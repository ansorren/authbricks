// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"go.authbricks.com/bricks/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"go.authbricks.com/bricks/ent/authorizationcode"
	"go.authbricks.com/bricks/ent/authorizationpayload"
	"go.authbricks.com/bricks/ent/codegrant"
	"go.authbricks.com/bricks/ent/cookiestore"
	"go.authbricks.com/bricks/ent/credentials"
	"go.authbricks.com/bricks/ent/keyset"
	"go.authbricks.com/bricks/ent/m2mgrant"
	"go.authbricks.com/bricks/ent/oauthclient"
	"go.authbricks.com/bricks/ent/oauthserver"
	"go.authbricks.com/bricks/ent/refreshtoken"
	"go.authbricks.com/bricks/ent/session"
	"go.authbricks.com/bricks/ent/signingkey"
	"go.authbricks.com/bricks/ent/standardclaims"
	"go.authbricks.com/bricks/ent/user"
	"go.authbricks.com/bricks/ent/userpool"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AuthorizationCode is the client for interacting with the AuthorizationCode builders.
	AuthorizationCode *AuthorizationCodeClient
	// AuthorizationPayload is the client for interacting with the AuthorizationPayload builders.
	AuthorizationPayload *AuthorizationPayloadClient
	// CodeGrant is the client for interacting with the CodeGrant builders.
	CodeGrant *CodeGrantClient
	// CookieStore is the client for interacting with the CookieStore builders.
	CookieStore *CookieStoreClient
	// Credentials is the client for interacting with the Credentials builders.
	Credentials *CredentialsClient
	// KeySet is the client for interacting with the KeySet builders.
	KeySet *KeySetClient
	// M2MGrant is the client for interacting with the M2MGrant builders.
	M2MGrant *M2MGrantClient
	// OAuthClient is the client for interacting with the OAuthClient builders.
	OAuthClient *OAuthClientClient
	// OAuthServer is the client for interacting with the OAuthServer builders.
	OAuthServer *OAuthServerClient
	// RefreshToken is the client for interacting with the RefreshToken builders.
	RefreshToken *RefreshTokenClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// SigningKey is the client for interacting with the SigningKey builders.
	SigningKey *SigningKeyClient
	// StandardClaims is the client for interacting with the StandardClaims builders.
	StandardClaims *StandardClaimsClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserPool is the client for interacting with the UserPool builders.
	UserPool *UserPoolClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AuthorizationCode = NewAuthorizationCodeClient(c.config)
	c.AuthorizationPayload = NewAuthorizationPayloadClient(c.config)
	c.CodeGrant = NewCodeGrantClient(c.config)
	c.CookieStore = NewCookieStoreClient(c.config)
	c.Credentials = NewCredentialsClient(c.config)
	c.KeySet = NewKeySetClient(c.config)
	c.M2MGrant = NewM2MGrantClient(c.config)
	c.OAuthClient = NewOAuthClientClient(c.config)
	c.OAuthServer = NewOAuthServerClient(c.config)
	c.RefreshToken = NewRefreshTokenClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.SigningKey = NewSigningKeyClient(c.config)
	c.StandardClaims = NewStandardClaimsClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserPool = NewUserPoolClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		AuthorizationCode:    NewAuthorizationCodeClient(cfg),
		AuthorizationPayload: NewAuthorizationPayloadClient(cfg),
		CodeGrant:            NewCodeGrantClient(cfg),
		CookieStore:          NewCookieStoreClient(cfg),
		Credentials:          NewCredentialsClient(cfg),
		KeySet:               NewKeySetClient(cfg),
		M2MGrant:             NewM2MGrantClient(cfg),
		OAuthClient:          NewOAuthClientClient(cfg),
		OAuthServer:          NewOAuthServerClient(cfg),
		RefreshToken:         NewRefreshTokenClient(cfg),
		Session:              NewSessionClient(cfg),
		SigningKey:           NewSigningKeyClient(cfg),
		StandardClaims:       NewStandardClaimsClient(cfg),
		User:                 NewUserClient(cfg),
		UserPool:             NewUserPoolClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		AuthorizationCode:    NewAuthorizationCodeClient(cfg),
		AuthorizationPayload: NewAuthorizationPayloadClient(cfg),
		CodeGrant:            NewCodeGrantClient(cfg),
		CookieStore:          NewCookieStoreClient(cfg),
		Credentials:          NewCredentialsClient(cfg),
		KeySet:               NewKeySetClient(cfg),
		M2MGrant:             NewM2MGrantClient(cfg),
		OAuthClient:          NewOAuthClientClient(cfg),
		OAuthServer:          NewOAuthServerClient(cfg),
		RefreshToken:         NewRefreshTokenClient(cfg),
		Session:              NewSessionClient(cfg),
		SigningKey:           NewSigningKeyClient(cfg),
		StandardClaims:       NewStandardClaimsClient(cfg),
		User:                 NewUserClient(cfg),
		UserPool:             NewUserPoolClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AuthorizationCode.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AuthorizationCode, c.AuthorizationPayload, c.CodeGrant, c.CookieStore,
		c.Credentials, c.KeySet, c.M2MGrant, c.OAuthClient, c.OAuthServer,
		c.RefreshToken, c.Session, c.SigningKey, c.StandardClaims, c.User, c.UserPool,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AuthorizationCode, c.AuthorizationPayload, c.CodeGrant, c.CookieStore,
		c.Credentials, c.KeySet, c.M2MGrant, c.OAuthClient, c.OAuthServer,
		c.RefreshToken, c.Session, c.SigningKey, c.StandardClaims, c.User, c.UserPool,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AuthorizationCodeMutation:
		return c.AuthorizationCode.mutate(ctx, m)
	case *AuthorizationPayloadMutation:
		return c.AuthorizationPayload.mutate(ctx, m)
	case *CodeGrantMutation:
		return c.CodeGrant.mutate(ctx, m)
	case *CookieStoreMutation:
		return c.CookieStore.mutate(ctx, m)
	case *CredentialsMutation:
		return c.Credentials.mutate(ctx, m)
	case *KeySetMutation:
		return c.KeySet.mutate(ctx, m)
	case *M2MGrantMutation:
		return c.M2MGrant.mutate(ctx, m)
	case *OAuthClientMutation:
		return c.OAuthClient.mutate(ctx, m)
	case *OAuthServerMutation:
		return c.OAuthServer.mutate(ctx, m)
	case *RefreshTokenMutation:
		return c.RefreshToken.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *SigningKeyMutation:
		return c.SigningKey.mutate(ctx, m)
	case *StandardClaimsMutation:
		return c.StandardClaims.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserPoolMutation:
		return c.UserPool.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AuthorizationCodeClient is a client for the AuthorizationCode schema.
type AuthorizationCodeClient struct {
	config
}

// NewAuthorizationCodeClient returns a client for the AuthorizationCode from the given config.
func NewAuthorizationCodeClient(c config) *AuthorizationCodeClient {
	return &AuthorizationCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizationcode.Hooks(f(g(h())))`.
func (c *AuthorizationCodeClient) Use(hooks ...Hook) {
	c.hooks.AuthorizationCode = append(c.hooks.AuthorizationCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizationcode.Intercept(f(g(h())))`.
func (c *AuthorizationCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizationCode = append(c.inters.AuthorizationCode, interceptors...)
}

// Create returns a builder for creating a AuthorizationCode entity.
func (c *AuthorizationCodeClient) Create() *AuthorizationCodeCreate {
	mutation := newAuthorizationCodeMutation(c.config, OpCreate)
	return &AuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizationCode entities.
func (c *AuthorizationCodeClient) CreateBulk(builders ...*AuthorizationCodeCreate) *AuthorizationCodeCreateBulk {
	return &AuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthorizationCodeClient) MapCreateBulk(slice any, setFunc func(*AuthorizationCodeCreate, int)) *AuthorizationCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthorizationCodeCreateBulk{err: fmt.Errorf("calling to AuthorizationCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthorizationCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Update() *AuthorizationCodeUpdate {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdate)
	return &AuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizationCodeClient) UpdateOne(ac *AuthorizationCode) *AuthorizationCodeUpdateOne {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdateOne, withAuthorizationCode(ac))
	return &AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizationCodeClient) UpdateOneID(id string) *AuthorizationCodeUpdateOne {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdateOne, withAuthorizationCodeID(id))
	return &AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Delete() *AuthorizationCodeDelete {
	mutation := newAuthorizationCodeMutation(c.config, OpDelete)
	return &AuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizationCodeClient) DeleteOne(ac *AuthorizationCode) *AuthorizationCodeDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizationCodeClient) DeleteOneID(id string) *AuthorizationCodeDeleteOne {
	builder := c.Delete().Where(authorizationcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizationCodeDeleteOne{builder}
}

// Query returns a query builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Query() *AuthorizationCodeQuery {
	return &AuthorizationCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizationCode},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizationCode entity by its id.
func (c *AuthorizationCodeClient) Get(ctx context.Context, id string) (*AuthorizationCode, error) {
	return c.Query().Where(authorizationcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizationCodeClient) GetX(ctx context.Context, id string) *AuthorizationCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthorizationCodeClient) Hooks() []Hook {
	return c.hooks.AuthorizationCode
}

// Interceptors returns the client interceptors.
func (c *AuthorizationCodeClient) Interceptors() []Interceptor {
	return c.inters.AuthorizationCode
}

func (c *AuthorizationCodeClient) mutate(ctx context.Context, m *AuthorizationCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizationCode mutation op: %q", m.Op())
	}
}

// AuthorizationPayloadClient is a client for the AuthorizationPayload schema.
type AuthorizationPayloadClient struct {
	config
}

// NewAuthorizationPayloadClient returns a client for the AuthorizationPayload from the given config.
func NewAuthorizationPayloadClient(c config) *AuthorizationPayloadClient {
	return &AuthorizationPayloadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizationpayload.Hooks(f(g(h())))`.
func (c *AuthorizationPayloadClient) Use(hooks ...Hook) {
	c.hooks.AuthorizationPayload = append(c.hooks.AuthorizationPayload, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizationpayload.Intercept(f(g(h())))`.
func (c *AuthorizationPayloadClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizationPayload = append(c.inters.AuthorizationPayload, interceptors...)
}

// Create returns a builder for creating a AuthorizationPayload entity.
func (c *AuthorizationPayloadClient) Create() *AuthorizationPayloadCreate {
	mutation := newAuthorizationPayloadMutation(c.config, OpCreate)
	return &AuthorizationPayloadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizationPayload entities.
func (c *AuthorizationPayloadClient) CreateBulk(builders ...*AuthorizationPayloadCreate) *AuthorizationPayloadCreateBulk {
	return &AuthorizationPayloadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthorizationPayloadClient) MapCreateBulk(slice any, setFunc func(*AuthorizationPayloadCreate, int)) *AuthorizationPayloadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthorizationPayloadCreateBulk{err: fmt.Errorf("calling to AuthorizationPayloadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthorizationPayloadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthorizationPayloadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizationPayload.
func (c *AuthorizationPayloadClient) Update() *AuthorizationPayloadUpdate {
	mutation := newAuthorizationPayloadMutation(c.config, OpUpdate)
	return &AuthorizationPayloadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizationPayloadClient) UpdateOne(ap *AuthorizationPayload) *AuthorizationPayloadUpdateOne {
	mutation := newAuthorizationPayloadMutation(c.config, OpUpdateOne, withAuthorizationPayload(ap))
	return &AuthorizationPayloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizationPayloadClient) UpdateOneID(id string) *AuthorizationPayloadUpdateOne {
	mutation := newAuthorizationPayloadMutation(c.config, OpUpdateOne, withAuthorizationPayloadID(id))
	return &AuthorizationPayloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizationPayload.
func (c *AuthorizationPayloadClient) Delete() *AuthorizationPayloadDelete {
	mutation := newAuthorizationPayloadMutation(c.config, OpDelete)
	return &AuthorizationPayloadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizationPayloadClient) DeleteOne(ap *AuthorizationPayload) *AuthorizationPayloadDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizationPayloadClient) DeleteOneID(id string) *AuthorizationPayloadDeleteOne {
	builder := c.Delete().Where(authorizationpayload.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizationPayloadDeleteOne{builder}
}

// Query returns a query builder for AuthorizationPayload.
func (c *AuthorizationPayloadClient) Query() *AuthorizationPayloadQuery {
	return &AuthorizationPayloadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizationPayload},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizationPayload entity by its id.
func (c *AuthorizationPayloadClient) Get(ctx context.Context, id string) (*AuthorizationPayload, error) {
	return c.Query().Where(authorizationpayload.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizationPayloadClient) GetX(ctx context.Context, id string) *AuthorizationPayload {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a AuthorizationPayload.
func (c *AuthorizationPayloadClient) QuerySession(ap *AuthorizationPayload) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authorizationpayload.Table, authorizationpayload.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, authorizationpayload.SessionTable, authorizationpayload.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthorizationPayloadClient) Hooks() []Hook {
	return c.hooks.AuthorizationPayload
}

// Interceptors returns the client interceptors.
func (c *AuthorizationPayloadClient) Interceptors() []Interceptor {
	return c.inters.AuthorizationPayload
}

func (c *AuthorizationPayloadClient) mutate(ctx context.Context, m *AuthorizationPayloadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizationPayloadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizationPayloadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizationPayloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizationPayloadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizationPayload mutation op: %q", m.Op())
	}
}

// CodeGrantClient is a client for the CodeGrant schema.
type CodeGrantClient struct {
	config
}

// NewCodeGrantClient returns a client for the CodeGrant from the given config.
func NewCodeGrantClient(c config) *CodeGrantClient {
	return &CodeGrantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `codegrant.Hooks(f(g(h())))`.
func (c *CodeGrantClient) Use(hooks ...Hook) {
	c.hooks.CodeGrant = append(c.hooks.CodeGrant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `codegrant.Intercept(f(g(h())))`.
func (c *CodeGrantClient) Intercept(interceptors ...Interceptor) {
	c.inters.CodeGrant = append(c.inters.CodeGrant, interceptors...)
}

// Create returns a builder for creating a CodeGrant entity.
func (c *CodeGrantClient) Create() *CodeGrantCreate {
	mutation := newCodeGrantMutation(c.config, OpCreate)
	return &CodeGrantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CodeGrant entities.
func (c *CodeGrantClient) CreateBulk(builders ...*CodeGrantCreate) *CodeGrantCreateBulk {
	return &CodeGrantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CodeGrantClient) MapCreateBulk(slice any, setFunc func(*CodeGrantCreate, int)) *CodeGrantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CodeGrantCreateBulk{err: fmt.Errorf("calling to CodeGrantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CodeGrantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CodeGrantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CodeGrant.
func (c *CodeGrantClient) Update() *CodeGrantUpdate {
	mutation := newCodeGrantMutation(c.config, OpUpdate)
	return &CodeGrantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CodeGrantClient) UpdateOne(cg *CodeGrant) *CodeGrantUpdateOne {
	mutation := newCodeGrantMutation(c.config, OpUpdateOne, withCodeGrant(cg))
	return &CodeGrantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CodeGrantClient) UpdateOneID(id string) *CodeGrantUpdateOne {
	mutation := newCodeGrantMutation(c.config, OpUpdateOne, withCodeGrantID(id))
	return &CodeGrantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CodeGrant.
func (c *CodeGrantClient) Delete() *CodeGrantDelete {
	mutation := newCodeGrantMutation(c.config, OpDelete)
	return &CodeGrantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CodeGrantClient) DeleteOne(cg *CodeGrant) *CodeGrantDeleteOne {
	return c.DeleteOneID(cg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CodeGrantClient) DeleteOneID(id string) *CodeGrantDeleteOne {
	builder := c.Delete().Where(codegrant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CodeGrantDeleteOne{builder}
}

// Query returns a query builder for CodeGrant.
func (c *CodeGrantClient) Query() *CodeGrantQuery {
	return &CodeGrantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCodeGrant},
		inters: c.Interceptors(),
	}
}

// Get returns a CodeGrant entity by its id.
func (c *CodeGrantClient) Get(ctx context.Context, id string) (*CodeGrant, error) {
	return c.Query().Where(codegrant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CodeGrantClient) GetX(ctx context.Context, id string) *CodeGrant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClient queries the client edge of a CodeGrant.
func (c *CodeGrantClient) QueryClient(cg *CodeGrant) *OAuthClientQuery {
	query := (&OAuthClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codegrant.Table, codegrant.FieldID, id),
			sqlgraph.To(oauthclient.Table, oauthclient.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, codegrant.ClientTable, codegrant.ClientColumn),
		)
		fromV = sqlgraph.Neighbors(cg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CodeGrantClient) Hooks() []Hook {
	return c.hooks.CodeGrant
}

// Interceptors returns the client interceptors.
func (c *CodeGrantClient) Interceptors() []Interceptor {
	return c.inters.CodeGrant
}

func (c *CodeGrantClient) mutate(ctx context.Context, m *CodeGrantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CodeGrantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CodeGrantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CodeGrantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CodeGrantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CodeGrant mutation op: %q", m.Op())
	}
}

// CookieStoreClient is a client for the CookieStore schema.
type CookieStoreClient struct {
	config
}

// NewCookieStoreClient returns a client for the CookieStore from the given config.
func NewCookieStoreClient(c config) *CookieStoreClient {
	return &CookieStoreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cookiestore.Hooks(f(g(h())))`.
func (c *CookieStoreClient) Use(hooks ...Hook) {
	c.hooks.CookieStore = append(c.hooks.CookieStore, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cookiestore.Intercept(f(g(h())))`.
func (c *CookieStoreClient) Intercept(interceptors ...Interceptor) {
	c.inters.CookieStore = append(c.inters.CookieStore, interceptors...)
}

// Create returns a builder for creating a CookieStore entity.
func (c *CookieStoreClient) Create() *CookieStoreCreate {
	mutation := newCookieStoreMutation(c.config, OpCreate)
	return &CookieStoreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CookieStore entities.
func (c *CookieStoreClient) CreateBulk(builders ...*CookieStoreCreate) *CookieStoreCreateBulk {
	return &CookieStoreCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CookieStoreClient) MapCreateBulk(slice any, setFunc func(*CookieStoreCreate, int)) *CookieStoreCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CookieStoreCreateBulk{err: fmt.Errorf("calling to CookieStoreClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CookieStoreCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CookieStoreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CookieStore.
func (c *CookieStoreClient) Update() *CookieStoreUpdate {
	mutation := newCookieStoreMutation(c.config, OpUpdate)
	return &CookieStoreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CookieStoreClient) UpdateOne(cs *CookieStore) *CookieStoreUpdateOne {
	mutation := newCookieStoreMutation(c.config, OpUpdateOne, withCookieStore(cs))
	return &CookieStoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CookieStoreClient) UpdateOneID(id string) *CookieStoreUpdateOne {
	mutation := newCookieStoreMutation(c.config, OpUpdateOne, withCookieStoreID(id))
	return &CookieStoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CookieStore.
func (c *CookieStoreClient) Delete() *CookieStoreDelete {
	mutation := newCookieStoreMutation(c.config, OpDelete)
	return &CookieStoreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CookieStoreClient) DeleteOne(cs *CookieStore) *CookieStoreDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CookieStoreClient) DeleteOneID(id string) *CookieStoreDeleteOne {
	builder := c.Delete().Where(cookiestore.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CookieStoreDeleteOne{builder}
}

// Query returns a query builder for CookieStore.
func (c *CookieStoreClient) Query() *CookieStoreQuery {
	return &CookieStoreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCookieStore},
		inters: c.Interceptors(),
	}
}

// Get returns a CookieStore entity by its id.
func (c *CookieStoreClient) Get(ctx context.Context, id string) (*CookieStore, error) {
	return c.Query().Where(cookiestore.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CookieStoreClient) GetX(ctx context.Context, id string) *CookieStore {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CookieStoreClient) Hooks() []Hook {
	return c.hooks.CookieStore
}

// Interceptors returns the client interceptors.
func (c *CookieStoreClient) Interceptors() []Interceptor {
	return c.inters.CookieStore
}

func (c *CookieStoreClient) mutate(ctx context.Context, m *CookieStoreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CookieStoreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CookieStoreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CookieStoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CookieStoreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CookieStore mutation op: %q", m.Op())
	}
}

// CredentialsClient is a client for the Credentials schema.
type CredentialsClient struct {
	config
}

// NewCredentialsClient returns a client for the Credentials from the given config.
func NewCredentialsClient(c config) *CredentialsClient {
	return &CredentialsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `credentials.Hooks(f(g(h())))`.
func (c *CredentialsClient) Use(hooks ...Hook) {
	c.hooks.Credentials = append(c.hooks.Credentials, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `credentials.Intercept(f(g(h())))`.
func (c *CredentialsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Credentials = append(c.inters.Credentials, interceptors...)
}

// Create returns a builder for creating a Credentials entity.
func (c *CredentialsClient) Create() *CredentialsCreate {
	mutation := newCredentialsMutation(c.config, OpCreate)
	return &CredentialsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Credentials entities.
func (c *CredentialsClient) CreateBulk(builders ...*CredentialsCreate) *CredentialsCreateBulk {
	return &CredentialsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CredentialsClient) MapCreateBulk(slice any, setFunc func(*CredentialsCreate, int)) *CredentialsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CredentialsCreateBulk{err: fmt.Errorf("calling to CredentialsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CredentialsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CredentialsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Credentials.
func (c *CredentialsClient) Update() *CredentialsUpdate {
	mutation := newCredentialsMutation(c.config, OpUpdate)
	return &CredentialsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CredentialsClient) UpdateOne(cr *Credentials) *CredentialsUpdateOne {
	mutation := newCredentialsMutation(c.config, OpUpdateOne, withCredentials(cr))
	return &CredentialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CredentialsClient) UpdateOneID(id string) *CredentialsUpdateOne {
	mutation := newCredentialsMutation(c.config, OpUpdateOne, withCredentialsID(id))
	return &CredentialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Credentials.
func (c *CredentialsClient) Delete() *CredentialsDelete {
	mutation := newCredentialsMutation(c.config, OpDelete)
	return &CredentialsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CredentialsClient) DeleteOne(cr *Credentials) *CredentialsDeleteOne {
	return c.DeleteOneID(cr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CredentialsClient) DeleteOneID(id string) *CredentialsDeleteOne {
	builder := c.Delete().Where(credentials.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CredentialsDeleteOne{builder}
}

// Query returns a query builder for Credentials.
func (c *CredentialsClient) Query() *CredentialsQuery {
	return &CredentialsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCredentials},
		inters: c.Interceptors(),
	}
}

// Get returns a Credentials entity by its id.
func (c *CredentialsClient) Get(ctx context.Context, id string) (*Credentials, error) {
	return c.Query().Where(credentials.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CredentialsClient) GetX(ctx context.Context, id string) *Credentials {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOauthClient queries the oauth_client edge of a Credentials.
func (c *CredentialsClient) QueryOauthClient(cr *Credentials) *OAuthClientQuery {
	query := (&OAuthClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(credentials.Table, credentials.FieldID, id),
			sqlgraph.To(oauthclient.Table, oauthclient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, credentials.OauthClientTable, credentials.OauthClientColumn),
		)
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CredentialsClient) Hooks() []Hook {
	return c.hooks.Credentials
}

// Interceptors returns the client interceptors.
func (c *CredentialsClient) Interceptors() []Interceptor {
	return c.inters.Credentials
}

func (c *CredentialsClient) mutate(ctx context.Context, m *CredentialsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CredentialsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CredentialsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CredentialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CredentialsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Credentials mutation op: %q", m.Op())
	}
}

// KeySetClient is a client for the KeySet schema.
type KeySetClient struct {
	config
}

// NewKeySetClient returns a client for the KeySet from the given config.
func NewKeySetClient(c config) *KeySetClient {
	return &KeySetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `keyset.Hooks(f(g(h())))`.
func (c *KeySetClient) Use(hooks ...Hook) {
	c.hooks.KeySet = append(c.hooks.KeySet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `keyset.Intercept(f(g(h())))`.
func (c *KeySetClient) Intercept(interceptors ...Interceptor) {
	c.inters.KeySet = append(c.inters.KeySet, interceptors...)
}

// Create returns a builder for creating a KeySet entity.
func (c *KeySetClient) Create() *KeySetCreate {
	mutation := newKeySetMutation(c.config, OpCreate)
	return &KeySetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of KeySet entities.
func (c *KeySetClient) CreateBulk(builders ...*KeySetCreate) *KeySetCreateBulk {
	return &KeySetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *KeySetClient) MapCreateBulk(slice any, setFunc func(*KeySetCreate, int)) *KeySetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &KeySetCreateBulk{err: fmt.Errorf("calling to KeySetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*KeySetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &KeySetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for KeySet.
func (c *KeySetClient) Update() *KeySetUpdate {
	mutation := newKeySetMutation(c.config, OpUpdate)
	return &KeySetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *KeySetClient) UpdateOne(ks *KeySet) *KeySetUpdateOne {
	mutation := newKeySetMutation(c.config, OpUpdateOne, withKeySet(ks))
	return &KeySetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *KeySetClient) UpdateOneID(id string) *KeySetUpdateOne {
	mutation := newKeySetMutation(c.config, OpUpdateOne, withKeySetID(id))
	return &KeySetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for KeySet.
func (c *KeySetClient) Delete() *KeySetDelete {
	mutation := newKeySetMutation(c.config, OpDelete)
	return &KeySetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *KeySetClient) DeleteOne(ks *KeySet) *KeySetDeleteOne {
	return c.DeleteOneID(ks.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *KeySetClient) DeleteOneID(id string) *KeySetDeleteOne {
	builder := c.Delete().Where(keyset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &KeySetDeleteOne{builder}
}

// Query returns a query builder for KeySet.
func (c *KeySetClient) Query() *KeySetQuery {
	return &KeySetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeKeySet},
		inters: c.Interceptors(),
	}
}

// Get returns a KeySet entity by its id.
func (c *KeySetClient) Get(ctx context.Context, id string) (*KeySet, error) {
	return c.Query().Where(keyset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *KeySetClient) GetX(ctx context.Context, id string) *KeySet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOauthServer queries the oauth_server edge of a KeySet.
func (c *KeySetClient) QueryOauthServer(ks *KeySet) *OAuthServerQuery {
	query := (&OAuthServerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ks.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(keyset.Table, keyset.FieldID, id),
			sqlgraph.To(oauthserver.Table, oauthserver.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, keyset.OauthServerTable, keyset.OauthServerColumn),
		)
		fromV = sqlgraph.Neighbors(ks.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySigningKeys queries the signing_keys edge of a KeySet.
func (c *KeySetClient) QuerySigningKeys(ks *KeySet) *SigningKeyQuery {
	query := (&SigningKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ks.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(keyset.Table, keyset.FieldID, id),
			sqlgraph.To(signingkey.Table, signingkey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, keyset.SigningKeysTable, keyset.SigningKeysColumn),
		)
		fromV = sqlgraph.Neighbors(ks.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *KeySetClient) Hooks() []Hook {
	return c.hooks.KeySet
}

// Interceptors returns the client interceptors.
func (c *KeySetClient) Interceptors() []Interceptor {
	return c.inters.KeySet
}

func (c *KeySetClient) mutate(ctx context.Context, m *KeySetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&KeySetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&KeySetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&KeySetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&KeySetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown KeySet mutation op: %q", m.Op())
	}
}

// M2MGrantClient is a client for the M2MGrant schema.
type M2MGrantClient struct {
	config
}

// NewM2MGrantClient returns a client for the M2MGrant from the given config.
func NewM2MGrantClient(c config) *M2MGrantClient {
	return &M2MGrantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `m2mgrant.Hooks(f(g(h())))`.
func (c *M2MGrantClient) Use(hooks ...Hook) {
	c.hooks.M2MGrant = append(c.hooks.M2MGrant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `m2mgrant.Intercept(f(g(h())))`.
func (c *M2MGrantClient) Intercept(interceptors ...Interceptor) {
	c.inters.M2MGrant = append(c.inters.M2MGrant, interceptors...)
}

// Create returns a builder for creating a M2MGrant entity.
func (c *M2MGrantClient) Create() *M2MGrantCreate {
	mutation := newM2MGrantMutation(c.config, OpCreate)
	return &M2MGrantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of M2MGrant entities.
func (c *M2MGrantClient) CreateBulk(builders ...*M2MGrantCreate) *M2MGrantCreateBulk {
	return &M2MGrantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *M2MGrantClient) MapCreateBulk(slice any, setFunc func(*M2MGrantCreate, int)) *M2MGrantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &M2MGrantCreateBulk{err: fmt.Errorf("calling to M2MGrantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*M2MGrantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &M2MGrantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for M2MGrant.
func (c *M2MGrantClient) Update() *M2MGrantUpdate {
	mutation := newM2MGrantMutation(c.config, OpUpdate)
	return &M2MGrantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *M2MGrantClient) UpdateOne(mg *M2MGrant) *M2MGrantUpdateOne {
	mutation := newM2MGrantMutation(c.config, OpUpdateOne, withM2MGrant(mg))
	return &M2MGrantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *M2MGrantClient) UpdateOneID(id string) *M2MGrantUpdateOne {
	mutation := newM2MGrantMutation(c.config, OpUpdateOne, withM2MGrantID(id))
	return &M2MGrantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for M2MGrant.
func (c *M2MGrantClient) Delete() *M2MGrantDelete {
	mutation := newM2MGrantMutation(c.config, OpDelete)
	return &M2MGrantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *M2MGrantClient) DeleteOne(mg *M2MGrant) *M2MGrantDeleteOne {
	return c.DeleteOneID(mg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *M2MGrantClient) DeleteOneID(id string) *M2MGrantDeleteOne {
	builder := c.Delete().Where(m2mgrant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &M2MGrantDeleteOne{builder}
}

// Query returns a query builder for M2MGrant.
func (c *M2MGrantClient) Query() *M2MGrantQuery {
	return &M2MGrantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeM2MGrant},
		inters: c.Interceptors(),
	}
}

// Get returns a M2MGrant entity by its id.
func (c *M2MGrantClient) Get(ctx context.Context, id string) (*M2MGrant, error) {
	return c.Query().Where(m2mgrant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *M2MGrantClient) GetX(ctx context.Context, id string) *M2MGrant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClient queries the client edge of a M2MGrant.
func (c *M2MGrantClient) QueryClient(mg *M2MGrant) *OAuthClientQuery {
	query := (&OAuthClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(m2mgrant.Table, m2mgrant.FieldID, id),
			sqlgraph.To(oauthclient.Table, oauthclient.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, m2mgrant.ClientTable, m2mgrant.ClientColumn),
		)
		fromV = sqlgraph.Neighbors(mg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *M2MGrantClient) Hooks() []Hook {
	return c.hooks.M2MGrant
}

// Interceptors returns the client interceptors.
func (c *M2MGrantClient) Interceptors() []Interceptor {
	return c.inters.M2MGrant
}

func (c *M2MGrantClient) mutate(ctx context.Context, m *M2MGrantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&M2MGrantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&M2MGrantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&M2MGrantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&M2MGrantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown M2MGrant mutation op: %q", m.Op())
	}
}

// OAuthClientClient is a client for the OAuthClient schema.
type OAuthClientClient struct {
	config
}

// NewOAuthClientClient returns a client for the OAuthClient from the given config.
func NewOAuthClientClient(c config) *OAuthClientClient {
	return &OAuthClientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthclient.Hooks(f(g(h())))`.
func (c *OAuthClientClient) Use(hooks ...Hook) {
	c.hooks.OAuthClient = append(c.hooks.OAuthClient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthclient.Intercept(f(g(h())))`.
func (c *OAuthClientClient) Intercept(interceptors ...Interceptor) {
	c.inters.OAuthClient = append(c.inters.OAuthClient, interceptors...)
}

// Create returns a builder for creating a OAuthClient entity.
func (c *OAuthClientClient) Create() *OAuthClientCreate {
	mutation := newOAuthClientMutation(c.config, OpCreate)
	return &OAuthClientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OAuthClient entities.
func (c *OAuthClientClient) CreateBulk(builders ...*OAuthClientCreate) *OAuthClientCreateBulk {
	return &OAuthClientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OAuthClientClient) MapCreateBulk(slice any, setFunc func(*OAuthClientCreate, int)) *OAuthClientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OAuthClientCreateBulk{err: fmt.Errorf("calling to OAuthClientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OAuthClientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OAuthClientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OAuthClient.
func (c *OAuthClientClient) Update() *OAuthClientUpdate {
	mutation := newOAuthClientMutation(c.config, OpUpdate)
	return &OAuthClientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OAuthClientClient) UpdateOne(oc *OAuthClient) *OAuthClientUpdateOne {
	mutation := newOAuthClientMutation(c.config, OpUpdateOne, withOAuthClient(oc))
	return &OAuthClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OAuthClientClient) UpdateOneID(id string) *OAuthClientUpdateOne {
	mutation := newOAuthClientMutation(c.config, OpUpdateOne, withOAuthClientID(id))
	return &OAuthClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OAuthClient.
func (c *OAuthClientClient) Delete() *OAuthClientDelete {
	mutation := newOAuthClientMutation(c.config, OpDelete)
	return &OAuthClientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OAuthClientClient) DeleteOne(oc *OAuthClient) *OAuthClientDeleteOne {
	return c.DeleteOneID(oc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OAuthClientClient) DeleteOneID(id string) *OAuthClientDeleteOne {
	builder := c.Delete().Where(oauthclient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OAuthClientDeleteOne{builder}
}

// Query returns a query builder for OAuthClient.
func (c *OAuthClientClient) Query() *OAuthClientQuery {
	return &OAuthClientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOAuthClient},
		inters: c.Interceptors(),
	}
}

// Get returns a OAuthClient entity by its id.
func (c *OAuthClientClient) Get(ctx context.Context, id string) (*OAuthClient, error) {
	return c.Query().Where(oauthclient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OAuthClientClient) GetX(ctx context.Context, id string) *OAuthClient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryM2mGrants queries the m2m_grants edge of a OAuthClient.
func (c *OAuthClientClient) QueryM2mGrants(oc *OAuthClient) *M2MGrantQuery {
	query := (&M2MGrantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthclient.Table, oauthclient.FieldID, id),
			sqlgraph.To(m2mgrant.Table, m2mgrant.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oauthclient.M2mGrantsTable, oauthclient.M2mGrantsColumn),
		)
		fromV = sqlgraph.Neighbors(oc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCodeGrants queries the code_grants edge of a OAuthClient.
func (c *OAuthClientClient) QueryCodeGrants(oc *OAuthClient) *CodeGrantQuery {
	query := (&CodeGrantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthclient.Table, oauthclient.FieldID, id),
			sqlgraph.To(codegrant.Table, codegrant.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oauthclient.CodeGrantsTable, oauthclient.CodeGrantsColumn),
		)
		fromV = sqlgraph.Neighbors(oc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCredentials queries the credentials edge of a OAuthClient.
func (c *OAuthClientClient) QueryCredentials(oc *OAuthClient) *CredentialsQuery {
	query := (&CredentialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthclient.Table, oauthclient.FieldID, id),
			sqlgraph.To(credentials.Table, credentials.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthclient.CredentialsTable, oauthclient.CredentialsColumn),
		)
		fromV = sqlgraph.Neighbors(oc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServer queries the server edge of a OAuthClient.
func (c *OAuthClientClient) QueryServer(oc *OAuthClient) *OAuthServerQuery {
	query := (&OAuthServerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthclient.Table, oauthclient.FieldID, id),
			sqlgraph.To(oauthserver.Table, oauthserver.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthclient.ServerTable, oauthclient.ServerColumn),
		)
		fromV = sqlgraph.Neighbors(oc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OAuthClientClient) Hooks() []Hook {
	return c.hooks.OAuthClient
}

// Interceptors returns the client interceptors.
func (c *OAuthClientClient) Interceptors() []Interceptor {
	return c.inters.OAuthClient
}

func (c *OAuthClientClient) mutate(ctx context.Context, m *OAuthClientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OAuthClientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OAuthClientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OAuthClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OAuthClientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OAuthClient mutation op: %q", m.Op())
	}
}

// OAuthServerClient is a client for the OAuthServer schema.
type OAuthServerClient struct {
	config
}

// NewOAuthServerClient returns a client for the OAuthServer from the given config.
func NewOAuthServerClient(c config) *OAuthServerClient {
	return &OAuthServerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthserver.Hooks(f(g(h())))`.
func (c *OAuthServerClient) Use(hooks ...Hook) {
	c.hooks.OAuthServer = append(c.hooks.OAuthServer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthserver.Intercept(f(g(h())))`.
func (c *OAuthServerClient) Intercept(interceptors ...Interceptor) {
	c.inters.OAuthServer = append(c.inters.OAuthServer, interceptors...)
}

// Create returns a builder for creating a OAuthServer entity.
func (c *OAuthServerClient) Create() *OAuthServerCreate {
	mutation := newOAuthServerMutation(c.config, OpCreate)
	return &OAuthServerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OAuthServer entities.
func (c *OAuthServerClient) CreateBulk(builders ...*OAuthServerCreate) *OAuthServerCreateBulk {
	return &OAuthServerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OAuthServerClient) MapCreateBulk(slice any, setFunc func(*OAuthServerCreate, int)) *OAuthServerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OAuthServerCreateBulk{err: fmt.Errorf("calling to OAuthServerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OAuthServerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OAuthServerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OAuthServer.
func (c *OAuthServerClient) Update() *OAuthServerUpdate {
	mutation := newOAuthServerMutation(c.config, OpUpdate)
	return &OAuthServerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OAuthServerClient) UpdateOne(os *OAuthServer) *OAuthServerUpdateOne {
	mutation := newOAuthServerMutation(c.config, OpUpdateOne, withOAuthServer(os))
	return &OAuthServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OAuthServerClient) UpdateOneID(id int) *OAuthServerUpdateOne {
	mutation := newOAuthServerMutation(c.config, OpUpdateOne, withOAuthServerID(id))
	return &OAuthServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OAuthServer.
func (c *OAuthServerClient) Delete() *OAuthServerDelete {
	mutation := newOAuthServerMutation(c.config, OpDelete)
	return &OAuthServerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OAuthServerClient) DeleteOne(os *OAuthServer) *OAuthServerDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OAuthServerClient) DeleteOneID(id int) *OAuthServerDeleteOne {
	builder := c.Delete().Where(oauthserver.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OAuthServerDeleteOne{builder}
}

// Query returns a query builder for OAuthServer.
func (c *OAuthServerClient) Query() *OAuthServerQuery {
	return &OAuthServerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOAuthServer},
		inters: c.Interceptors(),
	}
}

// Get returns a OAuthServer entity by its id.
func (c *OAuthServerClient) Get(ctx context.Context, id int) (*OAuthServer, error) {
	return c.Query().Where(oauthserver.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OAuthServerClient) GetX(ctx context.Context, id int) *OAuthServer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKeySet queries the key_set edge of a OAuthServer.
func (c *OAuthServerClient) QueryKeySet(os *OAuthServer) *KeySetQuery {
	query := (&KeySetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthserver.Table, oauthserver.FieldID, id),
			sqlgraph.To(keyset.Table, keyset.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oauthserver.KeySetTable, oauthserver.KeySetColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClients queries the clients edge of a OAuthServer.
func (c *OAuthServerClient) QueryClients(os *OAuthServer) *OAuthClientQuery {
	query := (&OAuthClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthserver.Table, oauthserver.FieldID, id),
			sqlgraph.To(oauthclient.Table, oauthclient.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthserver.ClientsTable, oauthserver.ClientsColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OAuthServerClient) Hooks() []Hook {
	return c.hooks.OAuthServer
}

// Interceptors returns the client interceptors.
func (c *OAuthServerClient) Interceptors() []Interceptor {
	return c.inters.OAuthServer
}

func (c *OAuthServerClient) mutate(ctx context.Context, m *OAuthServerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OAuthServerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OAuthServerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OAuthServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OAuthServerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OAuthServer mutation op: %q", m.Op())
	}
}

// RefreshTokenClient is a client for the RefreshToken schema.
type RefreshTokenClient struct {
	config
}

// NewRefreshTokenClient returns a client for the RefreshToken from the given config.
func NewRefreshTokenClient(c config) *RefreshTokenClient {
	return &RefreshTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `refreshtoken.Hooks(f(g(h())))`.
func (c *RefreshTokenClient) Use(hooks ...Hook) {
	c.hooks.RefreshToken = append(c.hooks.RefreshToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `refreshtoken.Intercept(f(g(h())))`.
func (c *RefreshTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.RefreshToken = append(c.inters.RefreshToken, interceptors...)
}

// Create returns a builder for creating a RefreshToken entity.
func (c *RefreshTokenClient) Create() *RefreshTokenCreate {
	mutation := newRefreshTokenMutation(c.config, OpCreate)
	return &RefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RefreshToken entities.
func (c *RefreshTokenClient) CreateBulk(builders ...*RefreshTokenCreate) *RefreshTokenCreateBulk {
	return &RefreshTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RefreshTokenClient) MapCreateBulk(slice any, setFunc func(*RefreshTokenCreate, int)) *RefreshTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RefreshTokenCreateBulk{err: fmt.Errorf("calling to RefreshTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RefreshTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RefreshTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RefreshToken.
func (c *RefreshTokenClient) Update() *RefreshTokenUpdate {
	mutation := newRefreshTokenMutation(c.config, OpUpdate)
	return &RefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RefreshTokenClient) UpdateOne(rt *RefreshToken) *RefreshTokenUpdateOne {
	mutation := newRefreshTokenMutation(c.config, OpUpdateOne, withRefreshToken(rt))
	return &RefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RefreshTokenClient) UpdateOneID(id string) *RefreshTokenUpdateOne {
	mutation := newRefreshTokenMutation(c.config, OpUpdateOne, withRefreshTokenID(id))
	return &RefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RefreshToken.
func (c *RefreshTokenClient) Delete() *RefreshTokenDelete {
	mutation := newRefreshTokenMutation(c.config, OpDelete)
	return &RefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RefreshTokenClient) DeleteOne(rt *RefreshToken) *RefreshTokenDeleteOne {
	return c.DeleteOneID(rt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RefreshTokenClient) DeleteOneID(id string) *RefreshTokenDeleteOne {
	builder := c.Delete().Where(refreshtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RefreshTokenDeleteOne{builder}
}

// Query returns a query builder for RefreshToken.
func (c *RefreshTokenClient) Query() *RefreshTokenQuery {
	return &RefreshTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRefreshToken},
		inters: c.Interceptors(),
	}
}

// Get returns a RefreshToken entity by its id.
func (c *RefreshTokenClient) Get(ctx context.Context, id string) (*RefreshToken, error) {
	return c.Query().Where(refreshtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RefreshTokenClient) GetX(ctx context.Context, id string) *RefreshToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RefreshTokenClient) Hooks() []Hook {
	return c.hooks.RefreshToken
}

// Interceptors returns the client interceptors.
func (c *RefreshTokenClient) Interceptors() []Interceptor {
	return c.inters.RefreshToken
}

func (c *RefreshTokenClient) mutate(ctx context.Context, m *RefreshTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RefreshToken mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id string) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id string) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id string) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id string) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthorizationPayload queries the authorization_payload edge of a Session.
func (c *SessionClient) QueryAuthorizationPayload(s *Session) *AuthorizationPayloadQuery {
	query := (&AuthorizationPayloadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(authorizationpayload.Table, authorizationpayload.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, session.AuthorizationPayloadTable, session.AuthorizationPayloadColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// SigningKeyClient is a client for the SigningKey schema.
type SigningKeyClient struct {
	config
}

// NewSigningKeyClient returns a client for the SigningKey from the given config.
func NewSigningKeyClient(c config) *SigningKeyClient {
	return &SigningKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `signingkey.Hooks(f(g(h())))`.
func (c *SigningKeyClient) Use(hooks ...Hook) {
	c.hooks.SigningKey = append(c.hooks.SigningKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `signingkey.Intercept(f(g(h())))`.
func (c *SigningKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.SigningKey = append(c.inters.SigningKey, interceptors...)
}

// Create returns a builder for creating a SigningKey entity.
func (c *SigningKeyClient) Create() *SigningKeyCreate {
	mutation := newSigningKeyMutation(c.config, OpCreate)
	return &SigningKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SigningKey entities.
func (c *SigningKeyClient) CreateBulk(builders ...*SigningKeyCreate) *SigningKeyCreateBulk {
	return &SigningKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SigningKeyClient) MapCreateBulk(slice any, setFunc func(*SigningKeyCreate, int)) *SigningKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SigningKeyCreateBulk{err: fmt.Errorf("calling to SigningKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SigningKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SigningKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SigningKey.
func (c *SigningKeyClient) Update() *SigningKeyUpdate {
	mutation := newSigningKeyMutation(c.config, OpUpdate)
	return &SigningKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SigningKeyClient) UpdateOne(sk *SigningKey) *SigningKeyUpdateOne {
	mutation := newSigningKeyMutation(c.config, OpUpdateOne, withSigningKey(sk))
	return &SigningKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SigningKeyClient) UpdateOneID(id string) *SigningKeyUpdateOne {
	mutation := newSigningKeyMutation(c.config, OpUpdateOne, withSigningKeyID(id))
	return &SigningKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SigningKey.
func (c *SigningKeyClient) Delete() *SigningKeyDelete {
	mutation := newSigningKeyMutation(c.config, OpDelete)
	return &SigningKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SigningKeyClient) DeleteOne(sk *SigningKey) *SigningKeyDeleteOne {
	return c.DeleteOneID(sk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SigningKeyClient) DeleteOneID(id string) *SigningKeyDeleteOne {
	builder := c.Delete().Where(signingkey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SigningKeyDeleteOne{builder}
}

// Query returns a query builder for SigningKey.
func (c *SigningKeyClient) Query() *SigningKeyQuery {
	return &SigningKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSigningKey},
		inters: c.Interceptors(),
	}
}

// Get returns a SigningKey entity by its id.
func (c *SigningKeyClient) Get(ctx context.Context, id string) (*SigningKey, error) {
	return c.Query().Where(signingkey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SigningKeyClient) GetX(ctx context.Context, id string) *SigningKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKeySet queries the key_set edge of a SigningKey.
func (c *SigningKeyClient) QueryKeySet(sk *SigningKey) *KeySetQuery {
	query := (&KeySetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(signingkey.Table, signingkey.FieldID, id),
			sqlgraph.To(keyset.Table, keyset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, signingkey.KeySetTable, signingkey.KeySetColumn),
		)
		fromV = sqlgraph.Neighbors(sk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SigningKeyClient) Hooks() []Hook {
	return c.hooks.SigningKey
}

// Interceptors returns the client interceptors.
func (c *SigningKeyClient) Interceptors() []Interceptor {
	return c.inters.SigningKey
}

func (c *SigningKeyClient) mutate(ctx context.Context, m *SigningKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SigningKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SigningKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SigningKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SigningKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SigningKey mutation op: %q", m.Op())
	}
}

// StandardClaimsClient is a client for the StandardClaims schema.
type StandardClaimsClient struct {
	config
}

// NewStandardClaimsClient returns a client for the StandardClaims from the given config.
func NewStandardClaimsClient(c config) *StandardClaimsClient {
	return &StandardClaimsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `standardclaims.Hooks(f(g(h())))`.
func (c *StandardClaimsClient) Use(hooks ...Hook) {
	c.hooks.StandardClaims = append(c.hooks.StandardClaims, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `standardclaims.Intercept(f(g(h())))`.
func (c *StandardClaimsClient) Intercept(interceptors ...Interceptor) {
	c.inters.StandardClaims = append(c.inters.StandardClaims, interceptors...)
}

// Create returns a builder for creating a StandardClaims entity.
func (c *StandardClaimsClient) Create() *StandardClaimsCreate {
	mutation := newStandardClaimsMutation(c.config, OpCreate)
	return &StandardClaimsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StandardClaims entities.
func (c *StandardClaimsClient) CreateBulk(builders ...*StandardClaimsCreate) *StandardClaimsCreateBulk {
	return &StandardClaimsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StandardClaimsClient) MapCreateBulk(slice any, setFunc func(*StandardClaimsCreate, int)) *StandardClaimsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StandardClaimsCreateBulk{err: fmt.Errorf("calling to StandardClaimsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StandardClaimsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StandardClaimsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StandardClaims.
func (c *StandardClaimsClient) Update() *StandardClaimsUpdate {
	mutation := newStandardClaimsMutation(c.config, OpUpdate)
	return &StandardClaimsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StandardClaimsClient) UpdateOne(sc *StandardClaims) *StandardClaimsUpdateOne {
	mutation := newStandardClaimsMutation(c.config, OpUpdateOne, withStandardClaims(sc))
	return &StandardClaimsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StandardClaimsClient) UpdateOneID(id int) *StandardClaimsUpdateOne {
	mutation := newStandardClaimsMutation(c.config, OpUpdateOne, withStandardClaimsID(id))
	return &StandardClaimsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StandardClaims.
func (c *StandardClaimsClient) Delete() *StandardClaimsDelete {
	mutation := newStandardClaimsMutation(c.config, OpDelete)
	return &StandardClaimsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StandardClaimsClient) DeleteOne(sc *StandardClaims) *StandardClaimsDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StandardClaimsClient) DeleteOneID(id int) *StandardClaimsDeleteOne {
	builder := c.Delete().Where(standardclaims.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StandardClaimsDeleteOne{builder}
}

// Query returns a query builder for StandardClaims.
func (c *StandardClaimsClient) Query() *StandardClaimsQuery {
	return &StandardClaimsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStandardClaims},
		inters: c.Interceptors(),
	}
}

// Get returns a StandardClaims entity by its id.
func (c *StandardClaimsClient) Get(ctx context.Context, id int) (*StandardClaims, error) {
	return c.Query().Where(standardclaims.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StandardClaimsClient) GetX(ctx context.Context, id int) *StandardClaims {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a StandardClaims.
func (c *StandardClaimsClient) QueryUser(sc *StandardClaims) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standardclaims.Table, standardclaims.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, standardclaims.UserTable, standardclaims.UserColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StandardClaimsClient) Hooks() []Hook {
	return c.hooks.StandardClaims
}

// Interceptors returns the client interceptors.
func (c *StandardClaimsClient) Interceptors() []Interceptor {
	return c.inters.StandardClaims
}

func (c *StandardClaimsClient) mutate(ctx context.Context, m *StandardClaimsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StandardClaimsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StandardClaimsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StandardClaimsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StandardClaimsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StandardClaims mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserPool queries the user_pool edge of a User.
func (c *UserClient) QueryUserPool(u *User) *UserPoolQuery {
	query := (&UserPoolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userpool.Table, userpool.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.UserPoolTable, user.UserPoolColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandardClaims queries the standard_claims edge of a User.
func (c *UserClient) QueryStandardClaims(u *User) *StandardClaimsQuery {
	query := (&StandardClaimsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(standardclaims.Table, standardclaims.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.StandardClaimsTable, user.StandardClaimsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserPoolClient is a client for the UserPool schema.
type UserPoolClient struct {
	config
}

// NewUserPoolClient returns a client for the UserPool from the given config.
func NewUserPoolClient(c config) *UserPoolClient {
	return &UserPoolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userpool.Hooks(f(g(h())))`.
func (c *UserPoolClient) Use(hooks ...Hook) {
	c.hooks.UserPool = append(c.hooks.UserPool, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userpool.Intercept(f(g(h())))`.
func (c *UserPoolClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserPool = append(c.inters.UserPool, interceptors...)
}

// Create returns a builder for creating a UserPool entity.
func (c *UserPoolClient) Create() *UserPoolCreate {
	mutation := newUserPoolMutation(c.config, OpCreate)
	return &UserPoolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserPool entities.
func (c *UserPoolClient) CreateBulk(builders ...*UserPoolCreate) *UserPoolCreateBulk {
	return &UserPoolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserPoolClient) MapCreateBulk(slice any, setFunc func(*UserPoolCreate, int)) *UserPoolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserPoolCreateBulk{err: fmt.Errorf("calling to UserPoolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserPoolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserPoolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserPool.
func (c *UserPoolClient) Update() *UserPoolUpdate {
	mutation := newUserPoolMutation(c.config, OpUpdate)
	return &UserPoolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserPoolClient) UpdateOne(up *UserPool) *UserPoolUpdateOne {
	mutation := newUserPoolMutation(c.config, OpUpdateOne, withUserPool(up))
	return &UserPoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserPoolClient) UpdateOneID(id string) *UserPoolUpdateOne {
	mutation := newUserPoolMutation(c.config, OpUpdateOne, withUserPoolID(id))
	return &UserPoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserPool.
func (c *UserPoolClient) Delete() *UserPoolDelete {
	mutation := newUserPoolMutation(c.config, OpDelete)
	return &UserPoolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserPoolClient) DeleteOne(up *UserPool) *UserPoolDeleteOne {
	return c.DeleteOneID(up.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserPoolClient) DeleteOneID(id string) *UserPoolDeleteOne {
	builder := c.Delete().Where(userpool.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserPoolDeleteOne{builder}
}

// Query returns a query builder for UserPool.
func (c *UserPoolClient) Query() *UserPoolQuery {
	return &UserPoolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserPool},
		inters: c.Interceptors(),
	}
}

// Get returns a UserPool entity by its id.
func (c *UserPoolClient) Get(ctx context.Context, id string) (*UserPool, error) {
	return c.Query().Where(userpool.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserPoolClient) GetX(ctx context.Context, id string) *UserPool {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a UserPool.
func (c *UserPoolClient) QueryUsers(up *UserPool) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userpool.Table, userpool.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, userpool.UsersTable, userpool.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserPoolClient) Hooks() []Hook {
	return c.hooks.UserPool
}

// Interceptors returns the client interceptors.
func (c *UserPoolClient) Interceptors() []Interceptor {
	return c.inters.UserPool
}

func (c *UserPoolClient) mutate(ctx context.Context, m *UserPoolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserPoolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserPoolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserPoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserPoolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserPool mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AuthorizationCode, AuthorizationPayload, CodeGrant, CookieStore, Credentials,
		KeySet, M2MGrant, OAuthClient, OAuthServer, RefreshToken, Session, SigningKey,
		StandardClaims, User, UserPool []ent.Hook
	}
	inters struct {
		AuthorizationCode, AuthorizationPayload, CodeGrant, CookieStore, Credentials,
		KeySet, M2MGrant, OAuthClient, OAuthServer, RefreshToken, Session, SigningKey,
		StandardClaims, User, UserPool []ent.Interceptor
	}
)
