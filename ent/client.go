// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"go.authbricks.com/bricks/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"go.authbricks.com/bricks/ent/application"
	"go.authbricks.com/bricks/ent/authorizationcode"
	"go.authbricks.com/bricks/ent/authorizationendpointconfig"
	"go.authbricks.com/bricks/ent/authorizationpayload"
	"go.authbricks.com/bricks/ent/cookiestore"
	"go.authbricks.com/bricks/ent/credentials"
	"go.authbricks.com/bricks/ent/introspectionendpointconfig"
	"go.authbricks.com/bricks/ent/jwksendpointconfig"
	"go.authbricks.com/bricks/ent/keyset"
	"go.authbricks.com/bricks/ent/refreshtoken"
	"go.authbricks.com/bricks/ent/service"
	"go.authbricks.com/bricks/ent/session"
	"go.authbricks.com/bricks/ent/signingkey"
	"go.authbricks.com/bricks/ent/standardclaims"
	"go.authbricks.com/bricks/ent/tokenendpointconfig"
	"go.authbricks.com/bricks/ent/user"
	"go.authbricks.com/bricks/ent/userinfoendpointconfig"
	"go.authbricks.com/bricks/ent/userpool"
	"go.authbricks.com/bricks/ent/wellknownendpointconfig"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Application is the client for interacting with the Application builders.
	Application *ApplicationClient
	// AuthorizationCode is the client for interacting with the AuthorizationCode builders.
	AuthorizationCode *AuthorizationCodeClient
	// AuthorizationEndpointConfig is the client for interacting with the AuthorizationEndpointConfig builders.
	AuthorizationEndpointConfig *AuthorizationEndpointConfigClient
	// AuthorizationPayload is the client for interacting with the AuthorizationPayload builders.
	AuthorizationPayload *AuthorizationPayloadClient
	// CookieStore is the client for interacting with the CookieStore builders.
	CookieStore *CookieStoreClient
	// Credentials is the client for interacting with the Credentials builders.
	Credentials *CredentialsClient
	// IntrospectionEndpointConfig is the client for interacting with the IntrospectionEndpointConfig builders.
	IntrospectionEndpointConfig *IntrospectionEndpointConfigClient
	// JwksEndpointConfig is the client for interacting with the JwksEndpointConfig builders.
	JwksEndpointConfig *JwksEndpointConfigClient
	// KeySet is the client for interacting with the KeySet builders.
	KeySet *KeySetClient
	// RefreshToken is the client for interacting with the RefreshToken builders.
	RefreshToken *RefreshTokenClient
	// Service is the client for interacting with the Service builders.
	Service *ServiceClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// SigningKey is the client for interacting with the SigningKey builders.
	SigningKey *SigningKeyClient
	// StandardClaims is the client for interacting with the StandardClaims builders.
	StandardClaims *StandardClaimsClient
	// TokenEndpointConfig is the client for interacting with the TokenEndpointConfig builders.
	TokenEndpointConfig *TokenEndpointConfigClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserInfoEndpointConfig is the client for interacting with the UserInfoEndpointConfig builders.
	UserInfoEndpointConfig *UserInfoEndpointConfigClient
	// UserPool is the client for interacting with the UserPool builders.
	UserPool *UserPoolClient
	// WellKnownEndpointConfig is the client for interacting with the WellKnownEndpointConfig builders.
	WellKnownEndpointConfig *WellKnownEndpointConfigClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Application = NewApplicationClient(c.config)
	c.AuthorizationCode = NewAuthorizationCodeClient(c.config)
	c.AuthorizationEndpointConfig = NewAuthorizationEndpointConfigClient(c.config)
	c.AuthorizationPayload = NewAuthorizationPayloadClient(c.config)
	c.CookieStore = NewCookieStoreClient(c.config)
	c.Credentials = NewCredentialsClient(c.config)
	c.IntrospectionEndpointConfig = NewIntrospectionEndpointConfigClient(c.config)
	c.JwksEndpointConfig = NewJwksEndpointConfigClient(c.config)
	c.KeySet = NewKeySetClient(c.config)
	c.RefreshToken = NewRefreshTokenClient(c.config)
	c.Service = NewServiceClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.SigningKey = NewSigningKeyClient(c.config)
	c.StandardClaims = NewStandardClaimsClient(c.config)
	c.TokenEndpointConfig = NewTokenEndpointConfigClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserInfoEndpointConfig = NewUserInfoEndpointConfigClient(c.config)
	c.UserPool = NewUserPoolClient(c.config)
	c.WellKnownEndpointConfig = NewWellKnownEndpointConfigClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                         ctx,
		config:                      cfg,
		Application:                 NewApplicationClient(cfg),
		AuthorizationCode:           NewAuthorizationCodeClient(cfg),
		AuthorizationEndpointConfig: NewAuthorizationEndpointConfigClient(cfg),
		AuthorizationPayload:        NewAuthorizationPayloadClient(cfg),
		CookieStore:                 NewCookieStoreClient(cfg),
		Credentials:                 NewCredentialsClient(cfg),
		IntrospectionEndpointConfig: NewIntrospectionEndpointConfigClient(cfg),
		JwksEndpointConfig:          NewJwksEndpointConfigClient(cfg),
		KeySet:                      NewKeySetClient(cfg),
		RefreshToken:                NewRefreshTokenClient(cfg),
		Service:                     NewServiceClient(cfg),
		Session:                     NewSessionClient(cfg),
		SigningKey:                  NewSigningKeyClient(cfg),
		StandardClaims:              NewStandardClaimsClient(cfg),
		TokenEndpointConfig:         NewTokenEndpointConfigClient(cfg),
		User:                        NewUserClient(cfg),
		UserInfoEndpointConfig:      NewUserInfoEndpointConfigClient(cfg),
		UserPool:                    NewUserPoolClient(cfg),
		WellKnownEndpointConfig:     NewWellKnownEndpointConfigClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                         ctx,
		config:                      cfg,
		Application:                 NewApplicationClient(cfg),
		AuthorizationCode:           NewAuthorizationCodeClient(cfg),
		AuthorizationEndpointConfig: NewAuthorizationEndpointConfigClient(cfg),
		AuthorizationPayload:        NewAuthorizationPayloadClient(cfg),
		CookieStore:                 NewCookieStoreClient(cfg),
		Credentials:                 NewCredentialsClient(cfg),
		IntrospectionEndpointConfig: NewIntrospectionEndpointConfigClient(cfg),
		JwksEndpointConfig:          NewJwksEndpointConfigClient(cfg),
		KeySet:                      NewKeySetClient(cfg),
		RefreshToken:                NewRefreshTokenClient(cfg),
		Service:                     NewServiceClient(cfg),
		Session:                     NewSessionClient(cfg),
		SigningKey:                  NewSigningKeyClient(cfg),
		StandardClaims:              NewStandardClaimsClient(cfg),
		TokenEndpointConfig:         NewTokenEndpointConfigClient(cfg),
		User:                        NewUserClient(cfg),
		UserInfoEndpointConfig:      NewUserInfoEndpointConfigClient(cfg),
		UserPool:                    NewUserPoolClient(cfg),
		WellKnownEndpointConfig:     NewWellKnownEndpointConfigClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Application.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Application, c.AuthorizationCode, c.AuthorizationEndpointConfig,
		c.AuthorizationPayload, c.CookieStore, c.Credentials,
		c.IntrospectionEndpointConfig, c.JwksEndpointConfig, c.KeySet, c.RefreshToken,
		c.Service, c.Session, c.SigningKey, c.StandardClaims, c.TokenEndpointConfig,
		c.User, c.UserInfoEndpointConfig, c.UserPool, c.WellKnownEndpointConfig,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Application, c.AuthorizationCode, c.AuthorizationEndpointConfig,
		c.AuthorizationPayload, c.CookieStore, c.Credentials,
		c.IntrospectionEndpointConfig, c.JwksEndpointConfig, c.KeySet, c.RefreshToken,
		c.Service, c.Session, c.SigningKey, c.StandardClaims, c.TokenEndpointConfig,
		c.User, c.UserInfoEndpointConfig, c.UserPool, c.WellKnownEndpointConfig,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ApplicationMutation:
		return c.Application.mutate(ctx, m)
	case *AuthorizationCodeMutation:
		return c.AuthorizationCode.mutate(ctx, m)
	case *AuthorizationEndpointConfigMutation:
		return c.AuthorizationEndpointConfig.mutate(ctx, m)
	case *AuthorizationPayloadMutation:
		return c.AuthorizationPayload.mutate(ctx, m)
	case *CookieStoreMutation:
		return c.CookieStore.mutate(ctx, m)
	case *CredentialsMutation:
		return c.Credentials.mutate(ctx, m)
	case *IntrospectionEndpointConfigMutation:
		return c.IntrospectionEndpointConfig.mutate(ctx, m)
	case *JwksEndpointConfigMutation:
		return c.JwksEndpointConfig.mutate(ctx, m)
	case *KeySetMutation:
		return c.KeySet.mutate(ctx, m)
	case *RefreshTokenMutation:
		return c.RefreshToken.mutate(ctx, m)
	case *ServiceMutation:
		return c.Service.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *SigningKeyMutation:
		return c.SigningKey.mutate(ctx, m)
	case *StandardClaimsMutation:
		return c.StandardClaims.mutate(ctx, m)
	case *TokenEndpointConfigMutation:
		return c.TokenEndpointConfig.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserInfoEndpointConfigMutation:
		return c.UserInfoEndpointConfig.mutate(ctx, m)
	case *UserPoolMutation:
		return c.UserPool.mutate(ctx, m)
	case *WellKnownEndpointConfigMutation:
		return c.WellKnownEndpointConfig.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ApplicationClient is a client for the Application schema.
type ApplicationClient struct {
	config
}

// NewApplicationClient returns a client for the Application from the given config.
func NewApplicationClient(c config) *ApplicationClient {
	return &ApplicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `application.Hooks(f(g(h())))`.
func (c *ApplicationClient) Use(hooks ...Hook) {
	c.hooks.Application = append(c.hooks.Application, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `application.Intercept(f(g(h())))`.
func (c *ApplicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Application = append(c.inters.Application, interceptors...)
}

// Create returns a builder for creating a Application entity.
func (c *ApplicationClient) Create() *ApplicationCreate {
	mutation := newApplicationMutation(c.config, OpCreate)
	return &ApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Application entities.
func (c *ApplicationClient) CreateBulk(builders ...*ApplicationCreate) *ApplicationCreateBulk {
	return &ApplicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ApplicationClient) MapCreateBulk(slice any, setFunc func(*ApplicationCreate, int)) *ApplicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ApplicationCreateBulk{err: fmt.Errorf("calling to ApplicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ApplicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ApplicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Application.
func (c *ApplicationClient) Update() *ApplicationUpdate {
	mutation := newApplicationMutation(c.config, OpUpdate)
	return &ApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApplicationClient) UpdateOne(a *Application) *ApplicationUpdateOne {
	mutation := newApplicationMutation(c.config, OpUpdateOne, withApplication(a))
	return &ApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApplicationClient) UpdateOneID(id string) *ApplicationUpdateOne {
	mutation := newApplicationMutation(c.config, OpUpdateOne, withApplicationID(id))
	return &ApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Application.
func (c *ApplicationClient) Delete() *ApplicationDelete {
	mutation := newApplicationMutation(c.config, OpDelete)
	return &ApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApplicationClient) DeleteOne(a *Application) *ApplicationDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApplicationClient) DeleteOneID(id string) *ApplicationDeleteOne {
	builder := c.Delete().Where(application.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApplicationDeleteOne{builder}
}

// Query returns a query builder for Application.
func (c *ApplicationClient) Query() *ApplicationQuery {
	return &ApplicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApplication},
		inters: c.Interceptors(),
	}
}

// Get returns a Application entity by its id.
func (c *ApplicationClient) Get(ctx context.Context, id string) (*Application, error) {
	return c.Query().Where(application.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApplicationClient) GetX(ctx context.Context, id string) *Application {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCredentials queries the credentials edge of a Application.
func (c *ApplicationClient) QueryCredentials(a *Application) *CredentialsQuery {
	query := (&CredentialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(application.Table, application.FieldID, id),
			sqlgraph.To(credentials.Table, credentials.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, application.CredentialsTable, application.CredentialsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryService queries the service edge of a Application.
func (c *ApplicationClient) QueryService(a *Application) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(application.Table, application.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, application.ServiceTable, application.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ApplicationClient) Hooks() []Hook {
	return c.hooks.Application
}

// Interceptors returns the client interceptors.
func (c *ApplicationClient) Interceptors() []Interceptor {
	return c.inters.Application
}

func (c *ApplicationClient) mutate(ctx context.Context, m *ApplicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Application mutation op: %q", m.Op())
	}
}

// AuthorizationCodeClient is a client for the AuthorizationCode schema.
type AuthorizationCodeClient struct {
	config
}

// NewAuthorizationCodeClient returns a client for the AuthorizationCode from the given config.
func NewAuthorizationCodeClient(c config) *AuthorizationCodeClient {
	return &AuthorizationCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizationcode.Hooks(f(g(h())))`.
func (c *AuthorizationCodeClient) Use(hooks ...Hook) {
	c.hooks.AuthorizationCode = append(c.hooks.AuthorizationCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizationcode.Intercept(f(g(h())))`.
func (c *AuthorizationCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizationCode = append(c.inters.AuthorizationCode, interceptors...)
}

// Create returns a builder for creating a AuthorizationCode entity.
func (c *AuthorizationCodeClient) Create() *AuthorizationCodeCreate {
	mutation := newAuthorizationCodeMutation(c.config, OpCreate)
	return &AuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizationCode entities.
func (c *AuthorizationCodeClient) CreateBulk(builders ...*AuthorizationCodeCreate) *AuthorizationCodeCreateBulk {
	return &AuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthorizationCodeClient) MapCreateBulk(slice any, setFunc func(*AuthorizationCodeCreate, int)) *AuthorizationCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthorizationCodeCreateBulk{err: fmt.Errorf("calling to AuthorizationCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthorizationCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Update() *AuthorizationCodeUpdate {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdate)
	return &AuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizationCodeClient) UpdateOne(ac *AuthorizationCode) *AuthorizationCodeUpdateOne {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdateOne, withAuthorizationCode(ac))
	return &AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizationCodeClient) UpdateOneID(id string) *AuthorizationCodeUpdateOne {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdateOne, withAuthorizationCodeID(id))
	return &AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Delete() *AuthorizationCodeDelete {
	mutation := newAuthorizationCodeMutation(c.config, OpDelete)
	return &AuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizationCodeClient) DeleteOne(ac *AuthorizationCode) *AuthorizationCodeDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizationCodeClient) DeleteOneID(id string) *AuthorizationCodeDeleteOne {
	builder := c.Delete().Where(authorizationcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizationCodeDeleteOne{builder}
}

// Query returns a query builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Query() *AuthorizationCodeQuery {
	return &AuthorizationCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizationCode},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizationCode entity by its id.
func (c *AuthorizationCodeClient) Get(ctx context.Context, id string) (*AuthorizationCode, error) {
	return c.Query().Where(authorizationcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizationCodeClient) GetX(ctx context.Context, id string) *AuthorizationCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthorizationCodeClient) Hooks() []Hook {
	return c.hooks.AuthorizationCode
}

// Interceptors returns the client interceptors.
func (c *AuthorizationCodeClient) Interceptors() []Interceptor {
	return c.inters.AuthorizationCode
}

func (c *AuthorizationCodeClient) mutate(ctx context.Context, m *AuthorizationCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizationCode mutation op: %q", m.Op())
	}
}

// AuthorizationEndpointConfigClient is a client for the AuthorizationEndpointConfig schema.
type AuthorizationEndpointConfigClient struct {
	config
}

// NewAuthorizationEndpointConfigClient returns a client for the AuthorizationEndpointConfig from the given config.
func NewAuthorizationEndpointConfigClient(c config) *AuthorizationEndpointConfigClient {
	return &AuthorizationEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizationendpointconfig.Hooks(f(g(h())))`.
func (c *AuthorizationEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.AuthorizationEndpointConfig = append(c.hooks.AuthorizationEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizationendpointconfig.Intercept(f(g(h())))`.
func (c *AuthorizationEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizationEndpointConfig = append(c.inters.AuthorizationEndpointConfig, interceptors...)
}

// Create returns a builder for creating a AuthorizationEndpointConfig entity.
func (c *AuthorizationEndpointConfigClient) Create() *AuthorizationEndpointConfigCreate {
	mutation := newAuthorizationEndpointConfigMutation(c.config, OpCreate)
	return &AuthorizationEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizationEndpointConfig entities.
func (c *AuthorizationEndpointConfigClient) CreateBulk(builders ...*AuthorizationEndpointConfigCreate) *AuthorizationEndpointConfigCreateBulk {
	return &AuthorizationEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthorizationEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*AuthorizationEndpointConfigCreate, int)) *AuthorizationEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthorizationEndpointConfigCreateBulk{err: fmt.Errorf("calling to AuthorizationEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthorizationEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthorizationEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizationEndpointConfig.
func (c *AuthorizationEndpointConfigClient) Update() *AuthorizationEndpointConfigUpdate {
	mutation := newAuthorizationEndpointConfigMutation(c.config, OpUpdate)
	return &AuthorizationEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizationEndpointConfigClient) UpdateOne(aec *AuthorizationEndpointConfig) *AuthorizationEndpointConfigUpdateOne {
	mutation := newAuthorizationEndpointConfigMutation(c.config, OpUpdateOne, withAuthorizationEndpointConfig(aec))
	return &AuthorizationEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizationEndpointConfigClient) UpdateOneID(id string) *AuthorizationEndpointConfigUpdateOne {
	mutation := newAuthorizationEndpointConfigMutation(c.config, OpUpdateOne, withAuthorizationEndpointConfigID(id))
	return &AuthorizationEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizationEndpointConfig.
func (c *AuthorizationEndpointConfigClient) Delete() *AuthorizationEndpointConfigDelete {
	mutation := newAuthorizationEndpointConfigMutation(c.config, OpDelete)
	return &AuthorizationEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizationEndpointConfigClient) DeleteOne(aec *AuthorizationEndpointConfig) *AuthorizationEndpointConfigDeleteOne {
	return c.DeleteOneID(aec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizationEndpointConfigClient) DeleteOneID(id string) *AuthorizationEndpointConfigDeleteOne {
	builder := c.Delete().Where(authorizationendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizationEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for AuthorizationEndpointConfig.
func (c *AuthorizationEndpointConfigClient) Query() *AuthorizationEndpointConfigQuery {
	return &AuthorizationEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizationEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizationEndpointConfig entity by its id.
func (c *AuthorizationEndpointConfigClient) Get(ctx context.Context, id string) (*AuthorizationEndpointConfig, error) {
	return c.Query().Where(authorizationendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizationEndpointConfigClient) GetX(ctx context.Context, id string) *AuthorizationEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a AuthorizationEndpointConfig.
func (c *AuthorizationEndpointConfigClient) QueryService(aec *AuthorizationEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := aec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authorizationendpointconfig.Table, authorizationendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, authorizationendpointconfig.ServiceTable, authorizationendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(aec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthorizationEndpointConfigClient) Hooks() []Hook {
	return c.hooks.AuthorizationEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *AuthorizationEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.AuthorizationEndpointConfig
}

func (c *AuthorizationEndpointConfigClient) mutate(ctx context.Context, m *AuthorizationEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizationEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizationEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizationEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizationEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizationEndpointConfig mutation op: %q", m.Op())
	}
}

// AuthorizationPayloadClient is a client for the AuthorizationPayload schema.
type AuthorizationPayloadClient struct {
	config
}

// NewAuthorizationPayloadClient returns a client for the AuthorizationPayload from the given config.
func NewAuthorizationPayloadClient(c config) *AuthorizationPayloadClient {
	return &AuthorizationPayloadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizationpayload.Hooks(f(g(h())))`.
func (c *AuthorizationPayloadClient) Use(hooks ...Hook) {
	c.hooks.AuthorizationPayload = append(c.hooks.AuthorizationPayload, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizationpayload.Intercept(f(g(h())))`.
func (c *AuthorizationPayloadClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizationPayload = append(c.inters.AuthorizationPayload, interceptors...)
}

// Create returns a builder for creating a AuthorizationPayload entity.
func (c *AuthorizationPayloadClient) Create() *AuthorizationPayloadCreate {
	mutation := newAuthorizationPayloadMutation(c.config, OpCreate)
	return &AuthorizationPayloadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizationPayload entities.
func (c *AuthorizationPayloadClient) CreateBulk(builders ...*AuthorizationPayloadCreate) *AuthorizationPayloadCreateBulk {
	return &AuthorizationPayloadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthorizationPayloadClient) MapCreateBulk(slice any, setFunc func(*AuthorizationPayloadCreate, int)) *AuthorizationPayloadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthorizationPayloadCreateBulk{err: fmt.Errorf("calling to AuthorizationPayloadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthorizationPayloadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthorizationPayloadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizationPayload.
func (c *AuthorizationPayloadClient) Update() *AuthorizationPayloadUpdate {
	mutation := newAuthorizationPayloadMutation(c.config, OpUpdate)
	return &AuthorizationPayloadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizationPayloadClient) UpdateOne(ap *AuthorizationPayload) *AuthorizationPayloadUpdateOne {
	mutation := newAuthorizationPayloadMutation(c.config, OpUpdateOne, withAuthorizationPayload(ap))
	return &AuthorizationPayloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizationPayloadClient) UpdateOneID(id string) *AuthorizationPayloadUpdateOne {
	mutation := newAuthorizationPayloadMutation(c.config, OpUpdateOne, withAuthorizationPayloadID(id))
	return &AuthorizationPayloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizationPayload.
func (c *AuthorizationPayloadClient) Delete() *AuthorizationPayloadDelete {
	mutation := newAuthorizationPayloadMutation(c.config, OpDelete)
	return &AuthorizationPayloadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizationPayloadClient) DeleteOne(ap *AuthorizationPayload) *AuthorizationPayloadDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizationPayloadClient) DeleteOneID(id string) *AuthorizationPayloadDeleteOne {
	builder := c.Delete().Where(authorizationpayload.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizationPayloadDeleteOne{builder}
}

// Query returns a query builder for AuthorizationPayload.
func (c *AuthorizationPayloadClient) Query() *AuthorizationPayloadQuery {
	return &AuthorizationPayloadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizationPayload},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizationPayload entity by its id.
func (c *AuthorizationPayloadClient) Get(ctx context.Context, id string) (*AuthorizationPayload, error) {
	return c.Query().Where(authorizationpayload.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizationPayloadClient) GetX(ctx context.Context, id string) *AuthorizationPayload {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a AuthorizationPayload.
func (c *AuthorizationPayloadClient) QuerySession(ap *AuthorizationPayload) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authorizationpayload.Table, authorizationpayload.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, authorizationpayload.SessionTable, authorizationpayload.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthorizationPayloadClient) Hooks() []Hook {
	return c.hooks.AuthorizationPayload
}

// Interceptors returns the client interceptors.
func (c *AuthorizationPayloadClient) Interceptors() []Interceptor {
	return c.inters.AuthorizationPayload
}

func (c *AuthorizationPayloadClient) mutate(ctx context.Context, m *AuthorizationPayloadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizationPayloadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizationPayloadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizationPayloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizationPayloadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizationPayload mutation op: %q", m.Op())
	}
}

// CookieStoreClient is a client for the CookieStore schema.
type CookieStoreClient struct {
	config
}

// NewCookieStoreClient returns a client for the CookieStore from the given config.
func NewCookieStoreClient(c config) *CookieStoreClient {
	return &CookieStoreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cookiestore.Hooks(f(g(h())))`.
func (c *CookieStoreClient) Use(hooks ...Hook) {
	c.hooks.CookieStore = append(c.hooks.CookieStore, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cookiestore.Intercept(f(g(h())))`.
func (c *CookieStoreClient) Intercept(interceptors ...Interceptor) {
	c.inters.CookieStore = append(c.inters.CookieStore, interceptors...)
}

// Create returns a builder for creating a CookieStore entity.
func (c *CookieStoreClient) Create() *CookieStoreCreate {
	mutation := newCookieStoreMutation(c.config, OpCreate)
	return &CookieStoreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CookieStore entities.
func (c *CookieStoreClient) CreateBulk(builders ...*CookieStoreCreate) *CookieStoreCreateBulk {
	return &CookieStoreCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CookieStoreClient) MapCreateBulk(slice any, setFunc func(*CookieStoreCreate, int)) *CookieStoreCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CookieStoreCreateBulk{err: fmt.Errorf("calling to CookieStoreClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CookieStoreCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CookieStoreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CookieStore.
func (c *CookieStoreClient) Update() *CookieStoreUpdate {
	mutation := newCookieStoreMutation(c.config, OpUpdate)
	return &CookieStoreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CookieStoreClient) UpdateOne(cs *CookieStore) *CookieStoreUpdateOne {
	mutation := newCookieStoreMutation(c.config, OpUpdateOne, withCookieStore(cs))
	return &CookieStoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CookieStoreClient) UpdateOneID(id string) *CookieStoreUpdateOne {
	mutation := newCookieStoreMutation(c.config, OpUpdateOne, withCookieStoreID(id))
	return &CookieStoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CookieStore.
func (c *CookieStoreClient) Delete() *CookieStoreDelete {
	mutation := newCookieStoreMutation(c.config, OpDelete)
	return &CookieStoreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CookieStoreClient) DeleteOne(cs *CookieStore) *CookieStoreDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CookieStoreClient) DeleteOneID(id string) *CookieStoreDeleteOne {
	builder := c.Delete().Where(cookiestore.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CookieStoreDeleteOne{builder}
}

// Query returns a query builder for CookieStore.
func (c *CookieStoreClient) Query() *CookieStoreQuery {
	return &CookieStoreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCookieStore},
		inters: c.Interceptors(),
	}
}

// Get returns a CookieStore entity by its id.
func (c *CookieStoreClient) Get(ctx context.Context, id string) (*CookieStore, error) {
	return c.Query().Where(cookiestore.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CookieStoreClient) GetX(ctx context.Context, id string) *CookieStore {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CookieStoreClient) Hooks() []Hook {
	return c.hooks.CookieStore
}

// Interceptors returns the client interceptors.
func (c *CookieStoreClient) Interceptors() []Interceptor {
	return c.inters.CookieStore
}

func (c *CookieStoreClient) mutate(ctx context.Context, m *CookieStoreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CookieStoreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CookieStoreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CookieStoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CookieStoreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CookieStore mutation op: %q", m.Op())
	}
}

// CredentialsClient is a client for the Credentials schema.
type CredentialsClient struct {
	config
}

// NewCredentialsClient returns a client for the Credentials from the given config.
func NewCredentialsClient(c config) *CredentialsClient {
	return &CredentialsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `credentials.Hooks(f(g(h())))`.
func (c *CredentialsClient) Use(hooks ...Hook) {
	c.hooks.Credentials = append(c.hooks.Credentials, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `credentials.Intercept(f(g(h())))`.
func (c *CredentialsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Credentials = append(c.inters.Credentials, interceptors...)
}

// Create returns a builder for creating a Credentials entity.
func (c *CredentialsClient) Create() *CredentialsCreate {
	mutation := newCredentialsMutation(c.config, OpCreate)
	return &CredentialsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Credentials entities.
func (c *CredentialsClient) CreateBulk(builders ...*CredentialsCreate) *CredentialsCreateBulk {
	return &CredentialsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CredentialsClient) MapCreateBulk(slice any, setFunc func(*CredentialsCreate, int)) *CredentialsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CredentialsCreateBulk{err: fmt.Errorf("calling to CredentialsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CredentialsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CredentialsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Credentials.
func (c *CredentialsClient) Update() *CredentialsUpdate {
	mutation := newCredentialsMutation(c.config, OpUpdate)
	return &CredentialsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CredentialsClient) UpdateOne(cr *Credentials) *CredentialsUpdateOne {
	mutation := newCredentialsMutation(c.config, OpUpdateOne, withCredentials(cr))
	return &CredentialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CredentialsClient) UpdateOneID(id string) *CredentialsUpdateOne {
	mutation := newCredentialsMutation(c.config, OpUpdateOne, withCredentialsID(id))
	return &CredentialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Credentials.
func (c *CredentialsClient) Delete() *CredentialsDelete {
	mutation := newCredentialsMutation(c.config, OpDelete)
	return &CredentialsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CredentialsClient) DeleteOne(cr *Credentials) *CredentialsDeleteOne {
	return c.DeleteOneID(cr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CredentialsClient) DeleteOneID(id string) *CredentialsDeleteOne {
	builder := c.Delete().Where(credentials.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CredentialsDeleteOne{builder}
}

// Query returns a query builder for Credentials.
func (c *CredentialsClient) Query() *CredentialsQuery {
	return &CredentialsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCredentials},
		inters: c.Interceptors(),
	}
}

// Get returns a Credentials entity by its id.
func (c *CredentialsClient) Get(ctx context.Context, id string) (*Credentials, error) {
	return c.Query().Where(credentials.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CredentialsClient) GetX(ctx context.Context, id string) *Credentials {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a Credentials.
func (c *CredentialsClient) QueryApplication(cr *Credentials) *ApplicationQuery {
	query := (&ApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(credentials.Table, credentials.FieldID, id),
			sqlgraph.To(application.Table, application.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, credentials.ApplicationTable, credentials.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CredentialsClient) Hooks() []Hook {
	return c.hooks.Credentials
}

// Interceptors returns the client interceptors.
func (c *CredentialsClient) Interceptors() []Interceptor {
	return c.inters.Credentials
}

func (c *CredentialsClient) mutate(ctx context.Context, m *CredentialsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CredentialsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CredentialsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CredentialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CredentialsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Credentials mutation op: %q", m.Op())
	}
}

// IntrospectionEndpointConfigClient is a client for the IntrospectionEndpointConfig schema.
type IntrospectionEndpointConfigClient struct {
	config
}

// NewIntrospectionEndpointConfigClient returns a client for the IntrospectionEndpointConfig from the given config.
func NewIntrospectionEndpointConfigClient(c config) *IntrospectionEndpointConfigClient {
	return &IntrospectionEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `introspectionendpointconfig.Hooks(f(g(h())))`.
func (c *IntrospectionEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.IntrospectionEndpointConfig = append(c.hooks.IntrospectionEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `introspectionendpointconfig.Intercept(f(g(h())))`.
func (c *IntrospectionEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.IntrospectionEndpointConfig = append(c.inters.IntrospectionEndpointConfig, interceptors...)
}

// Create returns a builder for creating a IntrospectionEndpointConfig entity.
func (c *IntrospectionEndpointConfigClient) Create() *IntrospectionEndpointConfigCreate {
	mutation := newIntrospectionEndpointConfigMutation(c.config, OpCreate)
	return &IntrospectionEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IntrospectionEndpointConfig entities.
func (c *IntrospectionEndpointConfigClient) CreateBulk(builders ...*IntrospectionEndpointConfigCreate) *IntrospectionEndpointConfigCreateBulk {
	return &IntrospectionEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IntrospectionEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*IntrospectionEndpointConfigCreate, int)) *IntrospectionEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IntrospectionEndpointConfigCreateBulk{err: fmt.Errorf("calling to IntrospectionEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IntrospectionEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IntrospectionEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IntrospectionEndpointConfig.
func (c *IntrospectionEndpointConfigClient) Update() *IntrospectionEndpointConfigUpdate {
	mutation := newIntrospectionEndpointConfigMutation(c.config, OpUpdate)
	return &IntrospectionEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntrospectionEndpointConfigClient) UpdateOne(iec *IntrospectionEndpointConfig) *IntrospectionEndpointConfigUpdateOne {
	mutation := newIntrospectionEndpointConfigMutation(c.config, OpUpdateOne, withIntrospectionEndpointConfig(iec))
	return &IntrospectionEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntrospectionEndpointConfigClient) UpdateOneID(id string) *IntrospectionEndpointConfigUpdateOne {
	mutation := newIntrospectionEndpointConfigMutation(c.config, OpUpdateOne, withIntrospectionEndpointConfigID(id))
	return &IntrospectionEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IntrospectionEndpointConfig.
func (c *IntrospectionEndpointConfigClient) Delete() *IntrospectionEndpointConfigDelete {
	mutation := newIntrospectionEndpointConfigMutation(c.config, OpDelete)
	return &IntrospectionEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntrospectionEndpointConfigClient) DeleteOne(iec *IntrospectionEndpointConfig) *IntrospectionEndpointConfigDeleteOne {
	return c.DeleteOneID(iec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntrospectionEndpointConfigClient) DeleteOneID(id string) *IntrospectionEndpointConfigDeleteOne {
	builder := c.Delete().Where(introspectionendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntrospectionEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for IntrospectionEndpointConfig.
func (c *IntrospectionEndpointConfigClient) Query() *IntrospectionEndpointConfigQuery {
	return &IntrospectionEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntrospectionEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a IntrospectionEndpointConfig entity by its id.
func (c *IntrospectionEndpointConfigClient) Get(ctx context.Context, id string) (*IntrospectionEndpointConfig, error) {
	return c.Query().Where(introspectionendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntrospectionEndpointConfigClient) GetX(ctx context.Context, id string) *IntrospectionEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a IntrospectionEndpointConfig.
func (c *IntrospectionEndpointConfigClient) QueryService(iec *IntrospectionEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(introspectionendpointconfig.Table, introspectionendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, introspectionendpointconfig.ServiceTable, introspectionendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(iec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IntrospectionEndpointConfigClient) Hooks() []Hook {
	return c.hooks.IntrospectionEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *IntrospectionEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.IntrospectionEndpointConfig
}

func (c *IntrospectionEndpointConfigClient) mutate(ctx context.Context, m *IntrospectionEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntrospectionEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntrospectionEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntrospectionEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntrospectionEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IntrospectionEndpointConfig mutation op: %q", m.Op())
	}
}

// JwksEndpointConfigClient is a client for the JwksEndpointConfig schema.
type JwksEndpointConfigClient struct {
	config
}

// NewJwksEndpointConfigClient returns a client for the JwksEndpointConfig from the given config.
func NewJwksEndpointConfigClient(c config) *JwksEndpointConfigClient {
	return &JwksEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `jwksendpointconfig.Hooks(f(g(h())))`.
func (c *JwksEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.JwksEndpointConfig = append(c.hooks.JwksEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `jwksendpointconfig.Intercept(f(g(h())))`.
func (c *JwksEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.JwksEndpointConfig = append(c.inters.JwksEndpointConfig, interceptors...)
}

// Create returns a builder for creating a JwksEndpointConfig entity.
func (c *JwksEndpointConfigClient) Create() *JwksEndpointConfigCreate {
	mutation := newJwksEndpointConfigMutation(c.config, OpCreate)
	return &JwksEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JwksEndpointConfig entities.
func (c *JwksEndpointConfigClient) CreateBulk(builders ...*JwksEndpointConfigCreate) *JwksEndpointConfigCreateBulk {
	return &JwksEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JwksEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*JwksEndpointConfigCreate, int)) *JwksEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JwksEndpointConfigCreateBulk{err: fmt.Errorf("calling to JwksEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JwksEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JwksEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JwksEndpointConfig.
func (c *JwksEndpointConfigClient) Update() *JwksEndpointConfigUpdate {
	mutation := newJwksEndpointConfigMutation(c.config, OpUpdate)
	return &JwksEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JwksEndpointConfigClient) UpdateOne(jec *JwksEndpointConfig) *JwksEndpointConfigUpdateOne {
	mutation := newJwksEndpointConfigMutation(c.config, OpUpdateOne, withJwksEndpointConfig(jec))
	return &JwksEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JwksEndpointConfigClient) UpdateOneID(id string) *JwksEndpointConfigUpdateOne {
	mutation := newJwksEndpointConfigMutation(c.config, OpUpdateOne, withJwksEndpointConfigID(id))
	return &JwksEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JwksEndpointConfig.
func (c *JwksEndpointConfigClient) Delete() *JwksEndpointConfigDelete {
	mutation := newJwksEndpointConfigMutation(c.config, OpDelete)
	return &JwksEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JwksEndpointConfigClient) DeleteOne(jec *JwksEndpointConfig) *JwksEndpointConfigDeleteOne {
	return c.DeleteOneID(jec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JwksEndpointConfigClient) DeleteOneID(id string) *JwksEndpointConfigDeleteOne {
	builder := c.Delete().Where(jwksendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JwksEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for JwksEndpointConfig.
func (c *JwksEndpointConfigClient) Query() *JwksEndpointConfigQuery {
	return &JwksEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJwksEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a JwksEndpointConfig entity by its id.
func (c *JwksEndpointConfigClient) Get(ctx context.Context, id string) (*JwksEndpointConfig, error) {
	return c.Query().Where(jwksendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JwksEndpointConfigClient) GetX(ctx context.Context, id string) *JwksEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a JwksEndpointConfig.
func (c *JwksEndpointConfigClient) QueryService(jec *JwksEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := jec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jwksendpointconfig.Table, jwksendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, jwksendpointconfig.ServiceTable, jwksendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(jec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JwksEndpointConfigClient) Hooks() []Hook {
	return c.hooks.JwksEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *JwksEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.JwksEndpointConfig
}

func (c *JwksEndpointConfigClient) mutate(ctx context.Context, m *JwksEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JwksEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JwksEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JwksEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JwksEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown JwksEndpointConfig mutation op: %q", m.Op())
	}
}

// KeySetClient is a client for the KeySet schema.
type KeySetClient struct {
	config
}

// NewKeySetClient returns a client for the KeySet from the given config.
func NewKeySetClient(c config) *KeySetClient {
	return &KeySetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `keyset.Hooks(f(g(h())))`.
func (c *KeySetClient) Use(hooks ...Hook) {
	c.hooks.KeySet = append(c.hooks.KeySet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `keyset.Intercept(f(g(h())))`.
func (c *KeySetClient) Intercept(interceptors ...Interceptor) {
	c.inters.KeySet = append(c.inters.KeySet, interceptors...)
}

// Create returns a builder for creating a KeySet entity.
func (c *KeySetClient) Create() *KeySetCreate {
	mutation := newKeySetMutation(c.config, OpCreate)
	return &KeySetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of KeySet entities.
func (c *KeySetClient) CreateBulk(builders ...*KeySetCreate) *KeySetCreateBulk {
	return &KeySetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *KeySetClient) MapCreateBulk(slice any, setFunc func(*KeySetCreate, int)) *KeySetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &KeySetCreateBulk{err: fmt.Errorf("calling to KeySetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*KeySetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &KeySetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for KeySet.
func (c *KeySetClient) Update() *KeySetUpdate {
	mutation := newKeySetMutation(c.config, OpUpdate)
	return &KeySetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *KeySetClient) UpdateOne(ks *KeySet) *KeySetUpdateOne {
	mutation := newKeySetMutation(c.config, OpUpdateOne, withKeySet(ks))
	return &KeySetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *KeySetClient) UpdateOneID(id string) *KeySetUpdateOne {
	mutation := newKeySetMutation(c.config, OpUpdateOne, withKeySetID(id))
	return &KeySetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for KeySet.
func (c *KeySetClient) Delete() *KeySetDelete {
	mutation := newKeySetMutation(c.config, OpDelete)
	return &KeySetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *KeySetClient) DeleteOne(ks *KeySet) *KeySetDeleteOne {
	return c.DeleteOneID(ks.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *KeySetClient) DeleteOneID(id string) *KeySetDeleteOne {
	builder := c.Delete().Where(keyset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &KeySetDeleteOne{builder}
}

// Query returns a query builder for KeySet.
func (c *KeySetClient) Query() *KeySetQuery {
	return &KeySetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeKeySet},
		inters: c.Interceptors(),
	}
}

// Get returns a KeySet entity by its id.
func (c *KeySetClient) Get(ctx context.Context, id string) (*KeySet, error) {
	return c.Query().Where(keyset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *KeySetClient) GetX(ctx context.Context, id string) *KeySet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a KeySet.
func (c *KeySetClient) QueryService(ks *KeySet) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ks.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(keyset.Table, keyset.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, keyset.ServiceTable, keyset.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(ks.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySigningKeys queries the signing_keys edge of a KeySet.
func (c *KeySetClient) QuerySigningKeys(ks *KeySet) *SigningKeyQuery {
	query := (&SigningKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ks.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(keyset.Table, keyset.FieldID, id),
			sqlgraph.To(signingkey.Table, signingkey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, keyset.SigningKeysTable, keyset.SigningKeysColumn),
		)
		fromV = sqlgraph.Neighbors(ks.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *KeySetClient) Hooks() []Hook {
	return c.hooks.KeySet
}

// Interceptors returns the client interceptors.
func (c *KeySetClient) Interceptors() []Interceptor {
	return c.inters.KeySet
}

func (c *KeySetClient) mutate(ctx context.Context, m *KeySetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&KeySetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&KeySetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&KeySetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&KeySetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown KeySet mutation op: %q", m.Op())
	}
}

// RefreshTokenClient is a client for the RefreshToken schema.
type RefreshTokenClient struct {
	config
}

// NewRefreshTokenClient returns a client for the RefreshToken from the given config.
func NewRefreshTokenClient(c config) *RefreshTokenClient {
	return &RefreshTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `refreshtoken.Hooks(f(g(h())))`.
func (c *RefreshTokenClient) Use(hooks ...Hook) {
	c.hooks.RefreshToken = append(c.hooks.RefreshToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `refreshtoken.Intercept(f(g(h())))`.
func (c *RefreshTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.RefreshToken = append(c.inters.RefreshToken, interceptors...)
}

// Create returns a builder for creating a RefreshToken entity.
func (c *RefreshTokenClient) Create() *RefreshTokenCreate {
	mutation := newRefreshTokenMutation(c.config, OpCreate)
	return &RefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RefreshToken entities.
func (c *RefreshTokenClient) CreateBulk(builders ...*RefreshTokenCreate) *RefreshTokenCreateBulk {
	return &RefreshTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RefreshTokenClient) MapCreateBulk(slice any, setFunc func(*RefreshTokenCreate, int)) *RefreshTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RefreshTokenCreateBulk{err: fmt.Errorf("calling to RefreshTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RefreshTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RefreshTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RefreshToken.
func (c *RefreshTokenClient) Update() *RefreshTokenUpdate {
	mutation := newRefreshTokenMutation(c.config, OpUpdate)
	return &RefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RefreshTokenClient) UpdateOne(rt *RefreshToken) *RefreshTokenUpdateOne {
	mutation := newRefreshTokenMutation(c.config, OpUpdateOne, withRefreshToken(rt))
	return &RefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RefreshTokenClient) UpdateOneID(id string) *RefreshTokenUpdateOne {
	mutation := newRefreshTokenMutation(c.config, OpUpdateOne, withRefreshTokenID(id))
	return &RefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RefreshToken.
func (c *RefreshTokenClient) Delete() *RefreshTokenDelete {
	mutation := newRefreshTokenMutation(c.config, OpDelete)
	return &RefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RefreshTokenClient) DeleteOne(rt *RefreshToken) *RefreshTokenDeleteOne {
	return c.DeleteOneID(rt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RefreshTokenClient) DeleteOneID(id string) *RefreshTokenDeleteOne {
	builder := c.Delete().Where(refreshtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RefreshTokenDeleteOne{builder}
}

// Query returns a query builder for RefreshToken.
func (c *RefreshTokenClient) Query() *RefreshTokenQuery {
	return &RefreshTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRefreshToken},
		inters: c.Interceptors(),
	}
}

// Get returns a RefreshToken entity by its id.
func (c *RefreshTokenClient) Get(ctx context.Context, id string) (*RefreshToken, error) {
	return c.Query().Where(refreshtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RefreshTokenClient) GetX(ctx context.Context, id string) *RefreshToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RefreshTokenClient) Hooks() []Hook {
	return c.hooks.RefreshToken
}

// Interceptors returns the client interceptors.
func (c *RefreshTokenClient) Interceptors() []Interceptor {
	return c.inters.RefreshToken
}

func (c *RefreshTokenClient) mutate(ctx context.Context, m *RefreshTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RefreshToken mutation op: %q", m.Op())
	}
}

// ServiceClient is a client for the Service schema.
type ServiceClient struct {
	config
}

// NewServiceClient returns a client for the Service from the given config.
func NewServiceClient(c config) *ServiceClient {
	return &ServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `service.Hooks(f(g(h())))`.
func (c *ServiceClient) Use(hooks ...Hook) {
	c.hooks.Service = append(c.hooks.Service, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `service.Intercept(f(g(h())))`.
func (c *ServiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Service = append(c.inters.Service, interceptors...)
}

// Create returns a builder for creating a Service entity.
func (c *ServiceClient) Create() *ServiceCreate {
	mutation := newServiceMutation(c.config, OpCreate)
	return &ServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Service entities.
func (c *ServiceClient) CreateBulk(builders ...*ServiceCreate) *ServiceCreateBulk {
	return &ServiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceClient) MapCreateBulk(slice any, setFunc func(*ServiceCreate, int)) *ServiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceCreateBulk{err: fmt.Errorf("calling to ServiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Service.
func (c *ServiceClient) Update() *ServiceUpdate {
	mutation := newServiceMutation(c.config, OpUpdate)
	return &ServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceClient) UpdateOne(s *Service) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withService(s))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceClient) UpdateOneID(id string) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withServiceID(id))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Service.
func (c *ServiceClient) Delete() *ServiceDelete {
	mutation := newServiceMutation(c.config, OpDelete)
	return &ServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceClient) DeleteOne(s *Service) *ServiceDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceClient) DeleteOneID(id string) *ServiceDeleteOne {
	builder := c.Delete().Where(service.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceDeleteOne{builder}
}

// Query returns a query builder for Service.
func (c *ServiceClient) Query() *ServiceQuery {
	return &ServiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeService},
		inters: c.Interceptors(),
	}
}

// Get returns a Service entity by its id.
func (c *ServiceClient) Get(ctx context.Context, id string) (*Service, error) {
	return c.Query().Where(service.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceClient) GetX(ctx context.Context, id string) *Service {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKeySet queries the key_set edge of a Service.
func (c *ServiceClient) QueryKeySet(s *Service) *KeySetQuery {
	query := (&KeySetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(keyset.Table, keyset.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.KeySetTable, service.KeySetColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceAuthorizationEndpointConfig queries the service_authorization_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceAuthorizationEndpointConfig(s *Service) *AuthorizationEndpointConfigQuery {
	query := (&AuthorizationEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(authorizationendpointconfig.Table, authorizationendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceAuthorizationEndpointConfigTable, service.ServiceAuthorizationEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceIntrospectionEndpointConfig queries the service_introspection_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceIntrospectionEndpointConfig(s *Service) *IntrospectionEndpointConfigQuery {
	query := (&IntrospectionEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(introspectionendpointconfig.Table, introspectionendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceIntrospectionEndpointConfigTable, service.ServiceIntrospectionEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceTokenEndpointConfig queries the service_token_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceTokenEndpointConfig(s *Service) *TokenEndpointConfigQuery {
	query := (&TokenEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(tokenendpointconfig.Table, tokenendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceTokenEndpointConfigTable, service.ServiceTokenEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceUserInfoEndpointConfig queries the service_user_info_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceUserInfoEndpointConfig(s *Service) *UserInfoEndpointConfigQuery {
	query := (&UserInfoEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(userinfoendpointconfig.Table, userinfoendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceUserInfoEndpointConfigTable, service.ServiceUserInfoEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceJwksEndpointConfig queries the service_jwks_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceJwksEndpointConfig(s *Service) *JwksEndpointConfigQuery {
	query := (&JwksEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(jwksendpointconfig.Table, jwksendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceJwksEndpointConfigTable, service.ServiceJwksEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceWellKnownEndpointConfig queries the service_well_known_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceWellKnownEndpointConfig(s *Service) *WellKnownEndpointConfigQuery {
	query := (&WellKnownEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(wellknownendpointconfig.Table, wellknownendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceWellKnownEndpointConfigTable, service.ServiceWellKnownEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApplications queries the applications edge of a Service.
func (c *ServiceClient) QueryApplications(s *Service) *ApplicationQuery {
	query := (&ApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(application.Table, application.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, service.ApplicationsTable, service.ApplicationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceClient) Hooks() []Hook {
	return c.hooks.Service
}

// Interceptors returns the client interceptors.
func (c *ServiceClient) Interceptors() []Interceptor {
	return c.inters.Service
}

func (c *ServiceClient) mutate(ctx context.Context, m *ServiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Service mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id string) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id string) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id string) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id string) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthorizationPayload queries the authorization_payload edge of a Session.
func (c *SessionClient) QueryAuthorizationPayload(s *Session) *AuthorizationPayloadQuery {
	query := (&AuthorizationPayloadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(authorizationpayload.Table, authorizationpayload.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, session.AuthorizationPayloadTable, session.AuthorizationPayloadColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// SigningKeyClient is a client for the SigningKey schema.
type SigningKeyClient struct {
	config
}

// NewSigningKeyClient returns a client for the SigningKey from the given config.
func NewSigningKeyClient(c config) *SigningKeyClient {
	return &SigningKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `signingkey.Hooks(f(g(h())))`.
func (c *SigningKeyClient) Use(hooks ...Hook) {
	c.hooks.SigningKey = append(c.hooks.SigningKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `signingkey.Intercept(f(g(h())))`.
func (c *SigningKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.SigningKey = append(c.inters.SigningKey, interceptors...)
}

// Create returns a builder for creating a SigningKey entity.
func (c *SigningKeyClient) Create() *SigningKeyCreate {
	mutation := newSigningKeyMutation(c.config, OpCreate)
	return &SigningKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SigningKey entities.
func (c *SigningKeyClient) CreateBulk(builders ...*SigningKeyCreate) *SigningKeyCreateBulk {
	return &SigningKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SigningKeyClient) MapCreateBulk(slice any, setFunc func(*SigningKeyCreate, int)) *SigningKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SigningKeyCreateBulk{err: fmt.Errorf("calling to SigningKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SigningKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SigningKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SigningKey.
func (c *SigningKeyClient) Update() *SigningKeyUpdate {
	mutation := newSigningKeyMutation(c.config, OpUpdate)
	return &SigningKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SigningKeyClient) UpdateOne(sk *SigningKey) *SigningKeyUpdateOne {
	mutation := newSigningKeyMutation(c.config, OpUpdateOne, withSigningKey(sk))
	return &SigningKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SigningKeyClient) UpdateOneID(id string) *SigningKeyUpdateOne {
	mutation := newSigningKeyMutation(c.config, OpUpdateOne, withSigningKeyID(id))
	return &SigningKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SigningKey.
func (c *SigningKeyClient) Delete() *SigningKeyDelete {
	mutation := newSigningKeyMutation(c.config, OpDelete)
	return &SigningKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SigningKeyClient) DeleteOne(sk *SigningKey) *SigningKeyDeleteOne {
	return c.DeleteOneID(sk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SigningKeyClient) DeleteOneID(id string) *SigningKeyDeleteOne {
	builder := c.Delete().Where(signingkey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SigningKeyDeleteOne{builder}
}

// Query returns a query builder for SigningKey.
func (c *SigningKeyClient) Query() *SigningKeyQuery {
	return &SigningKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSigningKey},
		inters: c.Interceptors(),
	}
}

// Get returns a SigningKey entity by its id.
func (c *SigningKeyClient) Get(ctx context.Context, id string) (*SigningKey, error) {
	return c.Query().Where(signingkey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SigningKeyClient) GetX(ctx context.Context, id string) *SigningKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKeySet queries the key_set edge of a SigningKey.
func (c *SigningKeyClient) QueryKeySet(sk *SigningKey) *KeySetQuery {
	query := (&KeySetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(signingkey.Table, signingkey.FieldID, id),
			sqlgraph.To(keyset.Table, keyset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, signingkey.KeySetTable, signingkey.KeySetColumn),
		)
		fromV = sqlgraph.Neighbors(sk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SigningKeyClient) Hooks() []Hook {
	return c.hooks.SigningKey
}

// Interceptors returns the client interceptors.
func (c *SigningKeyClient) Interceptors() []Interceptor {
	return c.inters.SigningKey
}

func (c *SigningKeyClient) mutate(ctx context.Context, m *SigningKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SigningKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SigningKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SigningKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SigningKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SigningKey mutation op: %q", m.Op())
	}
}

// StandardClaimsClient is a client for the StandardClaims schema.
type StandardClaimsClient struct {
	config
}

// NewStandardClaimsClient returns a client for the StandardClaims from the given config.
func NewStandardClaimsClient(c config) *StandardClaimsClient {
	return &StandardClaimsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `standardclaims.Hooks(f(g(h())))`.
func (c *StandardClaimsClient) Use(hooks ...Hook) {
	c.hooks.StandardClaims = append(c.hooks.StandardClaims, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `standardclaims.Intercept(f(g(h())))`.
func (c *StandardClaimsClient) Intercept(interceptors ...Interceptor) {
	c.inters.StandardClaims = append(c.inters.StandardClaims, interceptors...)
}

// Create returns a builder for creating a StandardClaims entity.
func (c *StandardClaimsClient) Create() *StandardClaimsCreate {
	mutation := newStandardClaimsMutation(c.config, OpCreate)
	return &StandardClaimsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StandardClaims entities.
func (c *StandardClaimsClient) CreateBulk(builders ...*StandardClaimsCreate) *StandardClaimsCreateBulk {
	return &StandardClaimsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StandardClaimsClient) MapCreateBulk(slice any, setFunc func(*StandardClaimsCreate, int)) *StandardClaimsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StandardClaimsCreateBulk{err: fmt.Errorf("calling to StandardClaimsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StandardClaimsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StandardClaimsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StandardClaims.
func (c *StandardClaimsClient) Update() *StandardClaimsUpdate {
	mutation := newStandardClaimsMutation(c.config, OpUpdate)
	return &StandardClaimsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StandardClaimsClient) UpdateOne(sc *StandardClaims) *StandardClaimsUpdateOne {
	mutation := newStandardClaimsMutation(c.config, OpUpdateOne, withStandardClaims(sc))
	return &StandardClaimsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StandardClaimsClient) UpdateOneID(id int) *StandardClaimsUpdateOne {
	mutation := newStandardClaimsMutation(c.config, OpUpdateOne, withStandardClaimsID(id))
	return &StandardClaimsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StandardClaims.
func (c *StandardClaimsClient) Delete() *StandardClaimsDelete {
	mutation := newStandardClaimsMutation(c.config, OpDelete)
	return &StandardClaimsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StandardClaimsClient) DeleteOne(sc *StandardClaims) *StandardClaimsDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StandardClaimsClient) DeleteOneID(id int) *StandardClaimsDeleteOne {
	builder := c.Delete().Where(standardclaims.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StandardClaimsDeleteOne{builder}
}

// Query returns a query builder for StandardClaims.
func (c *StandardClaimsClient) Query() *StandardClaimsQuery {
	return &StandardClaimsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStandardClaims},
		inters: c.Interceptors(),
	}
}

// Get returns a StandardClaims entity by its id.
func (c *StandardClaimsClient) Get(ctx context.Context, id int) (*StandardClaims, error) {
	return c.Query().Where(standardclaims.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StandardClaimsClient) GetX(ctx context.Context, id int) *StandardClaims {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a StandardClaims.
func (c *StandardClaimsClient) QueryUser(sc *StandardClaims) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standardclaims.Table, standardclaims.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, standardclaims.UserTable, standardclaims.UserColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StandardClaimsClient) Hooks() []Hook {
	return c.hooks.StandardClaims
}

// Interceptors returns the client interceptors.
func (c *StandardClaimsClient) Interceptors() []Interceptor {
	return c.inters.StandardClaims
}

func (c *StandardClaimsClient) mutate(ctx context.Context, m *StandardClaimsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StandardClaimsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StandardClaimsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StandardClaimsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StandardClaimsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StandardClaims mutation op: %q", m.Op())
	}
}

// TokenEndpointConfigClient is a client for the TokenEndpointConfig schema.
type TokenEndpointConfigClient struct {
	config
}

// NewTokenEndpointConfigClient returns a client for the TokenEndpointConfig from the given config.
func NewTokenEndpointConfigClient(c config) *TokenEndpointConfigClient {
	return &TokenEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tokenendpointconfig.Hooks(f(g(h())))`.
func (c *TokenEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.TokenEndpointConfig = append(c.hooks.TokenEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tokenendpointconfig.Intercept(f(g(h())))`.
func (c *TokenEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.TokenEndpointConfig = append(c.inters.TokenEndpointConfig, interceptors...)
}

// Create returns a builder for creating a TokenEndpointConfig entity.
func (c *TokenEndpointConfigClient) Create() *TokenEndpointConfigCreate {
	mutation := newTokenEndpointConfigMutation(c.config, OpCreate)
	return &TokenEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TokenEndpointConfig entities.
func (c *TokenEndpointConfigClient) CreateBulk(builders ...*TokenEndpointConfigCreate) *TokenEndpointConfigCreateBulk {
	return &TokenEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*TokenEndpointConfigCreate, int)) *TokenEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenEndpointConfigCreateBulk{err: fmt.Errorf("calling to TokenEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TokenEndpointConfig.
func (c *TokenEndpointConfigClient) Update() *TokenEndpointConfigUpdate {
	mutation := newTokenEndpointConfigMutation(c.config, OpUpdate)
	return &TokenEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenEndpointConfigClient) UpdateOne(tec *TokenEndpointConfig) *TokenEndpointConfigUpdateOne {
	mutation := newTokenEndpointConfigMutation(c.config, OpUpdateOne, withTokenEndpointConfig(tec))
	return &TokenEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenEndpointConfigClient) UpdateOneID(id string) *TokenEndpointConfigUpdateOne {
	mutation := newTokenEndpointConfigMutation(c.config, OpUpdateOne, withTokenEndpointConfigID(id))
	return &TokenEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TokenEndpointConfig.
func (c *TokenEndpointConfigClient) Delete() *TokenEndpointConfigDelete {
	mutation := newTokenEndpointConfigMutation(c.config, OpDelete)
	return &TokenEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenEndpointConfigClient) DeleteOne(tec *TokenEndpointConfig) *TokenEndpointConfigDeleteOne {
	return c.DeleteOneID(tec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenEndpointConfigClient) DeleteOneID(id string) *TokenEndpointConfigDeleteOne {
	builder := c.Delete().Where(tokenendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for TokenEndpointConfig.
func (c *TokenEndpointConfigClient) Query() *TokenEndpointConfigQuery {
	return &TokenEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTokenEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a TokenEndpointConfig entity by its id.
func (c *TokenEndpointConfigClient) Get(ctx context.Context, id string) (*TokenEndpointConfig, error) {
	return c.Query().Where(tokenendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenEndpointConfigClient) GetX(ctx context.Context, id string) *TokenEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a TokenEndpointConfig.
func (c *TokenEndpointConfigClient) QueryService(tec *TokenEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tokenendpointconfig.Table, tokenendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tokenendpointconfig.ServiceTable, tokenendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(tec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenEndpointConfigClient) Hooks() []Hook {
	return c.hooks.TokenEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *TokenEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.TokenEndpointConfig
}

func (c *TokenEndpointConfigClient) mutate(ctx context.Context, m *TokenEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TokenEndpointConfig mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserPool queries the user_pool edge of a User.
func (c *UserClient) QueryUserPool(u *User) *UserPoolQuery {
	query := (&UserPoolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userpool.Table, userpool.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.UserPoolTable, user.UserPoolColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandardClaims queries the standard_claims edge of a User.
func (c *UserClient) QueryStandardClaims(u *User) *StandardClaimsQuery {
	query := (&StandardClaimsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(standardclaims.Table, standardclaims.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.StandardClaimsTable, user.StandardClaimsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserInfoEndpointConfigClient is a client for the UserInfoEndpointConfig schema.
type UserInfoEndpointConfigClient struct {
	config
}

// NewUserInfoEndpointConfigClient returns a client for the UserInfoEndpointConfig from the given config.
func NewUserInfoEndpointConfigClient(c config) *UserInfoEndpointConfigClient {
	return &UserInfoEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userinfoendpointconfig.Hooks(f(g(h())))`.
func (c *UserInfoEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.UserInfoEndpointConfig = append(c.hooks.UserInfoEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userinfoendpointconfig.Intercept(f(g(h())))`.
func (c *UserInfoEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserInfoEndpointConfig = append(c.inters.UserInfoEndpointConfig, interceptors...)
}

// Create returns a builder for creating a UserInfoEndpointConfig entity.
func (c *UserInfoEndpointConfigClient) Create() *UserInfoEndpointConfigCreate {
	mutation := newUserInfoEndpointConfigMutation(c.config, OpCreate)
	return &UserInfoEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserInfoEndpointConfig entities.
func (c *UserInfoEndpointConfigClient) CreateBulk(builders ...*UserInfoEndpointConfigCreate) *UserInfoEndpointConfigCreateBulk {
	return &UserInfoEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserInfoEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*UserInfoEndpointConfigCreate, int)) *UserInfoEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserInfoEndpointConfigCreateBulk{err: fmt.Errorf("calling to UserInfoEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserInfoEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserInfoEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserInfoEndpointConfig.
func (c *UserInfoEndpointConfigClient) Update() *UserInfoEndpointConfigUpdate {
	mutation := newUserInfoEndpointConfigMutation(c.config, OpUpdate)
	return &UserInfoEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserInfoEndpointConfigClient) UpdateOne(uiec *UserInfoEndpointConfig) *UserInfoEndpointConfigUpdateOne {
	mutation := newUserInfoEndpointConfigMutation(c.config, OpUpdateOne, withUserInfoEndpointConfig(uiec))
	return &UserInfoEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserInfoEndpointConfigClient) UpdateOneID(id string) *UserInfoEndpointConfigUpdateOne {
	mutation := newUserInfoEndpointConfigMutation(c.config, OpUpdateOne, withUserInfoEndpointConfigID(id))
	return &UserInfoEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserInfoEndpointConfig.
func (c *UserInfoEndpointConfigClient) Delete() *UserInfoEndpointConfigDelete {
	mutation := newUserInfoEndpointConfigMutation(c.config, OpDelete)
	return &UserInfoEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserInfoEndpointConfigClient) DeleteOne(uiec *UserInfoEndpointConfig) *UserInfoEndpointConfigDeleteOne {
	return c.DeleteOneID(uiec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserInfoEndpointConfigClient) DeleteOneID(id string) *UserInfoEndpointConfigDeleteOne {
	builder := c.Delete().Where(userinfoendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserInfoEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for UserInfoEndpointConfig.
func (c *UserInfoEndpointConfigClient) Query() *UserInfoEndpointConfigQuery {
	return &UserInfoEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserInfoEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a UserInfoEndpointConfig entity by its id.
func (c *UserInfoEndpointConfigClient) Get(ctx context.Context, id string) (*UserInfoEndpointConfig, error) {
	return c.Query().Where(userinfoendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserInfoEndpointConfigClient) GetX(ctx context.Context, id string) *UserInfoEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a UserInfoEndpointConfig.
func (c *UserInfoEndpointConfigClient) QueryService(uiec *UserInfoEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uiec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userinfoendpointconfig.Table, userinfoendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, userinfoendpointconfig.ServiceTable, userinfoendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(uiec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserInfoEndpointConfigClient) Hooks() []Hook {
	return c.hooks.UserInfoEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *UserInfoEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.UserInfoEndpointConfig
}

func (c *UserInfoEndpointConfigClient) mutate(ctx context.Context, m *UserInfoEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserInfoEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserInfoEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserInfoEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserInfoEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserInfoEndpointConfig mutation op: %q", m.Op())
	}
}

// UserPoolClient is a client for the UserPool schema.
type UserPoolClient struct {
	config
}

// NewUserPoolClient returns a client for the UserPool from the given config.
func NewUserPoolClient(c config) *UserPoolClient {
	return &UserPoolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userpool.Hooks(f(g(h())))`.
func (c *UserPoolClient) Use(hooks ...Hook) {
	c.hooks.UserPool = append(c.hooks.UserPool, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userpool.Intercept(f(g(h())))`.
func (c *UserPoolClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserPool = append(c.inters.UserPool, interceptors...)
}

// Create returns a builder for creating a UserPool entity.
func (c *UserPoolClient) Create() *UserPoolCreate {
	mutation := newUserPoolMutation(c.config, OpCreate)
	return &UserPoolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserPool entities.
func (c *UserPoolClient) CreateBulk(builders ...*UserPoolCreate) *UserPoolCreateBulk {
	return &UserPoolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserPoolClient) MapCreateBulk(slice any, setFunc func(*UserPoolCreate, int)) *UserPoolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserPoolCreateBulk{err: fmt.Errorf("calling to UserPoolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserPoolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserPoolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserPool.
func (c *UserPoolClient) Update() *UserPoolUpdate {
	mutation := newUserPoolMutation(c.config, OpUpdate)
	return &UserPoolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserPoolClient) UpdateOne(up *UserPool) *UserPoolUpdateOne {
	mutation := newUserPoolMutation(c.config, OpUpdateOne, withUserPool(up))
	return &UserPoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserPoolClient) UpdateOneID(id string) *UserPoolUpdateOne {
	mutation := newUserPoolMutation(c.config, OpUpdateOne, withUserPoolID(id))
	return &UserPoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserPool.
func (c *UserPoolClient) Delete() *UserPoolDelete {
	mutation := newUserPoolMutation(c.config, OpDelete)
	return &UserPoolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserPoolClient) DeleteOne(up *UserPool) *UserPoolDeleteOne {
	return c.DeleteOneID(up.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserPoolClient) DeleteOneID(id string) *UserPoolDeleteOne {
	builder := c.Delete().Where(userpool.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserPoolDeleteOne{builder}
}

// Query returns a query builder for UserPool.
func (c *UserPoolClient) Query() *UserPoolQuery {
	return &UserPoolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserPool},
		inters: c.Interceptors(),
	}
}

// Get returns a UserPool entity by its id.
func (c *UserPoolClient) Get(ctx context.Context, id string) (*UserPool, error) {
	return c.Query().Where(userpool.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserPoolClient) GetX(ctx context.Context, id string) *UserPool {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a UserPool.
func (c *UserPoolClient) QueryUsers(up *UserPool) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userpool.Table, userpool.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, userpool.UsersTable, userpool.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserPoolClient) Hooks() []Hook {
	return c.hooks.UserPool
}

// Interceptors returns the client interceptors.
func (c *UserPoolClient) Interceptors() []Interceptor {
	return c.inters.UserPool
}

func (c *UserPoolClient) mutate(ctx context.Context, m *UserPoolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserPoolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserPoolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserPoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserPoolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserPool mutation op: %q", m.Op())
	}
}

// WellKnownEndpointConfigClient is a client for the WellKnownEndpointConfig schema.
type WellKnownEndpointConfigClient struct {
	config
}

// NewWellKnownEndpointConfigClient returns a client for the WellKnownEndpointConfig from the given config.
func NewWellKnownEndpointConfigClient(c config) *WellKnownEndpointConfigClient {
	return &WellKnownEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wellknownendpointconfig.Hooks(f(g(h())))`.
func (c *WellKnownEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.WellKnownEndpointConfig = append(c.hooks.WellKnownEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wellknownendpointconfig.Intercept(f(g(h())))`.
func (c *WellKnownEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.WellKnownEndpointConfig = append(c.inters.WellKnownEndpointConfig, interceptors...)
}

// Create returns a builder for creating a WellKnownEndpointConfig entity.
func (c *WellKnownEndpointConfigClient) Create() *WellKnownEndpointConfigCreate {
	mutation := newWellKnownEndpointConfigMutation(c.config, OpCreate)
	return &WellKnownEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WellKnownEndpointConfig entities.
func (c *WellKnownEndpointConfigClient) CreateBulk(builders ...*WellKnownEndpointConfigCreate) *WellKnownEndpointConfigCreateBulk {
	return &WellKnownEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WellKnownEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*WellKnownEndpointConfigCreate, int)) *WellKnownEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WellKnownEndpointConfigCreateBulk{err: fmt.Errorf("calling to WellKnownEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WellKnownEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WellKnownEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WellKnownEndpointConfig.
func (c *WellKnownEndpointConfigClient) Update() *WellKnownEndpointConfigUpdate {
	mutation := newWellKnownEndpointConfigMutation(c.config, OpUpdate)
	return &WellKnownEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WellKnownEndpointConfigClient) UpdateOne(wkec *WellKnownEndpointConfig) *WellKnownEndpointConfigUpdateOne {
	mutation := newWellKnownEndpointConfigMutation(c.config, OpUpdateOne, withWellKnownEndpointConfig(wkec))
	return &WellKnownEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WellKnownEndpointConfigClient) UpdateOneID(id string) *WellKnownEndpointConfigUpdateOne {
	mutation := newWellKnownEndpointConfigMutation(c.config, OpUpdateOne, withWellKnownEndpointConfigID(id))
	return &WellKnownEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WellKnownEndpointConfig.
func (c *WellKnownEndpointConfigClient) Delete() *WellKnownEndpointConfigDelete {
	mutation := newWellKnownEndpointConfigMutation(c.config, OpDelete)
	return &WellKnownEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WellKnownEndpointConfigClient) DeleteOne(wkec *WellKnownEndpointConfig) *WellKnownEndpointConfigDeleteOne {
	return c.DeleteOneID(wkec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WellKnownEndpointConfigClient) DeleteOneID(id string) *WellKnownEndpointConfigDeleteOne {
	builder := c.Delete().Where(wellknownendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WellKnownEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for WellKnownEndpointConfig.
func (c *WellKnownEndpointConfigClient) Query() *WellKnownEndpointConfigQuery {
	return &WellKnownEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWellKnownEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a WellKnownEndpointConfig entity by its id.
func (c *WellKnownEndpointConfigClient) Get(ctx context.Context, id string) (*WellKnownEndpointConfig, error) {
	return c.Query().Where(wellknownendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WellKnownEndpointConfigClient) GetX(ctx context.Context, id string) *WellKnownEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a WellKnownEndpointConfig.
func (c *WellKnownEndpointConfigClient) QueryService(wkec *WellKnownEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wkec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(wellknownendpointconfig.Table, wellknownendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, wellknownendpointconfig.ServiceTable, wellknownendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(wkec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WellKnownEndpointConfigClient) Hooks() []Hook {
	return c.hooks.WellKnownEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *WellKnownEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.WellKnownEndpointConfig
}

func (c *WellKnownEndpointConfigClient) mutate(ctx context.Context, m *WellKnownEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WellKnownEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WellKnownEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WellKnownEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WellKnownEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WellKnownEndpointConfig mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Application, AuthorizationCode, AuthorizationEndpointConfig,
		AuthorizationPayload, CookieStore, Credentials, IntrospectionEndpointConfig,
		JwksEndpointConfig, KeySet, RefreshToken, Service, Session, SigningKey,
		StandardClaims, TokenEndpointConfig, User, UserInfoEndpointConfig, UserPool,
		WellKnownEndpointConfig []ent.Hook
	}
	inters struct {
		Application, AuthorizationCode, AuthorizationEndpointConfig,
		AuthorizationPayload, CookieStore, Credentials, IntrospectionEndpointConfig,
		JwksEndpointConfig, KeySet, RefreshToken, Service, Session, SigningKey,
		StandardClaims, TokenEndpointConfig, User, UserInfoEndpointConfig, UserPool,
		WellKnownEndpointConfig []ent.Interceptor
	}
)
