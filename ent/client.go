// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"go.authbricks.com/bricks/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"go.authbricks.com/bricks/ent/application"
	"go.authbricks.com/bricks/ent/authorizationcode"
	"go.authbricks.com/bricks/ent/authorizationpayload"
	"go.authbricks.com/bricks/ent/cookiestore"
	"go.authbricks.com/bricks/ent/credentials"
	"go.authbricks.com/bricks/ent/keyset"
	"go.authbricks.com/bricks/ent/refreshtoken"
	"go.authbricks.com/bricks/ent/service"
	"go.authbricks.com/bricks/ent/serviceauthorizationendpointconfig"
	"go.authbricks.com/bricks/ent/serviceintrospectionendpointconfig"
	"go.authbricks.com/bricks/ent/servicejwksendpointconfig"
	"go.authbricks.com/bricks/ent/servicetokenendpointconfig"
	"go.authbricks.com/bricks/ent/serviceuserinfoendpointconfig"
	"go.authbricks.com/bricks/ent/session"
	"go.authbricks.com/bricks/ent/signingkey"
	"go.authbricks.com/bricks/ent/standardclaims"
	"go.authbricks.com/bricks/ent/user"
	"go.authbricks.com/bricks/ent/userpool"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Application is the client for interacting with the Application builders.
	Application *ApplicationClient
	// AuthorizationCode is the client for interacting with the AuthorizationCode builders.
	AuthorizationCode *AuthorizationCodeClient
	// AuthorizationPayload is the client for interacting with the AuthorizationPayload builders.
	AuthorizationPayload *AuthorizationPayloadClient
	// CookieStore is the client for interacting with the CookieStore builders.
	CookieStore *CookieStoreClient
	// Credentials is the client for interacting with the Credentials builders.
	Credentials *CredentialsClient
	// KeySet is the client for interacting with the KeySet builders.
	KeySet *KeySetClient
	// RefreshToken is the client for interacting with the RefreshToken builders.
	RefreshToken *RefreshTokenClient
	// Service is the client for interacting with the Service builders.
	Service *ServiceClient
	// ServiceAuthorizationEndpointConfig is the client for interacting with the ServiceAuthorizationEndpointConfig builders.
	ServiceAuthorizationEndpointConfig *ServiceAuthorizationEndpointConfigClient
	// ServiceIntrospectionEndpointConfig is the client for interacting with the ServiceIntrospectionEndpointConfig builders.
	ServiceIntrospectionEndpointConfig *ServiceIntrospectionEndpointConfigClient
	// ServiceJWKSEndpointConfig is the client for interacting with the ServiceJWKSEndpointConfig builders.
	ServiceJWKSEndpointConfig *ServiceJWKSEndpointConfigClient
	// ServiceTokenEndpointConfig is the client for interacting with the ServiceTokenEndpointConfig builders.
	ServiceTokenEndpointConfig *ServiceTokenEndpointConfigClient
	// ServiceUserInfoEndpointConfig is the client for interacting with the ServiceUserInfoEndpointConfig builders.
	ServiceUserInfoEndpointConfig *ServiceUserInfoEndpointConfigClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// SigningKey is the client for interacting with the SigningKey builders.
	SigningKey *SigningKeyClient
	// StandardClaims is the client for interacting with the StandardClaims builders.
	StandardClaims *StandardClaimsClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserPool is the client for interacting with the UserPool builders.
	UserPool *UserPoolClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Application = NewApplicationClient(c.config)
	c.AuthorizationCode = NewAuthorizationCodeClient(c.config)
	c.AuthorizationPayload = NewAuthorizationPayloadClient(c.config)
	c.CookieStore = NewCookieStoreClient(c.config)
	c.Credentials = NewCredentialsClient(c.config)
	c.KeySet = NewKeySetClient(c.config)
	c.RefreshToken = NewRefreshTokenClient(c.config)
	c.Service = NewServiceClient(c.config)
	c.ServiceAuthorizationEndpointConfig = NewServiceAuthorizationEndpointConfigClient(c.config)
	c.ServiceIntrospectionEndpointConfig = NewServiceIntrospectionEndpointConfigClient(c.config)
	c.ServiceJWKSEndpointConfig = NewServiceJWKSEndpointConfigClient(c.config)
	c.ServiceTokenEndpointConfig = NewServiceTokenEndpointConfigClient(c.config)
	c.ServiceUserInfoEndpointConfig = NewServiceUserInfoEndpointConfigClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.SigningKey = NewSigningKeyClient(c.config)
	c.StandardClaims = NewStandardClaimsClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserPool = NewUserPoolClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                                ctx,
		config:                             cfg,
		Application:                        NewApplicationClient(cfg),
		AuthorizationCode:                  NewAuthorizationCodeClient(cfg),
		AuthorizationPayload:               NewAuthorizationPayloadClient(cfg),
		CookieStore:                        NewCookieStoreClient(cfg),
		Credentials:                        NewCredentialsClient(cfg),
		KeySet:                             NewKeySetClient(cfg),
		RefreshToken:                       NewRefreshTokenClient(cfg),
		Service:                            NewServiceClient(cfg),
		ServiceAuthorizationEndpointConfig: NewServiceAuthorizationEndpointConfigClient(cfg),
		ServiceIntrospectionEndpointConfig: NewServiceIntrospectionEndpointConfigClient(cfg),
		ServiceJWKSEndpointConfig:          NewServiceJWKSEndpointConfigClient(cfg),
		ServiceTokenEndpointConfig:         NewServiceTokenEndpointConfigClient(cfg),
		ServiceUserInfoEndpointConfig:      NewServiceUserInfoEndpointConfigClient(cfg),
		Session:                            NewSessionClient(cfg),
		SigningKey:                         NewSigningKeyClient(cfg),
		StandardClaims:                     NewStandardClaimsClient(cfg),
		User:                               NewUserClient(cfg),
		UserPool:                           NewUserPoolClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                                ctx,
		config:                             cfg,
		Application:                        NewApplicationClient(cfg),
		AuthorizationCode:                  NewAuthorizationCodeClient(cfg),
		AuthorizationPayload:               NewAuthorizationPayloadClient(cfg),
		CookieStore:                        NewCookieStoreClient(cfg),
		Credentials:                        NewCredentialsClient(cfg),
		KeySet:                             NewKeySetClient(cfg),
		RefreshToken:                       NewRefreshTokenClient(cfg),
		Service:                            NewServiceClient(cfg),
		ServiceAuthorizationEndpointConfig: NewServiceAuthorizationEndpointConfigClient(cfg),
		ServiceIntrospectionEndpointConfig: NewServiceIntrospectionEndpointConfigClient(cfg),
		ServiceJWKSEndpointConfig:          NewServiceJWKSEndpointConfigClient(cfg),
		ServiceTokenEndpointConfig:         NewServiceTokenEndpointConfigClient(cfg),
		ServiceUserInfoEndpointConfig:      NewServiceUserInfoEndpointConfigClient(cfg),
		Session:                            NewSessionClient(cfg),
		SigningKey:                         NewSigningKeyClient(cfg),
		StandardClaims:                     NewStandardClaimsClient(cfg),
		User:                               NewUserClient(cfg),
		UserPool:                           NewUserPoolClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Application.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Application, c.AuthorizationCode, c.AuthorizationPayload, c.CookieStore,
		c.Credentials, c.KeySet, c.RefreshToken, c.Service,
		c.ServiceAuthorizationEndpointConfig, c.ServiceIntrospectionEndpointConfig,
		c.ServiceJWKSEndpointConfig, c.ServiceTokenEndpointConfig,
		c.ServiceUserInfoEndpointConfig, c.Session, c.SigningKey, c.StandardClaims,
		c.User, c.UserPool,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Application, c.AuthorizationCode, c.AuthorizationPayload, c.CookieStore,
		c.Credentials, c.KeySet, c.RefreshToken, c.Service,
		c.ServiceAuthorizationEndpointConfig, c.ServiceIntrospectionEndpointConfig,
		c.ServiceJWKSEndpointConfig, c.ServiceTokenEndpointConfig,
		c.ServiceUserInfoEndpointConfig, c.Session, c.SigningKey, c.StandardClaims,
		c.User, c.UserPool,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ApplicationMutation:
		return c.Application.mutate(ctx, m)
	case *AuthorizationCodeMutation:
		return c.AuthorizationCode.mutate(ctx, m)
	case *AuthorizationPayloadMutation:
		return c.AuthorizationPayload.mutate(ctx, m)
	case *CookieStoreMutation:
		return c.CookieStore.mutate(ctx, m)
	case *CredentialsMutation:
		return c.Credentials.mutate(ctx, m)
	case *KeySetMutation:
		return c.KeySet.mutate(ctx, m)
	case *RefreshTokenMutation:
		return c.RefreshToken.mutate(ctx, m)
	case *ServiceMutation:
		return c.Service.mutate(ctx, m)
	case *ServiceAuthorizationEndpointConfigMutation:
		return c.ServiceAuthorizationEndpointConfig.mutate(ctx, m)
	case *ServiceIntrospectionEndpointConfigMutation:
		return c.ServiceIntrospectionEndpointConfig.mutate(ctx, m)
	case *ServiceJWKSEndpointConfigMutation:
		return c.ServiceJWKSEndpointConfig.mutate(ctx, m)
	case *ServiceTokenEndpointConfigMutation:
		return c.ServiceTokenEndpointConfig.mutate(ctx, m)
	case *ServiceUserInfoEndpointConfigMutation:
		return c.ServiceUserInfoEndpointConfig.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *SigningKeyMutation:
		return c.SigningKey.mutate(ctx, m)
	case *StandardClaimsMutation:
		return c.StandardClaims.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserPoolMutation:
		return c.UserPool.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ApplicationClient is a client for the Application schema.
type ApplicationClient struct {
	config
}

// NewApplicationClient returns a client for the Application from the given config.
func NewApplicationClient(c config) *ApplicationClient {
	return &ApplicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `application.Hooks(f(g(h())))`.
func (c *ApplicationClient) Use(hooks ...Hook) {
	c.hooks.Application = append(c.hooks.Application, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `application.Intercept(f(g(h())))`.
func (c *ApplicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Application = append(c.inters.Application, interceptors...)
}

// Create returns a builder for creating a Application entity.
func (c *ApplicationClient) Create() *ApplicationCreate {
	mutation := newApplicationMutation(c.config, OpCreate)
	return &ApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Application entities.
func (c *ApplicationClient) CreateBulk(builders ...*ApplicationCreate) *ApplicationCreateBulk {
	return &ApplicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ApplicationClient) MapCreateBulk(slice any, setFunc func(*ApplicationCreate, int)) *ApplicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ApplicationCreateBulk{err: fmt.Errorf("calling to ApplicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ApplicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ApplicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Application.
func (c *ApplicationClient) Update() *ApplicationUpdate {
	mutation := newApplicationMutation(c.config, OpUpdate)
	return &ApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApplicationClient) UpdateOne(a *Application) *ApplicationUpdateOne {
	mutation := newApplicationMutation(c.config, OpUpdateOne, withApplication(a))
	return &ApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApplicationClient) UpdateOneID(id string) *ApplicationUpdateOne {
	mutation := newApplicationMutation(c.config, OpUpdateOne, withApplicationID(id))
	return &ApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Application.
func (c *ApplicationClient) Delete() *ApplicationDelete {
	mutation := newApplicationMutation(c.config, OpDelete)
	return &ApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApplicationClient) DeleteOne(a *Application) *ApplicationDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApplicationClient) DeleteOneID(id string) *ApplicationDeleteOne {
	builder := c.Delete().Where(application.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApplicationDeleteOne{builder}
}

// Query returns a query builder for Application.
func (c *ApplicationClient) Query() *ApplicationQuery {
	return &ApplicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApplication},
		inters: c.Interceptors(),
	}
}

// Get returns a Application entity by its id.
func (c *ApplicationClient) Get(ctx context.Context, id string) (*Application, error) {
	return c.Query().Where(application.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApplicationClient) GetX(ctx context.Context, id string) *Application {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCredentials queries the credentials edge of a Application.
func (c *ApplicationClient) QueryCredentials(a *Application) *CredentialsQuery {
	query := (&CredentialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(application.Table, application.FieldID, id),
			sqlgraph.To(credentials.Table, credentials.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, application.CredentialsTable, application.CredentialsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryService queries the service edge of a Application.
func (c *ApplicationClient) QueryService(a *Application) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(application.Table, application.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, application.ServiceTable, application.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ApplicationClient) Hooks() []Hook {
	return c.hooks.Application
}

// Interceptors returns the client interceptors.
func (c *ApplicationClient) Interceptors() []Interceptor {
	return c.inters.Application
}

func (c *ApplicationClient) mutate(ctx context.Context, m *ApplicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Application mutation op: %q", m.Op())
	}
}

// AuthorizationCodeClient is a client for the AuthorizationCode schema.
type AuthorizationCodeClient struct {
	config
}

// NewAuthorizationCodeClient returns a client for the AuthorizationCode from the given config.
func NewAuthorizationCodeClient(c config) *AuthorizationCodeClient {
	return &AuthorizationCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizationcode.Hooks(f(g(h())))`.
func (c *AuthorizationCodeClient) Use(hooks ...Hook) {
	c.hooks.AuthorizationCode = append(c.hooks.AuthorizationCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizationcode.Intercept(f(g(h())))`.
func (c *AuthorizationCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizationCode = append(c.inters.AuthorizationCode, interceptors...)
}

// Create returns a builder for creating a AuthorizationCode entity.
func (c *AuthorizationCodeClient) Create() *AuthorizationCodeCreate {
	mutation := newAuthorizationCodeMutation(c.config, OpCreate)
	return &AuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizationCode entities.
func (c *AuthorizationCodeClient) CreateBulk(builders ...*AuthorizationCodeCreate) *AuthorizationCodeCreateBulk {
	return &AuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthorizationCodeClient) MapCreateBulk(slice any, setFunc func(*AuthorizationCodeCreate, int)) *AuthorizationCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthorizationCodeCreateBulk{err: fmt.Errorf("calling to AuthorizationCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthorizationCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Update() *AuthorizationCodeUpdate {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdate)
	return &AuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizationCodeClient) UpdateOne(ac *AuthorizationCode) *AuthorizationCodeUpdateOne {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdateOne, withAuthorizationCode(ac))
	return &AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizationCodeClient) UpdateOneID(id string) *AuthorizationCodeUpdateOne {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdateOne, withAuthorizationCodeID(id))
	return &AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Delete() *AuthorizationCodeDelete {
	mutation := newAuthorizationCodeMutation(c.config, OpDelete)
	return &AuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizationCodeClient) DeleteOne(ac *AuthorizationCode) *AuthorizationCodeDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizationCodeClient) DeleteOneID(id string) *AuthorizationCodeDeleteOne {
	builder := c.Delete().Where(authorizationcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizationCodeDeleteOne{builder}
}

// Query returns a query builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Query() *AuthorizationCodeQuery {
	return &AuthorizationCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizationCode},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizationCode entity by its id.
func (c *AuthorizationCodeClient) Get(ctx context.Context, id string) (*AuthorizationCode, error) {
	return c.Query().Where(authorizationcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizationCodeClient) GetX(ctx context.Context, id string) *AuthorizationCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthorizationCodeClient) Hooks() []Hook {
	return c.hooks.AuthorizationCode
}

// Interceptors returns the client interceptors.
func (c *AuthorizationCodeClient) Interceptors() []Interceptor {
	return c.inters.AuthorizationCode
}

func (c *AuthorizationCodeClient) mutate(ctx context.Context, m *AuthorizationCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizationCode mutation op: %q", m.Op())
	}
}

// AuthorizationPayloadClient is a client for the AuthorizationPayload schema.
type AuthorizationPayloadClient struct {
	config
}

// NewAuthorizationPayloadClient returns a client for the AuthorizationPayload from the given config.
func NewAuthorizationPayloadClient(c config) *AuthorizationPayloadClient {
	return &AuthorizationPayloadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizationpayload.Hooks(f(g(h())))`.
func (c *AuthorizationPayloadClient) Use(hooks ...Hook) {
	c.hooks.AuthorizationPayload = append(c.hooks.AuthorizationPayload, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizationpayload.Intercept(f(g(h())))`.
func (c *AuthorizationPayloadClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizationPayload = append(c.inters.AuthorizationPayload, interceptors...)
}

// Create returns a builder for creating a AuthorizationPayload entity.
func (c *AuthorizationPayloadClient) Create() *AuthorizationPayloadCreate {
	mutation := newAuthorizationPayloadMutation(c.config, OpCreate)
	return &AuthorizationPayloadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizationPayload entities.
func (c *AuthorizationPayloadClient) CreateBulk(builders ...*AuthorizationPayloadCreate) *AuthorizationPayloadCreateBulk {
	return &AuthorizationPayloadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthorizationPayloadClient) MapCreateBulk(slice any, setFunc func(*AuthorizationPayloadCreate, int)) *AuthorizationPayloadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthorizationPayloadCreateBulk{err: fmt.Errorf("calling to AuthorizationPayloadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthorizationPayloadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthorizationPayloadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizationPayload.
func (c *AuthorizationPayloadClient) Update() *AuthorizationPayloadUpdate {
	mutation := newAuthorizationPayloadMutation(c.config, OpUpdate)
	return &AuthorizationPayloadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizationPayloadClient) UpdateOne(ap *AuthorizationPayload) *AuthorizationPayloadUpdateOne {
	mutation := newAuthorizationPayloadMutation(c.config, OpUpdateOne, withAuthorizationPayload(ap))
	return &AuthorizationPayloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizationPayloadClient) UpdateOneID(id string) *AuthorizationPayloadUpdateOne {
	mutation := newAuthorizationPayloadMutation(c.config, OpUpdateOne, withAuthorizationPayloadID(id))
	return &AuthorizationPayloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizationPayload.
func (c *AuthorizationPayloadClient) Delete() *AuthorizationPayloadDelete {
	mutation := newAuthorizationPayloadMutation(c.config, OpDelete)
	return &AuthorizationPayloadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizationPayloadClient) DeleteOne(ap *AuthorizationPayload) *AuthorizationPayloadDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizationPayloadClient) DeleteOneID(id string) *AuthorizationPayloadDeleteOne {
	builder := c.Delete().Where(authorizationpayload.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizationPayloadDeleteOne{builder}
}

// Query returns a query builder for AuthorizationPayload.
func (c *AuthorizationPayloadClient) Query() *AuthorizationPayloadQuery {
	return &AuthorizationPayloadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizationPayload},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizationPayload entity by its id.
func (c *AuthorizationPayloadClient) Get(ctx context.Context, id string) (*AuthorizationPayload, error) {
	return c.Query().Where(authorizationpayload.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizationPayloadClient) GetX(ctx context.Context, id string) *AuthorizationPayload {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a AuthorizationPayload.
func (c *AuthorizationPayloadClient) QuerySession(ap *AuthorizationPayload) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authorizationpayload.Table, authorizationpayload.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, authorizationpayload.SessionTable, authorizationpayload.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthorizationPayloadClient) Hooks() []Hook {
	return c.hooks.AuthorizationPayload
}

// Interceptors returns the client interceptors.
func (c *AuthorizationPayloadClient) Interceptors() []Interceptor {
	return c.inters.AuthorizationPayload
}

func (c *AuthorizationPayloadClient) mutate(ctx context.Context, m *AuthorizationPayloadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizationPayloadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizationPayloadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizationPayloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizationPayloadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizationPayload mutation op: %q", m.Op())
	}
}

// CookieStoreClient is a client for the CookieStore schema.
type CookieStoreClient struct {
	config
}

// NewCookieStoreClient returns a client for the CookieStore from the given config.
func NewCookieStoreClient(c config) *CookieStoreClient {
	return &CookieStoreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cookiestore.Hooks(f(g(h())))`.
func (c *CookieStoreClient) Use(hooks ...Hook) {
	c.hooks.CookieStore = append(c.hooks.CookieStore, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cookiestore.Intercept(f(g(h())))`.
func (c *CookieStoreClient) Intercept(interceptors ...Interceptor) {
	c.inters.CookieStore = append(c.inters.CookieStore, interceptors...)
}

// Create returns a builder for creating a CookieStore entity.
func (c *CookieStoreClient) Create() *CookieStoreCreate {
	mutation := newCookieStoreMutation(c.config, OpCreate)
	return &CookieStoreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CookieStore entities.
func (c *CookieStoreClient) CreateBulk(builders ...*CookieStoreCreate) *CookieStoreCreateBulk {
	return &CookieStoreCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CookieStoreClient) MapCreateBulk(slice any, setFunc func(*CookieStoreCreate, int)) *CookieStoreCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CookieStoreCreateBulk{err: fmt.Errorf("calling to CookieStoreClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CookieStoreCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CookieStoreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CookieStore.
func (c *CookieStoreClient) Update() *CookieStoreUpdate {
	mutation := newCookieStoreMutation(c.config, OpUpdate)
	return &CookieStoreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CookieStoreClient) UpdateOne(cs *CookieStore) *CookieStoreUpdateOne {
	mutation := newCookieStoreMutation(c.config, OpUpdateOne, withCookieStore(cs))
	return &CookieStoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CookieStoreClient) UpdateOneID(id string) *CookieStoreUpdateOne {
	mutation := newCookieStoreMutation(c.config, OpUpdateOne, withCookieStoreID(id))
	return &CookieStoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CookieStore.
func (c *CookieStoreClient) Delete() *CookieStoreDelete {
	mutation := newCookieStoreMutation(c.config, OpDelete)
	return &CookieStoreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CookieStoreClient) DeleteOne(cs *CookieStore) *CookieStoreDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CookieStoreClient) DeleteOneID(id string) *CookieStoreDeleteOne {
	builder := c.Delete().Where(cookiestore.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CookieStoreDeleteOne{builder}
}

// Query returns a query builder for CookieStore.
func (c *CookieStoreClient) Query() *CookieStoreQuery {
	return &CookieStoreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCookieStore},
		inters: c.Interceptors(),
	}
}

// Get returns a CookieStore entity by its id.
func (c *CookieStoreClient) Get(ctx context.Context, id string) (*CookieStore, error) {
	return c.Query().Where(cookiestore.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CookieStoreClient) GetX(ctx context.Context, id string) *CookieStore {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CookieStoreClient) Hooks() []Hook {
	return c.hooks.CookieStore
}

// Interceptors returns the client interceptors.
func (c *CookieStoreClient) Interceptors() []Interceptor {
	return c.inters.CookieStore
}

func (c *CookieStoreClient) mutate(ctx context.Context, m *CookieStoreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CookieStoreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CookieStoreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CookieStoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CookieStoreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CookieStore mutation op: %q", m.Op())
	}
}

// CredentialsClient is a client for the Credentials schema.
type CredentialsClient struct {
	config
}

// NewCredentialsClient returns a client for the Credentials from the given config.
func NewCredentialsClient(c config) *CredentialsClient {
	return &CredentialsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `credentials.Hooks(f(g(h())))`.
func (c *CredentialsClient) Use(hooks ...Hook) {
	c.hooks.Credentials = append(c.hooks.Credentials, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `credentials.Intercept(f(g(h())))`.
func (c *CredentialsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Credentials = append(c.inters.Credentials, interceptors...)
}

// Create returns a builder for creating a Credentials entity.
func (c *CredentialsClient) Create() *CredentialsCreate {
	mutation := newCredentialsMutation(c.config, OpCreate)
	return &CredentialsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Credentials entities.
func (c *CredentialsClient) CreateBulk(builders ...*CredentialsCreate) *CredentialsCreateBulk {
	return &CredentialsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CredentialsClient) MapCreateBulk(slice any, setFunc func(*CredentialsCreate, int)) *CredentialsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CredentialsCreateBulk{err: fmt.Errorf("calling to CredentialsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CredentialsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CredentialsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Credentials.
func (c *CredentialsClient) Update() *CredentialsUpdate {
	mutation := newCredentialsMutation(c.config, OpUpdate)
	return &CredentialsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CredentialsClient) UpdateOne(cr *Credentials) *CredentialsUpdateOne {
	mutation := newCredentialsMutation(c.config, OpUpdateOne, withCredentials(cr))
	return &CredentialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CredentialsClient) UpdateOneID(id string) *CredentialsUpdateOne {
	mutation := newCredentialsMutation(c.config, OpUpdateOne, withCredentialsID(id))
	return &CredentialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Credentials.
func (c *CredentialsClient) Delete() *CredentialsDelete {
	mutation := newCredentialsMutation(c.config, OpDelete)
	return &CredentialsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CredentialsClient) DeleteOne(cr *Credentials) *CredentialsDeleteOne {
	return c.DeleteOneID(cr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CredentialsClient) DeleteOneID(id string) *CredentialsDeleteOne {
	builder := c.Delete().Where(credentials.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CredentialsDeleteOne{builder}
}

// Query returns a query builder for Credentials.
func (c *CredentialsClient) Query() *CredentialsQuery {
	return &CredentialsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCredentials},
		inters: c.Interceptors(),
	}
}

// Get returns a Credentials entity by its id.
func (c *CredentialsClient) Get(ctx context.Context, id string) (*Credentials, error) {
	return c.Query().Where(credentials.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CredentialsClient) GetX(ctx context.Context, id string) *Credentials {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a Credentials.
func (c *CredentialsClient) QueryApplication(cr *Credentials) *ApplicationQuery {
	query := (&ApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(credentials.Table, credentials.FieldID, id),
			sqlgraph.To(application.Table, application.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, credentials.ApplicationTable, credentials.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CredentialsClient) Hooks() []Hook {
	return c.hooks.Credentials
}

// Interceptors returns the client interceptors.
func (c *CredentialsClient) Interceptors() []Interceptor {
	return c.inters.Credentials
}

func (c *CredentialsClient) mutate(ctx context.Context, m *CredentialsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CredentialsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CredentialsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CredentialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CredentialsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Credentials mutation op: %q", m.Op())
	}
}

// KeySetClient is a client for the KeySet schema.
type KeySetClient struct {
	config
}

// NewKeySetClient returns a client for the KeySet from the given config.
func NewKeySetClient(c config) *KeySetClient {
	return &KeySetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `keyset.Hooks(f(g(h())))`.
func (c *KeySetClient) Use(hooks ...Hook) {
	c.hooks.KeySet = append(c.hooks.KeySet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `keyset.Intercept(f(g(h())))`.
func (c *KeySetClient) Intercept(interceptors ...Interceptor) {
	c.inters.KeySet = append(c.inters.KeySet, interceptors...)
}

// Create returns a builder for creating a KeySet entity.
func (c *KeySetClient) Create() *KeySetCreate {
	mutation := newKeySetMutation(c.config, OpCreate)
	return &KeySetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of KeySet entities.
func (c *KeySetClient) CreateBulk(builders ...*KeySetCreate) *KeySetCreateBulk {
	return &KeySetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *KeySetClient) MapCreateBulk(slice any, setFunc func(*KeySetCreate, int)) *KeySetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &KeySetCreateBulk{err: fmt.Errorf("calling to KeySetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*KeySetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &KeySetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for KeySet.
func (c *KeySetClient) Update() *KeySetUpdate {
	mutation := newKeySetMutation(c.config, OpUpdate)
	return &KeySetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *KeySetClient) UpdateOne(ks *KeySet) *KeySetUpdateOne {
	mutation := newKeySetMutation(c.config, OpUpdateOne, withKeySet(ks))
	return &KeySetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *KeySetClient) UpdateOneID(id string) *KeySetUpdateOne {
	mutation := newKeySetMutation(c.config, OpUpdateOne, withKeySetID(id))
	return &KeySetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for KeySet.
func (c *KeySetClient) Delete() *KeySetDelete {
	mutation := newKeySetMutation(c.config, OpDelete)
	return &KeySetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *KeySetClient) DeleteOne(ks *KeySet) *KeySetDeleteOne {
	return c.DeleteOneID(ks.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *KeySetClient) DeleteOneID(id string) *KeySetDeleteOne {
	builder := c.Delete().Where(keyset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &KeySetDeleteOne{builder}
}

// Query returns a query builder for KeySet.
func (c *KeySetClient) Query() *KeySetQuery {
	return &KeySetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeKeySet},
		inters: c.Interceptors(),
	}
}

// Get returns a KeySet entity by its id.
func (c *KeySetClient) Get(ctx context.Context, id string) (*KeySet, error) {
	return c.Query().Where(keyset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *KeySetClient) GetX(ctx context.Context, id string) *KeySet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a KeySet.
func (c *KeySetClient) QueryService(ks *KeySet) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ks.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(keyset.Table, keyset.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, keyset.ServiceTable, keyset.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(ks.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySigningKeys queries the signing_keys edge of a KeySet.
func (c *KeySetClient) QuerySigningKeys(ks *KeySet) *SigningKeyQuery {
	query := (&SigningKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ks.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(keyset.Table, keyset.FieldID, id),
			sqlgraph.To(signingkey.Table, signingkey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, keyset.SigningKeysTable, keyset.SigningKeysColumn),
		)
		fromV = sqlgraph.Neighbors(ks.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *KeySetClient) Hooks() []Hook {
	return c.hooks.KeySet
}

// Interceptors returns the client interceptors.
func (c *KeySetClient) Interceptors() []Interceptor {
	return c.inters.KeySet
}

func (c *KeySetClient) mutate(ctx context.Context, m *KeySetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&KeySetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&KeySetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&KeySetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&KeySetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown KeySet mutation op: %q", m.Op())
	}
}

// RefreshTokenClient is a client for the RefreshToken schema.
type RefreshTokenClient struct {
	config
}

// NewRefreshTokenClient returns a client for the RefreshToken from the given config.
func NewRefreshTokenClient(c config) *RefreshTokenClient {
	return &RefreshTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `refreshtoken.Hooks(f(g(h())))`.
func (c *RefreshTokenClient) Use(hooks ...Hook) {
	c.hooks.RefreshToken = append(c.hooks.RefreshToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `refreshtoken.Intercept(f(g(h())))`.
func (c *RefreshTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.RefreshToken = append(c.inters.RefreshToken, interceptors...)
}

// Create returns a builder for creating a RefreshToken entity.
func (c *RefreshTokenClient) Create() *RefreshTokenCreate {
	mutation := newRefreshTokenMutation(c.config, OpCreate)
	return &RefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RefreshToken entities.
func (c *RefreshTokenClient) CreateBulk(builders ...*RefreshTokenCreate) *RefreshTokenCreateBulk {
	return &RefreshTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RefreshTokenClient) MapCreateBulk(slice any, setFunc func(*RefreshTokenCreate, int)) *RefreshTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RefreshTokenCreateBulk{err: fmt.Errorf("calling to RefreshTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RefreshTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RefreshTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RefreshToken.
func (c *RefreshTokenClient) Update() *RefreshTokenUpdate {
	mutation := newRefreshTokenMutation(c.config, OpUpdate)
	return &RefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RefreshTokenClient) UpdateOne(rt *RefreshToken) *RefreshTokenUpdateOne {
	mutation := newRefreshTokenMutation(c.config, OpUpdateOne, withRefreshToken(rt))
	return &RefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RefreshTokenClient) UpdateOneID(id string) *RefreshTokenUpdateOne {
	mutation := newRefreshTokenMutation(c.config, OpUpdateOne, withRefreshTokenID(id))
	return &RefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RefreshToken.
func (c *RefreshTokenClient) Delete() *RefreshTokenDelete {
	mutation := newRefreshTokenMutation(c.config, OpDelete)
	return &RefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RefreshTokenClient) DeleteOne(rt *RefreshToken) *RefreshTokenDeleteOne {
	return c.DeleteOneID(rt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RefreshTokenClient) DeleteOneID(id string) *RefreshTokenDeleteOne {
	builder := c.Delete().Where(refreshtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RefreshTokenDeleteOne{builder}
}

// Query returns a query builder for RefreshToken.
func (c *RefreshTokenClient) Query() *RefreshTokenQuery {
	return &RefreshTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRefreshToken},
		inters: c.Interceptors(),
	}
}

// Get returns a RefreshToken entity by its id.
func (c *RefreshTokenClient) Get(ctx context.Context, id string) (*RefreshToken, error) {
	return c.Query().Where(refreshtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RefreshTokenClient) GetX(ctx context.Context, id string) *RefreshToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RefreshTokenClient) Hooks() []Hook {
	return c.hooks.RefreshToken
}

// Interceptors returns the client interceptors.
func (c *RefreshTokenClient) Interceptors() []Interceptor {
	return c.inters.RefreshToken
}

func (c *RefreshTokenClient) mutate(ctx context.Context, m *RefreshTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RefreshToken mutation op: %q", m.Op())
	}
}

// ServiceClient is a client for the Service schema.
type ServiceClient struct {
	config
}

// NewServiceClient returns a client for the Service from the given config.
func NewServiceClient(c config) *ServiceClient {
	return &ServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `service.Hooks(f(g(h())))`.
func (c *ServiceClient) Use(hooks ...Hook) {
	c.hooks.Service = append(c.hooks.Service, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `service.Intercept(f(g(h())))`.
func (c *ServiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Service = append(c.inters.Service, interceptors...)
}

// Create returns a builder for creating a Service entity.
func (c *ServiceClient) Create() *ServiceCreate {
	mutation := newServiceMutation(c.config, OpCreate)
	return &ServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Service entities.
func (c *ServiceClient) CreateBulk(builders ...*ServiceCreate) *ServiceCreateBulk {
	return &ServiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceClient) MapCreateBulk(slice any, setFunc func(*ServiceCreate, int)) *ServiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceCreateBulk{err: fmt.Errorf("calling to ServiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Service.
func (c *ServiceClient) Update() *ServiceUpdate {
	mutation := newServiceMutation(c.config, OpUpdate)
	return &ServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceClient) UpdateOne(s *Service) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withService(s))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceClient) UpdateOneID(id string) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withServiceID(id))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Service.
func (c *ServiceClient) Delete() *ServiceDelete {
	mutation := newServiceMutation(c.config, OpDelete)
	return &ServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceClient) DeleteOne(s *Service) *ServiceDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceClient) DeleteOneID(id string) *ServiceDeleteOne {
	builder := c.Delete().Where(service.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceDeleteOne{builder}
}

// Query returns a query builder for Service.
func (c *ServiceClient) Query() *ServiceQuery {
	return &ServiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeService},
		inters: c.Interceptors(),
	}
}

// Get returns a Service entity by its id.
func (c *ServiceClient) Get(ctx context.Context, id string) (*Service, error) {
	return c.Query().Where(service.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceClient) GetX(ctx context.Context, id string) *Service {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKeySet queries the key_set edge of a Service.
func (c *ServiceClient) QueryKeySet(s *Service) *KeySetQuery {
	query := (&KeySetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(keyset.Table, keyset.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.KeySetTable, service.KeySetColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceAuthorizationEndpointConfig queries the service_authorization_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceAuthorizationEndpointConfig(s *Service) *ServiceAuthorizationEndpointConfigQuery {
	query := (&ServiceAuthorizationEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(serviceauthorizationendpointconfig.Table, serviceauthorizationendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceAuthorizationEndpointConfigTable, service.ServiceAuthorizationEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceIntrospectionEndpointConfig queries the service_introspection_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceIntrospectionEndpointConfig(s *Service) *ServiceIntrospectionEndpointConfigQuery {
	query := (&ServiceIntrospectionEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(serviceintrospectionendpointconfig.Table, serviceintrospectionendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceIntrospectionEndpointConfigTable, service.ServiceIntrospectionEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceTokenEndpointConfig queries the service_token_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceTokenEndpointConfig(s *Service) *ServiceTokenEndpointConfigQuery {
	query := (&ServiceTokenEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(servicetokenendpointconfig.Table, servicetokenendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceTokenEndpointConfigTable, service.ServiceTokenEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceUserInfoEndpointConfig queries the service_user_info_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceUserInfoEndpointConfig(s *Service) *ServiceUserInfoEndpointConfigQuery {
	query := (&ServiceUserInfoEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(serviceuserinfoendpointconfig.Table, serviceuserinfoendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceUserInfoEndpointConfigTable, service.ServiceUserInfoEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceJwksEndpointConfig queries the service_jwks_endpoint_config edge of a Service.
func (c *ServiceClient) QueryServiceJwksEndpointConfig(s *Service) *ServiceJWKSEndpointConfigQuery {
	query := (&ServiceJWKSEndpointConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(servicejwksendpointconfig.Table, servicejwksendpointconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, service.ServiceJwksEndpointConfigTable, service.ServiceJwksEndpointConfigColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApplications queries the applications edge of a Service.
func (c *ServiceClient) QueryApplications(s *Service) *ApplicationQuery {
	query := (&ApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(application.Table, application.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, service.ApplicationsTable, service.ApplicationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceClient) Hooks() []Hook {
	return c.hooks.Service
}

// Interceptors returns the client interceptors.
func (c *ServiceClient) Interceptors() []Interceptor {
	return c.inters.Service
}

func (c *ServiceClient) mutate(ctx context.Context, m *ServiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Service mutation op: %q", m.Op())
	}
}

// ServiceAuthorizationEndpointConfigClient is a client for the ServiceAuthorizationEndpointConfig schema.
type ServiceAuthorizationEndpointConfigClient struct {
	config
}

// NewServiceAuthorizationEndpointConfigClient returns a client for the ServiceAuthorizationEndpointConfig from the given config.
func NewServiceAuthorizationEndpointConfigClient(c config) *ServiceAuthorizationEndpointConfigClient {
	return &ServiceAuthorizationEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `serviceauthorizationendpointconfig.Hooks(f(g(h())))`.
func (c *ServiceAuthorizationEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.ServiceAuthorizationEndpointConfig = append(c.hooks.ServiceAuthorizationEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `serviceauthorizationendpointconfig.Intercept(f(g(h())))`.
func (c *ServiceAuthorizationEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceAuthorizationEndpointConfig = append(c.inters.ServiceAuthorizationEndpointConfig, interceptors...)
}

// Create returns a builder for creating a ServiceAuthorizationEndpointConfig entity.
func (c *ServiceAuthorizationEndpointConfigClient) Create() *ServiceAuthorizationEndpointConfigCreate {
	mutation := newServiceAuthorizationEndpointConfigMutation(c.config, OpCreate)
	return &ServiceAuthorizationEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceAuthorizationEndpointConfig entities.
func (c *ServiceAuthorizationEndpointConfigClient) CreateBulk(builders ...*ServiceAuthorizationEndpointConfigCreate) *ServiceAuthorizationEndpointConfigCreateBulk {
	return &ServiceAuthorizationEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceAuthorizationEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*ServiceAuthorizationEndpointConfigCreate, int)) *ServiceAuthorizationEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceAuthorizationEndpointConfigCreateBulk{err: fmt.Errorf("calling to ServiceAuthorizationEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceAuthorizationEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceAuthorizationEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceAuthorizationEndpointConfig.
func (c *ServiceAuthorizationEndpointConfigClient) Update() *ServiceAuthorizationEndpointConfigUpdate {
	mutation := newServiceAuthorizationEndpointConfigMutation(c.config, OpUpdate)
	return &ServiceAuthorizationEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceAuthorizationEndpointConfigClient) UpdateOne(saec *ServiceAuthorizationEndpointConfig) *ServiceAuthorizationEndpointConfigUpdateOne {
	mutation := newServiceAuthorizationEndpointConfigMutation(c.config, OpUpdateOne, withServiceAuthorizationEndpointConfig(saec))
	return &ServiceAuthorizationEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceAuthorizationEndpointConfigClient) UpdateOneID(id string) *ServiceAuthorizationEndpointConfigUpdateOne {
	mutation := newServiceAuthorizationEndpointConfigMutation(c.config, OpUpdateOne, withServiceAuthorizationEndpointConfigID(id))
	return &ServiceAuthorizationEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceAuthorizationEndpointConfig.
func (c *ServiceAuthorizationEndpointConfigClient) Delete() *ServiceAuthorizationEndpointConfigDelete {
	mutation := newServiceAuthorizationEndpointConfigMutation(c.config, OpDelete)
	return &ServiceAuthorizationEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceAuthorizationEndpointConfigClient) DeleteOne(saec *ServiceAuthorizationEndpointConfig) *ServiceAuthorizationEndpointConfigDeleteOne {
	return c.DeleteOneID(saec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceAuthorizationEndpointConfigClient) DeleteOneID(id string) *ServiceAuthorizationEndpointConfigDeleteOne {
	builder := c.Delete().Where(serviceauthorizationendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceAuthorizationEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for ServiceAuthorizationEndpointConfig.
func (c *ServiceAuthorizationEndpointConfigClient) Query() *ServiceAuthorizationEndpointConfigQuery {
	return &ServiceAuthorizationEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceAuthorizationEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceAuthorizationEndpointConfig entity by its id.
func (c *ServiceAuthorizationEndpointConfigClient) Get(ctx context.Context, id string) (*ServiceAuthorizationEndpointConfig, error) {
	return c.Query().Where(serviceauthorizationendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceAuthorizationEndpointConfigClient) GetX(ctx context.Context, id string) *ServiceAuthorizationEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a ServiceAuthorizationEndpointConfig.
func (c *ServiceAuthorizationEndpointConfigClient) QueryService(saec *ServiceAuthorizationEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := saec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceauthorizationendpointconfig.Table, serviceauthorizationendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, serviceauthorizationendpointconfig.ServiceTable, serviceauthorizationendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(saec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceAuthorizationEndpointConfigClient) Hooks() []Hook {
	return c.hooks.ServiceAuthorizationEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *ServiceAuthorizationEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.ServiceAuthorizationEndpointConfig
}

func (c *ServiceAuthorizationEndpointConfigClient) mutate(ctx context.Context, m *ServiceAuthorizationEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceAuthorizationEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceAuthorizationEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceAuthorizationEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceAuthorizationEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceAuthorizationEndpointConfig mutation op: %q", m.Op())
	}
}

// ServiceIntrospectionEndpointConfigClient is a client for the ServiceIntrospectionEndpointConfig schema.
type ServiceIntrospectionEndpointConfigClient struct {
	config
}

// NewServiceIntrospectionEndpointConfigClient returns a client for the ServiceIntrospectionEndpointConfig from the given config.
func NewServiceIntrospectionEndpointConfigClient(c config) *ServiceIntrospectionEndpointConfigClient {
	return &ServiceIntrospectionEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `serviceintrospectionendpointconfig.Hooks(f(g(h())))`.
func (c *ServiceIntrospectionEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.ServiceIntrospectionEndpointConfig = append(c.hooks.ServiceIntrospectionEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `serviceintrospectionendpointconfig.Intercept(f(g(h())))`.
func (c *ServiceIntrospectionEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceIntrospectionEndpointConfig = append(c.inters.ServiceIntrospectionEndpointConfig, interceptors...)
}

// Create returns a builder for creating a ServiceIntrospectionEndpointConfig entity.
func (c *ServiceIntrospectionEndpointConfigClient) Create() *ServiceIntrospectionEndpointConfigCreate {
	mutation := newServiceIntrospectionEndpointConfigMutation(c.config, OpCreate)
	return &ServiceIntrospectionEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceIntrospectionEndpointConfig entities.
func (c *ServiceIntrospectionEndpointConfigClient) CreateBulk(builders ...*ServiceIntrospectionEndpointConfigCreate) *ServiceIntrospectionEndpointConfigCreateBulk {
	return &ServiceIntrospectionEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceIntrospectionEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*ServiceIntrospectionEndpointConfigCreate, int)) *ServiceIntrospectionEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceIntrospectionEndpointConfigCreateBulk{err: fmt.Errorf("calling to ServiceIntrospectionEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceIntrospectionEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceIntrospectionEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceIntrospectionEndpointConfig.
func (c *ServiceIntrospectionEndpointConfigClient) Update() *ServiceIntrospectionEndpointConfigUpdate {
	mutation := newServiceIntrospectionEndpointConfigMutation(c.config, OpUpdate)
	return &ServiceIntrospectionEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceIntrospectionEndpointConfigClient) UpdateOne(siec *ServiceIntrospectionEndpointConfig) *ServiceIntrospectionEndpointConfigUpdateOne {
	mutation := newServiceIntrospectionEndpointConfigMutation(c.config, OpUpdateOne, withServiceIntrospectionEndpointConfig(siec))
	return &ServiceIntrospectionEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceIntrospectionEndpointConfigClient) UpdateOneID(id string) *ServiceIntrospectionEndpointConfigUpdateOne {
	mutation := newServiceIntrospectionEndpointConfigMutation(c.config, OpUpdateOne, withServiceIntrospectionEndpointConfigID(id))
	return &ServiceIntrospectionEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceIntrospectionEndpointConfig.
func (c *ServiceIntrospectionEndpointConfigClient) Delete() *ServiceIntrospectionEndpointConfigDelete {
	mutation := newServiceIntrospectionEndpointConfigMutation(c.config, OpDelete)
	return &ServiceIntrospectionEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceIntrospectionEndpointConfigClient) DeleteOne(siec *ServiceIntrospectionEndpointConfig) *ServiceIntrospectionEndpointConfigDeleteOne {
	return c.DeleteOneID(siec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceIntrospectionEndpointConfigClient) DeleteOneID(id string) *ServiceIntrospectionEndpointConfigDeleteOne {
	builder := c.Delete().Where(serviceintrospectionendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceIntrospectionEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for ServiceIntrospectionEndpointConfig.
func (c *ServiceIntrospectionEndpointConfigClient) Query() *ServiceIntrospectionEndpointConfigQuery {
	return &ServiceIntrospectionEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceIntrospectionEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceIntrospectionEndpointConfig entity by its id.
func (c *ServiceIntrospectionEndpointConfigClient) Get(ctx context.Context, id string) (*ServiceIntrospectionEndpointConfig, error) {
	return c.Query().Where(serviceintrospectionendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceIntrospectionEndpointConfigClient) GetX(ctx context.Context, id string) *ServiceIntrospectionEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a ServiceIntrospectionEndpointConfig.
func (c *ServiceIntrospectionEndpointConfigClient) QueryService(siec *ServiceIntrospectionEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := siec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceintrospectionendpointconfig.Table, serviceintrospectionendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, serviceintrospectionendpointconfig.ServiceTable, serviceintrospectionendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(siec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceIntrospectionEndpointConfigClient) Hooks() []Hook {
	return c.hooks.ServiceIntrospectionEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *ServiceIntrospectionEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.ServiceIntrospectionEndpointConfig
}

func (c *ServiceIntrospectionEndpointConfigClient) mutate(ctx context.Context, m *ServiceIntrospectionEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceIntrospectionEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceIntrospectionEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceIntrospectionEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceIntrospectionEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceIntrospectionEndpointConfig mutation op: %q", m.Op())
	}
}

// ServiceJWKSEndpointConfigClient is a client for the ServiceJWKSEndpointConfig schema.
type ServiceJWKSEndpointConfigClient struct {
	config
}

// NewServiceJWKSEndpointConfigClient returns a client for the ServiceJWKSEndpointConfig from the given config.
func NewServiceJWKSEndpointConfigClient(c config) *ServiceJWKSEndpointConfigClient {
	return &ServiceJWKSEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servicejwksendpointconfig.Hooks(f(g(h())))`.
func (c *ServiceJWKSEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.ServiceJWKSEndpointConfig = append(c.hooks.ServiceJWKSEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `servicejwksendpointconfig.Intercept(f(g(h())))`.
func (c *ServiceJWKSEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceJWKSEndpointConfig = append(c.inters.ServiceJWKSEndpointConfig, interceptors...)
}

// Create returns a builder for creating a ServiceJWKSEndpointConfig entity.
func (c *ServiceJWKSEndpointConfigClient) Create() *ServiceJWKSEndpointConfigCreate {
	mutation := newServiceJWKSEndpointConfigMutation(c.config, OpCreate)
	return &ServiceJWKSEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceJWKSEndpointConfig entities.
func (c *ServiceJWKSEndpointConfigClient) CreateBulk(builders ...*ServiceJWKSEndpointConfigCreate) *ServiceJWKSEndpointConfigCreateBulk {
	return &ServiceJWKSEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceJWKSEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*ServiceJWKSEndpointConfigCreate, int)) *ServiceJWKSEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceJWKSEndpointConfigCreateBulk{err: fmt.Errorf("calling to ServiceJWKSEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceJWKSEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceJWKSEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceJWKSEndpointConfig.
func (c *ServiceJWKSEndpointConfigClient) Update() *ServiceJWKSEndpointConfigUpdate {
	mutation := newServiceJWKSEndpointConfigMutation(c.config, OpUpdate)
	return &ServiceJWKSEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceJWKSEndpointConfigClient) UpdateOne(sjec *ServiceJWKSEndpointConfig) *ServiceJWKSEndpointConfigUpdateOne {
	mutation := newServiceJWKSEndpointConfigMutation(c.config, OpUpdateOne, withServiceJWKSEndpointConfig(sjec))
	return &ServiceJWKSEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceJWKSEndpointConfigClient) UpdateOneID(id string) *ServiceJWKSEndpointConfigUpdateOne {
	mutation := newServiceJWKSEndpointConfigMutation(c.config, OpUpdateOne, withServiceJWKSEndpointConfigID(id))
	return &ServiceJWKSEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceJWKSEndpointConfig.
func (c *ServiceJWKSEndpointConfigClient) Delete() *ServiceJWKSEndpointConfigDelete {
	mutation := newServiceJWKSEndpointConfigMutation(c.config, OpDelete)
	return &ServiceJWKSEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceJWKSEndpointConfigClient) DeleteOne(sjec *ServiceJWKSEndpointConfig) *ServiceJWKSEndpointConfigDeleteOne {
	return c.DeleteOneID(sjec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceJWKSEndpointConfigClient) DeleteOneID(id string) *ServiceJWKSEndpointConfigDeleteOne {
	builder := c.Delete().Where(servicejwksendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceJWKSEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for ServiceJWKSEndpointConfig.
func (c *ServiceJWKSEndpointConfigClient) Query() *ServiceJWKSEndpointConfigQuery {
	return &ServiceJWKSEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceJWKSEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceJWKSEndpointConfig entity by its id.
func (c *ServiceJWKSEndpointConfigClient) Get(ctx context.Context, id string) (*ServiceJWKSEndpointConfig, error) {
	return c.Query().Where(servicejwksendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceJWKSEndpointConfigClient) GetX(ctx context.Context, id string) *ServiceJWKSEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a ServiceJWKSEndpointConfig.
func (c *ServiceJWKSEndpointConfigClient) QueryService(sjec *ServiceJWKSEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sjec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicejwksendpointconfig.Table, servicejwksendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, servicejwksendpointconfig.ServiceTable, servicejwksendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(sjec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceJWKSEndpointConfigClient) Hooks() []Hook {
	return c.hooks.ServiceJWKSEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *ServiceJWKSEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.ServiceJWKSEndpointConfig
}

func (c *ServiceJWKSEndpointConfigClient) mutate(ctx context.Context, m *ServiceJWKSEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceJWKSEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceJWKSEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceJWKSEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceJWKSEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceJWKSEndpointConfig mutation op: %q", m.Op())
	}
}

// ServiceTokenEndpointConfigClient is a client for the ServiceTokenEndpointConfig schema.
type ServiceTokenEndpointConfigClient struct {
	config
}

// NewServiceTokenEndpointConfigClient returns a client for the ServiceTokenEndpointConfig from the given config.
func NewServiceTokenEndpointConfigClient(c config) *ServiceTokenEndpointConfigClient {
	return &ServiceTokenEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servicetokenendpointconfig.Hooks(f(g(h())))`.
func (c *ServiceTokenEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.ServiceTokenEndpointConfig = append(c.hooks.ServiceTokenEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `servicetokenendpointconfig.Intercept(f(g(h())))`.
func (c *ServiceTokenEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceTokenEndpointConfig = append(c.inters.ServiceTokenEndpointConfig, interceptors...)
}

// Create returns a builder for creating a ServiceTokenEndpointConfig entity.
func (c *ServiceTokenEndpointConfigClient) Create() *ServiceTokenEndpointConfigCreate {
	mutation := newServiceTokenEndpointConfigMutation(c.config, OpCreate)
	return &ServiceTokenEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceTokenEndpointConfig entities.
func (c *ServiceTokenEndpointConfigClient) CreateBulk(builders ...*ServiceTokenEndpointConfigCreate) *ServiceTokenEndpointConfigCreateBulk {
	return &ServiceTokenEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceTokenEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*ServiceTokenEndpointConfigCreate, int)) *ServiceTokenEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceTokenEndpointConfigCreateBulk{err: fmt.Errorf("calling to ServiceTokenEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceTokenEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceTokenEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceTokenEndpointConfig.
func (c *ServiceTokenEndpointConfigClient) Update() *ServiceTokenEndpointConfigUpdate {
	mutation := newServiceTokenEndpointConfigMutation(c.config, OpUpdate)
	return &ServiceTokenEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceTokenEndpointConfigClient) UpdateOne(stec *ServiceTokenEndpointConfig) *ServiceTokenEndpointConfigUpdateOne {
	mutation := newServiceTokenEndpointConfigMutation(c.config, OpUpdateOne, withServiceTokenEndpointConfig(stec))
	return &ServiceTokenEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceTokenEndpointConfigClient) UpdateOneID(id string) *ServiceTokenEndpointConfigUpdateOne {
	mutation := newServiceTokenEndpointConfigMutation(c.config, OpUpdateOne, withServiceTokenEndpointConfigID(id))
	return &ServiceTokenEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceTokenEndpointConfig.
func (c *ServiceTokenEndpointConfigClient) Delete() *ServiceTokenEndpointConfigDelete {
	mutation := newServiceTokenEndpointConfigMutation(c.config, OpDelete)
	return &ServiceTokenEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceTokenEndpointConfigClient) DeleteOne(stec *ServiceTokenEndpointConfig) *ServiceTokenEndpointConfigDeleteOne {
	return c.DeleteOneID(stec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceTokenEndpointConfigClient) DeleteOneID(id string) *ServiceTokenEndpointConfigDeleteOne {
	builder := c.Delete().Where(servicetokenendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceTokenEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for ServiceTokenEndpointConfig.
func (c *ServiceTokenEndpointConfigClient) Query() *ServiceTokenEndpointConfigQuery {
	return &ServiceTokenEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceTokenEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceTokenEndpointConfig entity by its id.
func (c *ServiceTokenEndpointConfigClient) Get(ctx context.Context, id string) (*ServiceTokenEndpointConfig, error) {
	return c.Query().Where(servicetokenendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceTokenEndpointConfigClient) GetX(ctx context.Context, id string) *ServiceTokenEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a ServiceTokenEndpointConfig.
func (c *ServiceTokenEndpointConfigClient) QueryService(stec *ServiceTokenEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := stec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicetokenendpointconfig.Table, servicetokenendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, servicetokenendpointconfig.ServiceTable, servicetokenendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(stec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceTokenEndpointConfigClient) Hooks() []Hook {
	return c.hooks.ServiceTokenEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *ServiceTokenEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.ServiceTokenEndpointConfig
}

func (c *ServiceTokenEndpointConfigClient) mutate(ctx context.Context, m *ServiceTokenEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceTokenEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceTokenEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceTokenEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceTokenEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceTokenEndpointConfig mutation op: %q", m.Op())
	}
}

// ServiceUserInfoEndpointConfigClient is a client for the ServiceUserInfoEndpointConfig schema.
type ServiceUserInfoEndpointConfigClient struct {
	config
}

// NewServiceUserInfoEndpointConfigClient returns a client for the ServiceUserInfoEndpointConfig from the given config.
func NewServiceUserInfoEndpointConfigClient(c config) *ServiceUserInfoEndpointConfigClient {
	return &ServiceUserInfoEndpointConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `serviceuserinfoendpointconfig.Hooks(f(g(h())))`.
func (c *ServiceUserInfoEndpointConfigClient) Use(hooks ...Hook) {
	c.hooks.ServiceUserInfoEndpointConfig = append(c.hooks.ServiceUserInfoEndpointConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `serviceuserinfoendpointconfig.Intercept(f(g(h())))`.
func (c *ServiceUserInfoEndpointConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceUserInfoEndpointConfig = append(c.inters.ServiceUserInfoEndpointConfig, interceptors...)
}

// Create returns a builder for creating a ServiceUserInfoEndpointConfig entity.
func (c *ServiceUserInfoEndpointConfigClient) Create() *ServiceUserInfoEndpointConfigCreate {
	mutation := newServiceUserInfoEndpointConfigMutation(c.config, OpCreate)
	return &ServiceUserInfoEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceUserInfoEndpointConfig entities.
func (c *ServiceUserInfoEndpointConfigClient) CreateBulk(builders ...*ServiceUserInfoEndpointConfigCreate) *ServiceUserInfoEndpointConfigCreateBulk {
	return &ServiceUserInfoEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceUserInfoEndpointConfigClient) MapCreateBulk(slice any, setFunc func(*ServiceUserInfoEndpointConfigCreate, int)) *ServiceUserInfoEndpointConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceUserInfoEndpointConfigCreateBulk{err: fmt.Errorf("calling to ServiceUserInfoEndpointConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceUserInfoEndpointConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceUserInfoEndpointConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceUserInfoEndpointConfig.
func (c *ServiceUserInfoEndpointConfigClient) Update() *ServiceUserInfoEndpointConfigUpdate {
	mutation := newServiceUserInfoEndpointConfigMutation(c.config, OpUpdate)
	return &ServiceUserInfoEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceUserInfoEndpointConfigClient) UpdateOne(suiec *ServiceUserInfoEndpointConfig) *ServiceUserInfoEndpointConfigUpdateOne {
	mutation := newServiceUserInfoEndpointConfigMutation(c.config, OpUpdateOne, withServiceUserInfoEndpointConfig(suiec))
	return &ServiceUserInfoEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceUserInfoEndpointConfigClient) UpdateOneID(id string) *ServiceUserInfoEndpointConfigUpdateOne {
	mutation := newServiceUserInfoEndpointConfigMutation(c.config, OpUpdateOne, withServiceUserInfoEndpointConfigID(id))
	return &ServiceUserInfoEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceUserInfoEndpointConfig.
func (c *ServiceUserInfoEndpointConfigClient) Delete() *ServiceUserInfoEndpointConfigDelete {
	mutation := newServiceUserInfoEndpointConfigMutation(c.config, OpDelete)
	return &ServiceUserInfoEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceUserInfoEndpointConfigClient) DeleteOne(suiec *ServiceUserInfoEndpointConfig) *ServiceUserInfoEndpointConfigDeleteOne {
	return c.DeleteOneID(suiec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceUserInfoEndpointConfigClient) DeleteOneID(id string) *ServiceUserInfoEndpointConfigDeleteOne {
	builder := c.Delete().Where(serviceuserinfoendpointconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceUserInfoEndpointConfigDeleteOne{builder}
}

// Query returns a query builder for ServiceUserInfoEndpointConfig.
func (c *ServiceUserInfoEndpointConfigClient) Query() *ServiceUserInfoEndpointConfigQuery {
	return &ServiceUserInfoEndpointConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceUserInfoEndpointConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceUserInfoEndpointConfig entity by its id.
func (c *ServiceUserInfoEndpointConfigClient) Get(ctx context.Context, id string) (*ServiceUserInfoEndpointConfig, error) {
	return c.Query().Where(serviceuserinfoendpointconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceUserInfoEndpointConfigClient) GetX(ctx context.Context, id string) *ServiceUserInfoEndpointConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a ServiceUserInfoEndpointConfig.
func (c *ServiceUserInfoEndpointConfigClient) QueryService(suiec *ServiceUserInfoEndpointConfig) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := suiec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceuserinfoendpointconfig.Table, serviceuserinfoendpointconfig.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, serviceuserinfoendpointconfig.ServiceTable, serviceuserinfoendpointconfig.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(suiec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceUserInfoEndpointConfigClient) Hooks() []Hook {
	return c.hooks.ServiceUserInfoEndpointConfig
}

// Interceptors returns the client interceptors.
func (c *ServiceUserInfoEndpointConfigClient) Interceptors() []Interceptor {
	return c.inters.ServiceUserInfoEndpointConfig
}

func (c *ServiceUserInfoEndpointConfigClient) mutate(ctx context.Context, m *ServiceUserInfoEndpointConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceUserInfoEndpointConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceUserInfoEndpointConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceUserInfoEndpointConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceUserInfoEndpointConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceUserInfoEndpointConfig mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id string) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id string) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id string) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id string) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthorizationPayload queries the authorization_payload edge of a Session.
func (c *SessionClient) QueryAuthorizationPayload(s *Session) *AuthorizationPayloadQuery {
	query := (&AuthorizationPayloadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(authorizationpayload.Table, authorizationpayload.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, session.AuthorizationPayloadTable, session.AuthorizationPayloadColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// SigningKeyClient is a client for the SigningKey schema.
type SigningKeyClient struct {
	config
}

// NewSigningKeyClient returns a client for the SigningKey from the given config.
func NewSigningKeyClient(c config) *SigningKeyClient {
	return &SigningKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `signingkey.Hooks(f(g(h())))`.
func (c *SigningKeyClient) Use(hooks ...Hook) {
	c.hooks.SigningKey = append(c.hooks.SigningKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `signingkey.Intercept(f(g(h())))`.
func (c *SigningKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.SigningKey = append(c.inters.SigningKey, interceptors...)
}

// Create returns a builder for creating a SigningKey entity.
func (c *SigningKeyClient) Create() *SigningKeyCreate {
	mutation := newSigningKeyMutation(c.config, OpCreate)
	return &SigningKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SigningKey entities.
func (c *SigningKeyClient) CreateBulk(builders ...*SigningKeyCreate) *SigningKeyCreateBulk {
	return &SigningKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SigningKeyClient) MapCreateBulk(slice any, setFunc func(*SigningKeyCreate, int)) *SigningKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SigningKeyCreateBulk{err: fmt.Errorf("calling to SigningKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SigningKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SigningKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SigningKey.
func (c *SigningKeyClient) Update() *SigningKeyUpdate {
	mutation := newSigningKeyMutation(c.config, OpUpdate)
	return &SigningKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SigningKeyClient) UpdateOne(sk *SigningKey) *SigningKeyUpdateOne {
	mutation := newSigningKeyMutation(c.config, OpUpdateOne, withSigningKey(sk))
	return &SigningKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SigningKeyClient) UpdateOneID(id string) *SigningKeyUpdateOne {
	mutation := newSigningKeyMutation(c.config, OpUpdateOne, withSigningKeyID(id))
	return &SigningKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SigningKey.
func (c *SigningKeyClient) Delete() *SigningKeyDelete {
	mutation := newSigningKeyMutation(c.config, OpDelete)
	return &SigningKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SigningKeyClient) DeleteOne(sk *SigningKey) *SigningKeyDeleteOne {
	return c.DeleteOneID(sk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SigningKeyClient) DeleteOneID(id string) *SigningKeyDeleteOne {
	builder := c.Delete().Where(signingkey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SigningKeyDeleteOne{builder}
}

// Query returns a query builder for SigningKey.
func (c *SigningKeyClient) Query() *SigningKeyQuery {
	return &SigningKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSigningKey},
		inters: c.Interceptors(),
	}
}

// Get returns a SigningKey entity by its id.
func (c *SigningKeyClient) Get(ctx context.Context, id string) (*SigningKey, error) {
	return c.Query().Where(signingkey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SigningKeyClient) GetX(ctx context.Context, id string) *SigningKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKeySet queries the key_set edge of a SigningKey.
func (c *SigningKeyClient) QueryKeySet(sk *SigningKey) *KeySetQuery {
	query := (&KeySetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(signingkey.Table, signingkey.FieldID, id),
			sqlgraph.To(keyset.Table, keyset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, signingkey.KeySetTable, signingkey.KeySetColumn),
		)
		fromV = sqlgraph.Neighbors(sk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SigningKeyClient) Hooks() []Hook {
	return c.hooks.SigningKey
}

// Interceptors returns the client interceptors.
func (c *SigningKeyClient) Interceptors() []Interceptor {
	return c.inters.SigningKey
}

func (c *SigningKeyClient) mutate(ctx context.Context, m *SigningKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SigningKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SigningKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SigningKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SigningKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SigningKey mutation op: %q", m.Op())
	}
}

// StandardClaimsClient is a client for the StandardClaims schema.
type StandardClaimsClient struct {
	config
}

// NewStandardClaimsClient returns a client for the StandardClaims from the given config.
func NewStandardClaimsClient(c config) *StandardClaimsClient {
	return &StandardClaimsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `standardclaims.Hooks(f(g(h())))`.
func (c *StandardClaimsClient) Use(hooks ...Hook) {
	c.hooks.StandardClaims = append(c.hooks.StandardClaims, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `standardclaims.Intercept(f(g(h())))`.
func (c *StandardClaimsClient) Intercept(interceptors ...Interceptor) {
	c.inters.StandardClaims = append(c.inters.StandardClaims, interceptors...)
}

// Create returns a builder for creating a StandardClaims entity.
func (c *StandardClaimsClient) Create() *StandardClaimsCreate {
	mutation := newStandardClaimsMutation(c.config, OpCreate)
	return &StandardClaimsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StandardClaims entities.
func (c *StandardClaimsClient) CreateBulk(builders ...*StandardClaimsCreate) *StandardClaimsCreateBulk {
	return &StandardClaimsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StandardClaimsClient) MapCreateBulk(slice any, setFunc func(*StandardClaimsCreate, int)) *StandardClaimsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StandardClaimsCreateBulk{err: fmt.Errorf("calling to StandardClaimsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StandardClaimsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StandardClaimsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StandardClaims.
func (c *StandardClaimsClient) Update() *StandardClaimsUpdate {
	mutation := newStandardClaimsMutation(c.config, OpUpdate)
	return &StandardClaimsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StandardClaimsClient) UpdateOne(sc *StandardClaims) *StandardClaimsUpdateOne {
	mutation := newStandardClaimsMutation(c.config, OpUpdateOne, withStandardClaims(sc))
	return &StandardClaimsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StandardClaimsClient) UpdateOneID(id int) *StandardClaimsUpdateOne {
	mutation := newStandardClaimsMutation(c.config, OpUpdateOne, withStandardClaimsID(id))
	return &StandardClaimsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StandardClaims.
func (c *StandardClaimsClient) Delete() *StandardClaimsDelete {
	mutation := newStandardClaimsMutation(c.config, OpDelete)
	return &StandardClaimsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StandardClaimsClient) DeleteOne(sc *StandardClaims) *StandardClaimsDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StandardClaimsClient) DeleteOneID(id int) *StandardClaimsDeleteOne {
	builder := c.Delete().Where(standardclaims.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StandardClaimsDeleteOne{builder}
}

// Query returns a query builder for StandardClaims.
func (c *StandardClaimsClient) Query() *StandardClaimsQuery {
	return &StandardClaimsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStandardClaims},
		inters: c.Interceptors(),
	}
}

// Get returns a StandardClaims entity by its id.
func (c *StandardClaimsClient) Get(ctx context.Context, id int) (*StandardClaims, error) {
	return c.Query().Where(standardclaims.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StandardClaimsClient) GetX(ctx context.Context, id int) *StandardClaims {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a StandardClaims.
func (c *StandardClaimsClient) QueryUser(sc *StandardClaims) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standardclaims.Table, standardclaims.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, standardclaims.UserTable, standardclaims.UserColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StandardClaimsClient) Hooks() []Hook {
	return c.hooks.StandardClaims
}

// Interceptors returns the client interceptors.
func (c *StandardClaimsClient) Interceptors() []Interceptor {
	return c.inters.StandardClaims
}

func (c *StandardClaimsClient) mutate(ctx context.Context, m *StandardClaimsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StandardClaimsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StandardClaimsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StandardClaimsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StandardClaimsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StandardClaims mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserPool queries the user_pool edge of a User.
func (c *UserClient) QueryUserPool(u *User) *UserPoolQuery {
	query := (&UserPoolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userpool.Table, userpool.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.UserPoolTable, user.UserPoolColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandardClaims queries the standard_claims edge of a User.
func (c *UserClient) QueryStandardClaims(u *User) *StandardClaimsQuery {
	query := (&StandardClaimsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(standardclaims.Table, standardclaims.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.StandardClaimsTable, user.StandardClaimsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserPoolClient is a client for the UserPool schema.
type UserPoolClient struct {
	config
}

// NewUserPoolClient returns a client for the UserPool from the given config.
func NewUserPoolClient(c config) *UserPoolClient {
	return &UserPoolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userpool.Hooks(f(g(h())))`.
func (c *UserPoolClient) Use(hooks ...Hook) {
	c.hooks.UserPool = append(c.hooks.UserPool, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userpool.Intercept(f(g(h())))`.
func (c *UserPoolClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserPool = append(c.inters.UserPool, interceptors...)
}

// Create returns a builder for creating a UserPool entity.
func (c *UserPoolClient) Create() *UserPoolCreate {
	mutation := newUserPoolMutation(c.config, OpCreate)
	return &UserPoolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserPool entities.
func (c *UserPoolClient) CreateBulk(builders ...*UserPoolCreate) *UserPoolCreateBulk {
	return &UserPoolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserPoolClient) MapCreateBulk(slice any, setFunc func(*UserPoolCreate, int)) *UserPoolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserPoolCreateBulk{err: fmt.Errorf("calling to UserPoolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserPoolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserPoolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserPool.
func (c *UserPoolClient) Update() *UserPoolUpdate {
	mutation := newUserPoolMutation(c.config, OpUpdate)
	return &UserPoolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserPoolClient) UpdateOne(up *UserPool) *UserPoolUpdateOne {
	mutation := newUserPoolMutation(c.config, OpUpdateOne, withUserPool(up))
	return &UserPoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserPoolClient) UpdateOneID(id string) *UserPoolUpdateOne {
	mutation := newUserPoolMutation(c.config, OpUpdateOne, withUserPoolID(id))
	return &UserPoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserPool.
func (c *UserPoolClient) Delete() *UserPoolDelete {
	mutation := newUserPoolMutation(c.config, OpDelete)
	return &UserPoolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserPoolClient) DeleteOne(up *UserPool) *UserPoolDeleteOne {
	return c.DeleteOneID(up.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserPoolClient) DeleteOneID(id string) *UserPoolDeleteOne {
	builder := c.Delete().Where(userpool.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserPoolDeleteOne{builder}
}

// Query returns a query builder for UserPool.
func (c *UserPoolClient) Query() *UserPoolQuery {
	return &UserPoolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserPool},
		inters: c.Interceptors(),
	}
}

// Get returns a UserPool entity by its id.
func (c *UserPoolClient) Get(ctx context.Context, id string) (*UserPool, error) {
	return c.Query().Where(userpool.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserPoolClient) GetX(ctx context.Context, id string) *UserPool {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a UserPool.
func (c *UserPoolClient) QueryUsers(up *UserPool) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userpool.Table, userpool.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, userpool.UsersTable, userpool.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserPoolClient) Hooks() []Hook {
	return c.hooks.UserPool
}

// Interceptors returns the client interceptors.
func (c *UserPoolClient) Interceptors() []Interceptor {
	return c.inters.UserPool
}

func (c *UserPoolClient) mutate(ctx context.Context, m *UserPoolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserPoolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserPoolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserPoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserPoolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserPool mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Application, AuthorizationCode, AuthorizationPayload, CookieStore, Credentials,
		KeySet, RefreshToken, Service, ServiceAuthorizationEndpointConfig,
		ServiceIntrospectionEndpointConfig, ServiceJWKSEndpointConfig,
		ServiceTokenEndpointConfig, ServiceUserInfoEndpointConfig, Session, SigningKey,
		StandardClaims, User, UserPool []ent.Hook
	}
	inters struct {
		Application, AuthorizationCode, AuthorizationPayload, CookieStore, Credentials,
		KeySet, RefreshToken, Service, ServiceAuthorizationEndpointConfig,
		ServiceIntrospectionEndpointConfig, ServiceJWKSEndpointConfig,
		ServiceTokenEndpointConfig, ServiceUserInfoEndpointConfig, Session, SigningKey,
		StandardClaims, User, UserPool []ent.Interceptor
	}
)
