// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"go.authbricks.com/bricks/ent/application"
	"go.authbricks.com/bricks/ent/authorizationcode"
	"go.authbricks.com/bricks/ent/authorizationpayload"
	"go.authbricks.com/bricks/ent/codegrant"
	"go.authbricks.com/bricks/ent/cookiestore"
	"go.authbricks.com/bricks/ent/credentials"
	"go.authbricks.com/bricks/ent/keyset"
	"go.authbricks.com/bricks/ent/m2mgrant"
	"go.authbricks.com/bricks/ent/predicate"
	"go.authbricks.com/bricks/ent/refreshtoken"
	"go.authbricks.com/bricks/ent/service"
	"go.authbricks.com/bricks/ent/serviceconfig"
	"go.authbricks.com/bricks/ent/session"
	"go.authbricks.com/bricks/ent/signingkey"
	"go.authbricks.com/bricks/ent/standardclaims"
	"go.authbricks.com/bricks/ent/user"
	"go.authbricks.com/bricks/ent/userpool"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplication          = "Application"
	TypeAuthorizationCode    = "AuthorizationCode"
	TypeAuthorizationPayload = "AuthorizationPayload"
	TypeCodeGrant            = "CodeGrant"
	TypeCookieStore          = "CookieStore"
	TypeCredentials          = "Credentials"
	TypeKeySet               = "KeySet"
	TypeM2MGrant             = "M2MGrant"
	TypeRefreshToken         = "RefreshToken"
	TypeService              = "Service"
	TypeServiceConfig        = "ServiceConfig"
	TypeSession              = "Session"
	TypeSigningKey           = "SigningKey"
	TypeStandardClaims       = "StandardClaims"
	TypeUser                 = "User"
	TypeUserPool             = "UserPool"
)

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	public             *bool
	clearedFields      map[string]struct{}
	m2m_grants         *string
	clearedm2m_grants  bool
	code_grants        *string
	clearedcode_grants bool
	credentials        map[string]struct{}
	removedcredentials map[string]struct{}
	clearedcredentials bool
	service            *string
	clearedservice     bool
	done               bool
	oldValue           func(context.Context) (*Application, error)
	predicates         []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id string) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Application entities.
func (m *ApplicationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ApplicationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApplicationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApplicationMutation) ResetName() {
	m.name = nil
}

// SetPublic sets the "public" field.
func (m *ApplicationMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *ApplicationMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldPublic(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *ApplicationMutation) ResetPublic() {
	m.public = nil
}

// SetM2mGrantsID sets the "m2m_grants" edge to the M2MGrant entity by id.
func (m *ApplicationMutation) SetM2mGrantsID(id string) {
	m.m2m_grants = &id
}

// ClearM2mGrants clears the "m2m_grants" edge to the M2MGrant entity.
func (m *ApplicationMutation) ClearM2mGrants() {
	m.clearedm2m_grants = true
}

// M2mGrantsCleared reports if the "m2m_grants" edge to the M2MGrant entity was cleared.
func (m *ApplicationMutation) M2mGrantsCleared() bool {
	return m.clearedm2m_grants
}

// M2mGrantsID returns the "m2m_grants" edge ID in the mutation.
func (m *ApplicationMutation) M2mGrantsID() (id string, exists bool) {
	if m.m2m_grants != nil {
		return *m.m2m_grants, true
	}
	return
}

// M2mGrantsIDs returns the "m2m_grants" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// M2mGrantsID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) M2mGrantsIDs() (ids []string) {
	if id := m.m2m_grants; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetM2mGrants resets all changes to the "m2m_grants" edge.
func (m *ApplicationMutation) ResetM2mGrants() {
	m.m2m_grants = nil
	m.clearedm2m_grants = false
}

// SetCodeGrantsID sets the "code_grants" edge to the CodeGrant entity by id.
func (m *ApplicationMutation) SetCodeGrantsID(id string) {
	m.code_grants = &id
}

// ClearCodeGrants clears the "code_grants" edge to the CodeGrant entity.
func (m *ApplicationMutation) ClearCodeGrants() {
	m.clearedcode_grants = true
}

// CodeGrantsCleared reports if the "code_grants" edge to the CodeGrant entity was cleared.
func (m *ApplicationMutation) CodeGrantsCleared() bool {
	return m.clearedcode_grants
}

// CodeGrantsID returns the "code_grants" edge ID in the mutation.
func (m *ApplicationMutation) CodeGrantsID() (id string, exists bool) {
	if m.code_grants != nil {
		return *m.code_grants, true
	}
	return
}

// CodeGrantsIDs returns the "code_grants" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodeGrantsID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) CodeGrantsIDs() (ids []string) {
	if id := m.code_grants; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodeGrants resets all changes to the "code_grants" edge.
func (m *ApplicationMutation) ResetCodeGrants() {
	m.code_grants = nil
	m.clearedcode_grants = false
}

// AddCredentialIDs adds the "credentials" edge to the Credentials entity by ids.
func (m *ApplicationMutation) AddCredentialIDs(ids ...string) {
	if m.credentials == nil {
		m.credentials = make(map[string]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credentials entity.
func (m *ApplicationMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credentials entity was cleared.
func (m *ApplicationMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credentials entity by IDs.
func (m *ApplicationMutation) RemoveCredentialIDs(ids ...string) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credentials entity.
func (m *ApplicationMutation) RemovedCredentialsIDs() (ids []string) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *ApplicationMutation) CredentialsIDs() (ids []string) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *ApplicationMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *ApplicationMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *ApplicationMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ApplicationMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *ApplicationMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ApplicationMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, application.FieldName)
	}
	if m.public != nil {
		fields = append(fields, application.FieldPublic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldName:
		return m.Name()
	case application.FieldPublic:
		return m.Public()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldName:
		return m.OldName(ctx)
	case application.FieldPublic:
		return m.OldPublic(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case application.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldName:
		m.ResetName()
		return nil
	case application.FieldPublic:
		m.ResetPublic()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.m2m_grants != nil {
		edges = append(edges, application.EdgeM2mGrants)
	}
	if m.code_grants != nil {
		edges = append(edges, application.EdgeCodeGrants)
	}
	if m.credentials != nil {
		edges = append(edges, application.EdgeCredentials)
	}
	if m.service != nil {
		edges = append(edges, application.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeM2mGrants:
		if id := m.m2m_grants; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeCodeGrants:
		if id := m.code_grants; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcredentials != nil {
		edges = append(edges, application.EdgeCredentials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedm2m_grants {
		edges = append(edges, application.EdgeM2mGrants)
	}
	if m.clearedcode_grants {
		edges = append(edges, application.EdgeCodeGrants)
	}
	if m.clearedcredentials {
		edges = append(edges, application.EdgeCredentials)
	}
	if m.clearedservice {
		edges = append(edges, application.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeM2mGrants:
		return m.clearedm2m_grants
	case application.EdgeCodeGrants:
		return m.clearedcode_grants
	case application.EdgeCredentials:
		return m.clearedcredentials
	case application.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeM2mGrants:
		m.ClearM2mGrants()
		return nil
	case application.EdgeCodeGrants:
		m.ClearCodeGrants()
		return nil
	case application.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeM2mGrants:
		m.ResetM2mGrants()
		return nil
	case application.EdgeCodeGrants:
		m.ResetCodeGrants()
		return nil
	case application.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case application.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// AuthorizationCodeMutation represents an operation that mutates the AuthorizationCode nodes in the graph.
type AuthorizationCodeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	client_name           *string
	code_challenge        *string
	code_challenge_method *string
	created_at            *time.Time
	auth_time             *time.Time
	redirect_uri          *string
	nonce                 *string
	server_name           *string
	state                 *string
	subject               *string
	granted_scopes        *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*AuthorizationCode, error)
	predicates            []predicate.AuthorizationCode
}

var _ ent.Mutation = (*AuthorizationCodeMutation)(nil)

// authorizationcodeOption allows management of the mutation configuration using functional options.
type authorizationcodeOption func(*AuthorizationCodeMutation)

// newAuthorizationCodeMutation creates new mutation for the AuthorizationCode entity.
func newAuthorizationCodeMutation(c config, op Op, opts ...authorizationcodeOption) *AuthorizationCodeMutation {
	m := &AuthorizationCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthorizationCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorizationCodeID sets the ID field of the mutation.
func withAuthorizationCodeID(id string) authorizationcodeOption {
	return func(m *AuthorizationCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthorizationCode
		)
		m.oldValue = func(ctx context.Context) (*AuthorizationCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthorizationCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthorizationCode sets the old AuthorizationCode of the mutation.
func withAuthorizationCode(node *AuthorizationCode) authorizationcodeOption {
	return func(m *AuthorizationCodeMutation) {
		m.oldValue = func(context.Context) (*AuthorizationCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorizationCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorizationCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthorizationCode entities.
func (m *AuthorizationCodeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorizationCodeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorizationCodeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthorizationCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientName sets the "client_name" field.
func (m *AuthorizationCodeMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *AuthorizationCodeMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *AuthorizationCodeMutation) ResetClientName() {
	m.client_name = nil
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *AuthorizationCodeMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *AuthorizationCodeMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *AuthorizationCodeMutation) ResetCodeChallenge() {
	m.code_challenge = nil
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *AuthorizationCodeMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *AuthorizationCodeMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *AuthorizationCodeMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthorizationCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthorizationCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthorizationCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAuthTime sets the "auth_time" field.
func (m *AuthorizationCodeMutation) SetAuthTime(t time.Time) {
	m.auth_time = &t
}

// AuthTime returns the value of the "auth_time" field in the mutation.
func (m *AuthorizationCodeMutation) AuthTime() (r time.Time, exists bool) {
	v := m.auth_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthTime returns the old "auth_time" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldAuthTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthTime: %w", err)
	}
	return oldValue.AuthTime, nil
}

// ResetAuthTime resets all changes to the "auth_time" field.
func (m *AuthorizationCodeMutation) ResetAuthTime() {
	m.auth_time = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AuthorizationCodeMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AuthorizationCodeMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AuthorizationCodeMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetNonce sets the "nonce" field.
func (m *AuthorizationCodeMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *AuthorizationCodeMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *AuthorizationCodeMutation) ResetNonce() {
	m.nonce = nil
}

// SetServerName sets the "server_name" field.
func (m *AuthorizationCodeMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *AuthorizationCodeMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ResetServerName resets all changes to the "server_name" field.
func (m *AuthorizationCodeMutation) ResetServerName() {
	m.server_name = nil
}

// SetState sets the "state" field.
func (m *AuthorizationCodeMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AuthorizationCodeMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AuthorizationCodeMutation) ResetState() {
	m.state = nil
}

// SetSubject sets the "subject" field.
func (m *AuthorizationCodeMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *AuthorizationCodeMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *AuthorizationCodeMutation) ResetSubject() {
	m.subject = nil
}

// SetGrantedScopes sets the "granted_scopes" field.
func (m *AuthorizationCodeMutation) SetGrantedScopes(s string) {
	m.granted_scopes = &s
}

// GrantedScopes returns the value of the "granted_scopes" field in the mutation.
func (m *AuthorizationCodeMutation) GrantedScopes() (r string, exists bool) {
	v := m.granted_scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedScopes returns the old "granted_scopes" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldGrantedScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedScopes: %w", err)
	}
	return oldValue.GrantedScopes, nil
}

// ResetGrantedScopes resets all changes to the "granted_scopes" field.
func (m *AuthorizationCodeMutation) ResetGrantedScopes() {
	m.granted_scopes = nil
}

// Where appends a list predicates to the AuthorizationCodeMutation builder.
func (m *AuthorizationCodeMutation) Where(ps ...predicate.AuthorizationCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthorizationCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthorizationCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthorizationCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthorizationCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthorizationCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthorizationCode).
func (m *AuthorizationCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorizationCodeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.client_name != nil {
		fields = append(fields, authorizationcode.FieldClientName)
	}
	if m.code_challenge != nil {
		fields = append(fields, authorizationcode.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, authorizationcode.FieldCodeChallengeMethod)
	}
	if m.created_at != nil {
		fields = append(fields, authorizationcode.FieldCreatedAt)
	}
	if m.auth_time != nil {
		fields = append(fields, authorizationcode.FieldAuthTime)
	}
	if m.redirect_uri != nil {
		fields = append(fields, authorizationcode.FieldRedirectURI)
	}
	if m.nonce != nil {
		fields = append(fields, authorizationcode.FieldNonce)
	}
	if m.server_name != nil {
		fields = append(fields, authorizationcode.FieldServerName)
	}
	if m.state != nil {
		fields = append(fields, authorizationcode.FieldState)
	}
	if m.subject != nil {
		fields = append(fields, authorizationcode.FieldSubject)
	}
	if m.granted_scopes != nil {
		fields = append(fields, authorizationcode.FieldGrantedScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorizationCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authorizationcode.FieldClientName:
		return m.ClientName()
	case authorizationcode.FieldCodeChallenge:
		return m.CodeChallenge()
	case authorizationcode.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	case authorizationcode.FieldCreatedAt:
		return m.CreatedAt()
	case authorizationcode.FieldAuthTime:
		return m.AuthTime()
	case authorizationcode.FieldRedirectURI:
		return m.RedirectURI()
	case authorizationcode.FieldNonce:
		return m.Nonce()
	case authorizationcode.FieldServerName:
		return m.ServerName()
	case authorizationcode.FieldState:
		return m.State()
	case authorizationcode.FieldSubject:
		return m.Subject()
	case authorizationcode.FieldGrantedScopes:
		return m.GrantedScopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorizationCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authorizationcode.FieldClientName:
		return m.OldClientName(ctx)
	case authorizationcode.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case authorizationcode.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	case authorizationcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authorizationcode.FieldAuthTime:
		return m.OldAuthTime(ctx)
	case authorizationcode.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case authorizationcode.FieldNonce:
		return m.OldNonce(ctx)
	case authorizationcode.FieldServerName:
		return m.OldServerName(ctx)
	case authorizationcode.FieldState:
		return m.OldState(ctx)
	case authorizationcode.FieldSubject:
		return m.OldSubject(ctx)
	case authorizationcode.FieldGrantedScopes:
		return m.OldGrantedScopes(ctx)
	}
	return nil, fmt.Errorf("unknown AuthorizationCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authorizationcode.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case authorizationcode.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case authorizationcode.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	case authorizationcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authorizationcode.FieldAuthTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthTime(v)
		return nil
	case authorizationcode.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case authorizationcode.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case authorizationcode.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	case authorizationcode.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case authorizationcode.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case authorizationcode.FieldGrantedScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedScopes(v)
		return nil
	}
	return fmt.Errorf("unknown AuthorizationCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorizationCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorizationCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthorizationCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorizationCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorizationCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorizationCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthorizationCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorizationCodeMutation) ResetField(name string) error {
	switch name {
	case authorizationcode.FieldClientName:
		m.ResetClientName()
		return nil
	case authorizationcode.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case authorizationcode.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	case authorizationcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authorizationcode.FieldAuthTime:
		m.ResetAuthTime()
		return nil
	case authorizationcode.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case authorizationcode.FieldNonce:
		m.ResetNonce()
		return nil
	case authorizationcode.FieldServerName:
		m.ResetServerName()
		return nil
	case authorizationcode.FieldState:
		m.ResetState()
		return nil
	case authorizationcode.FieldSubject:
		m.ResetSubject()
		return nil
	case authorizationcode.FieldGrantedScopes:
		m.ResetGrantedScopes()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorizationCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorizationCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorizationCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorizationCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorizationCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorizationCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorizationCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthorizationCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorizationCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthorizationCode edge %s", name)
}

// AuthorizationPayloadMutation represents an operation that mutates the AuthorizationPayload nodes in the graph.
type AuthorizationPayloadMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	code_challenge        *string
	code_challenge_method *string
	client_id             *string
	nonce                 *string
	redirect_uri          *string
	response_type         *string
	scope                 *string
	server_name           *string
	state                 *string
	response_mode         *string
	clearedFields         map[string]struct{}
	session               *string
	clearedsession        bool
	done                  bool
	oldValue              func(context.Context) (*AuthorizationPayload, error)
	predicates            []predicate.AuthorizationPayload
}

var _ ent.Mutation = (*AuthorizationPayloadMutation)(nil)

// authorizationpayloadOption allows management of the mutation configuration using functional options.
type authorizationpayloadOption func(*AuthorizationPayloadMutation)

// newAuthorizationPayloadMutation creates new mutation for the AuthorizationPayload entity.
func newAuthorizationPayloadMutation(c config, op Op, opts ...authorizationpayloadOption) *AuthorizationPayloadMutation {
	m := &AuthorizationPayloadMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthorizationPayload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorizationPayloadID sets the ID field of the mutation.
func withAuthorizationPayloadID(id string) authorizationpayloadOption {
	return func(m *AuthorizationPayloadMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthorizationPayload
		)
		m.oldValue = func(ctx context.Context) (*AuthorizationPayload, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthorizationPayload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthorizationPayload sets the old AuthorizationPayload of the mutation.
func withAuthorizationPayload(node *AuthorizationPayload) authorizationpayloadOption {
	return func(m *AuthorizationPayloadMutation) {
		m.oldValue = func(context.Context) (*AuthorizationPayload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorizationPayloadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorizationPayloadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthorizationPayload entities.
func (m *AuthorizationPayloadMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorizationPayloadMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorizationPayloadMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthorizationPayload.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *AuthorizationPayloadMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *AuthorizationPayloadMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *AuthorizationPayloadMutation) ResetCodeChallenge() {
	m.code_challenge = nil
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *AuthorizationPayloadMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *AuthorizationPayloadMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *AuthorizationPayloadMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
}

// SetClientID sets the "client_id" field.
func (m *AuthorizationPayloadMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuthorizationPayloadMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuthorizationPayloadMutation) ResetClientID() {
	m.client_id = nil
}

// SetNonce sets the "nonce" field.
func (m *AuthorizationPayloadMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *AuthorizationPayloadMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *AuthorizationPayloadMutation) ResetNonce() {
	m.nonce = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AuthorizationPayloadMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AuthorizationPayloadMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AuthorizationPayloadMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetResponseType sets the "response_type" field.
func (m *AuthorizationPayloadMutation) SetResponseType(s string) {
	m.response_type = &s
}

// ResponseType returns the value of the "response_type" field in the mutation.
func (m *AuthorizationPayloadMutation) ResponseType() (r string, exists bool) {
	v := m.response_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseType returns the old "response_type" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldResponseType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseType: %w", err)
	}
	return oldValue.ResponseType, nil
}

// ResetResponseType resets all changes to the "response_type" field.
func (m *AuthorizationPayloadMutation) ResetResponseType() {
	m.response_type = nil
}

// SetScope sets the "scope" field.
func (m *AuthorizationPayloadMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *AuthorizationPayloadMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *AuthorizationPayloadMutation) ResetScope() {
	m.scope = nil
}

// SetServerName sets the "server_name" field.
func (m *AuthorizationPayloadMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *AuthorizationPayloadMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ResetServerName resets all changes to the "server_name" field.
func (m *AuthorizationPayloadMutation) ResetServerName() {
	m.server_name = nil
}

// SetState sets the "state" field.
func (m *AuthorizationPayloadMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AuthorizationPayloadMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AuthorizationPayloadMutation) ResetState() {
	m.state = nil
}

// SetResponseMode sets the "response_mode" field.
func (m *AuthorizationPayloadMutation) SetResponseMode(s string) {
	m.response_mode = &s
}

// ResponseMode returns the value of the "response_mode" field in the mutation.
func (m *AuthorizationPayloadMutation) ResponseMode() (r string, exists bool) {
	v := m.response_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseMode returns the old "response_mode" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldResponseMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseMode: %w", err)
	}
	return oldValue.ResponseMode, nil
}

// ResetResponseMode resets all changes to the "response_mode" field.
func (m *AuthorizationPayloadMutation) ResetResponseMode() {
	m.response_mode = nil
}

// SetSessionID sets the "session" edge to the Session entity by id.
func (m *AuthorizationPayloadMutation) SetSessionID(id string) {
	m.session = &id
}

// ClearSession clears the "session" edge to the Session entity.
func (m *AuthorizationPayloadMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *AuthorizationPayloadMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *AuthorizationPayloadMutation) SessionID() (id string, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *AuthorizationPayloadMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *AuthorizationPayloadMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the AuthorizationPayloadMutation builder.
func (m *AuthorizationPayloadMutation) Where(ps ...predicate.AuthorizationPayload) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthorizationPayloadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthorizationPayloadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthorizationPayload, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthorizationPayloadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthorizationPayloadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthorizationPayload).
func (m *AuthorizationPayloadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorizationPayloadMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.code_challenge != nil {
		fields = append(fields, authorizationpayload.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, authorizationpayload.FieldCodeChallengeMethod)
	}
	if m.client_id != nil {
		fields = append(fields, authorizationpayload.FieldClientID)
	}
	if m.nonce != nil {
		fields = append(fields, authorizationpayload.FieldNonce)
	}
	if m.redirect_uri != nil {
		fields = append(fields, authorizationpayload.FieldRedirectURI)
	}
	if m.response_type != nil {
		fields = append(fields, authorizationpayload.FieldResponseType)
	}
	if m.scope != nil {
		fields = append(fields, authorizationpayload.FieldScope)
	}
	if m.server_name != nil {
		fields = append(fields, authorizationpayload.FieldServerName)
	}
	if m.state != nil {
		fields = append(fields, authorizationpayload.FieldState)
	}
	if m.response_mode != nil {
		fields = append(fields, authorizationpayload.FieldResponseMode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorizationPayloadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authorizationpayload.FieldCodeChallenge:
		return m.CodeChallenge()
	case authorizationpayload.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	case authorizationpayload.FieldClientID:
		return m.ClientID()
	case authorizationpayload.FieldNonce:
		return m.Nonce()
	case authorizationpayload.FieldRedirectURI:
		return m.RedirectURI()
	case authorizationpayload.FieldResponseType:
		return m.ResponseType()
	case authorizationpayload.FieldScope:
		return m.Scope()
	case authorizationpayload.FieldServerName:
		return m.ServerName()
	case authorizationpayload.FieldState:
		return m.State()
	case authorizationpayload.FieldResponseMode:
		return m.ResponseMode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorizationPayloadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authorizationpayload.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case authorizationpayload.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	case authorizationpayload.FieldClientID:
		return m.OldClientID(ctx)
	case authorizationpayload.FieldNonce:
		return m.OldNonce(ctx)
	case authorizationpayload.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case authorizationpayload.FieldResponseType:
		return m.OldResponseType(ctx)
	case authorizationpayload.FieldScope:
		return m.OldScope(ctx)
	case authorizationpayload.FieldServerName:
		return m.OldServerName(ctx)
	case authorizationpayload.FieldState:
		return m.OldState(ctx)
	case authorizationpayload.FieldResponseMode:
		return m.OldResponseMode(ctx)
	}
	return nil, fmt.Errorf("unknown AuthorizationPayload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationPayloadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authorizationpayload.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case authorizationpayload.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	case authorizationpayload.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case authorizationpayload.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case authorizationpayload.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case authorizationpayload.FieldResponseType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseType(v)
		return nil
	case authorizationpayload.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case authorizationpayload.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	case authorizationpayload.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case authorizationpayload.FieldResponseMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseMode(v)
		return nil
	}
	return fmt.Errorf("unknown AuthorizationPayload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorizationPayloadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorizationPayloadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationPayloadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthorizationPayload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorizationPayloadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorizationPayloadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorizationPayloadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthorizationPayload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorizationPayloadMutation) ResetField(name string) error {
	switch name {
	case authorizationpayload.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case authorizationpayload.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	case authorizationpayload.FieldClientID:
		m.ResetClientID()
		return nil
	case authorizationpayload.FieldNonce:
		m.ResetNonce()
		return nil
	case authorizationpayload.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case authorizationpayload.FieldResponseType:
		m.ResetResponseType()
		return nil
	case authorizationpayload.FieldScope:
		m.ResetScope()
		return nil
	case authorizationpayload.FieldServerName:
		m.ResetServerName()
		return nil
	case authorizationpayload.FieldState:
		m.ResetState()
		return nil
	case authorizationpayload.FieldResponseMode:
		m.ResetResponseMode()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationPayload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorizationPayloadMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, authorizationpayload.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorizationPayloadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authorizationpayload.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorizationPayloadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorizationPayloadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorizationPayloadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, authorizationpayload.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorizationPayloadMutation) EdgeCleared(name string) bool {
	switch name {
	case authorizationpayload.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorizationPayloadMutation) ClearEdge(name string) error {
	switch name {
	case authorizationpayload.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationPayload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorizationPayloadMutation) ResetEdge(name string) error {
	switch name {
	case authorizationpayload.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationPayload edge %s", name)
}

// CodeGrantMutation represents an operation that mutates the CodeGrant nodes in the graph.
type CodeGrantMutation struct {
	config
	op              Op
	typ             string
	id              *string
	scopes          *[]string
	appendscopes    []string
	callbacks       *[]string
	appendcallbacks []string
	clearedFields   map[string]struct{}
	client          *string
	clearedclient   bool
	done            bool
	oldValue        func(context.Context) (*CodeGrant, error)
	predicates      []predicate.CodeGrant
}

var _ ent.Mutation = (*CodeGrantMutation)(nil)

// codegrantOption allows management of the mutation configuration using functional options.
type codegrantOption func(*CodeGrantMutation)

// newCodeGrantMutation creates new mutation for the CodeGrant entity.
func newCodeGrantMutation(c config, op Op, opts ...codegrantOption) *CodeGrantMutation {
	m := &CodeGrantMutation{
		config:        c,
		op:            op,
		typ:           TypeCodeGrant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodeGrantID sets the ID field of the mutation.
func withCodeGrantID(id string) codegrantOption {
	return func(m *CodeGrantMutation) {
		var (
			err   error
			once  sync.Once
			value *CodeGrant
		)
		m.oldValue = func(ctx context.Context) (*CodeGrant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodeGrant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodeGrant sets the old CodeGrant of the mutation.
func withCodeGrant(node *CodeGrant) codegrantOption {
	return func(m *CodeGrantMutation) {
		m.oldValue = func(context.Context) (*CodeGrant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodeGrantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodeGrantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CodeGrant entities.
func (m *CodeGrantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodeGrantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodeGrantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodeGrant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScopes sets the "scopes" field.
func (m *CodeGrantMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *CodeGrantMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the CodeGrant entity.
// If the CodeGrant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeGrantMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *CodeGrantMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *CodeGrantMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *CodeGrantMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetCallbacks sets the "callbacks" field.
func (m *CodeGrantMutation) SetCallbacks(s []string) {
	m.callbacks = &s
	m.appendcallbacks = nil
}

// Callbacks returns the value of the "callbacks" field in the mutation.
func (m *CodeGrantMutation) Callbacks() (r []string, exists bool) {
	v := m.callbacks
	if v == nil {
		return
	}
	return *v, true
}

// OldCallbacks returns the old "callbacks" field's value of the CodeGrant entity.
// If the CodeGrant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeGrantMutation) OldCallbacks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallbacks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallbacks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallbacks: %w", err)
	}
	return oldValue.Callbacks, nil
}

// AppendCallbacks adds s to the "callbacks" field.
func (m *CodeGrantMutation) AppendCallbacks(s []string) {
	m.appendcallbacks = append(m.appendcallbacks, s...)
}

// AppendedCallbacks returns the list of values that were appended to the "callbacks" field in this mutation.
func (m *CodeGrantMutation) AppendedCallbacks() ([]string, bool) {
	if len(m.appendcallbacks) == 0 {
		return nil, false
	}
	return m.appendcallbacks, true
}

// ResetCallbacks resets all changes to the "callbacks" field.
func (m *CodeGrantMutation) ResetCallbacks() {
	m.callbacks = nil
	m.appendcallbacks = nil
}

// SetClientID sets the "client" edge to the Application entity by id.
func (m *CodeGrantMutation) SetClientID(id string) {
	m.client = &id
}

// ClearClient clears the "client" edge to the Application entity.
func (m *CodeGrantMutation) ClearClient() {
	m.clearedclient = true
}

// ClientCleared reports if the "client" edge to the Application entity was cleared.
func (m *CodeGrantMutation) ClientCleared() bool {
	return m.clearedclient
}

// ClientID returns the "client" edge ID in the mutation.
func (m *CodeGrantMutation) ClientID() (id string, exists bool) {
	if m.client != nil {
		return *m.client, true
	}
	return
}

// ClientIDs returns the "client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientID instead. It exists only for internal usage by the builders.
func (m *CodeGrantMutation) ClientIDs() (ids []string) {
	if id := m.client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClient resets all changes to the "client" edge.
func (m *CodeGrantMutation) ResetClient() {
	m.client = nil
	m.clearedclient = false
}

// Where appends a list predicates to the CodeGrantMutation builder.
func (m *CodeGrantMutation) Where(ps ...predicate.CodeGrant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CodeGrantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CodeGrantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CodeGrant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CodeGrantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CodeGrantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CodeGrant).
func (m *CodeGrantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodeGrantMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.scopes != nil {
		fields = append(fields, codegrant.FieldScopes)
	}
	if m.callbacks != nil {
		fields = append(fields, codegrant.FieldCallbacks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodeGrantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codegrant.FieldScopes:
		return m.Scopes()
	case codegrant.FieldCallbacks:
		return m.Callbacks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodeGrantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codegrant.FieldScopes:
		return m.OldScopes(ctx)
	case codegrant.FieldCallbacks:
		return m.OldCallbacks(ctx)
	}
	return nil, fmt.Errorf("unknown CodeGrant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeGrantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codegrant.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case codegrant.FieldCallbacks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallbacks(v)
		return nil
	}
	return fmt.Errorf("unknown CodeGrant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodeGrantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodeGrantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeGrantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodeGrant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodeGrantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodeGrantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodeGrantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodeGrant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodeGrantMutation) ResetField(name string) error {
	switch name {
	case codegrant.FieldScopes:
		m.ResetScopes()
		return nil
	case codegrant.FieldCallbacks:
		m.ResetCallbacks()
		return nil
	}
	return fmt.Errorf("unknown CodeGrant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodeGrantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.client != nil {
		edges = append(edges, codegrant.EdgeClient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodeGrantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codegrant.EdgeClient:
		if id := m.client; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodeGrantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodeGrantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodeGrantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclient {
		edges = append(edges, codegrant.EdgeClient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodeGrantMutation) EdgeCleared(name string) bool {
	switch name {
	case codegrant.EdgeClient:
		return m.clearedclient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodeGrantMutation) ClearEdge(name string) error {
	switch name {
	case codegrant.EdgeClient:
		m.ClearClient()
		return nil
	}
	return fmt.Errorf("unknown CodeGrant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodeGrantMutation) ResetEdge(name string) error {
	switch name {
	case codegrant.EdgeClient:
		m.ResetClient()
		return nil
	}
	return fmt.Errorf("unknown CodeGrant edge %s", name)
}

// CookieStoreMutation represents an operation that mutates the CookieStore nodes in the graph.
type CookieStoreMutation struct {
	config
	op             Op
	typ            string
	id             *string
	auth_key       *string
	encryption_key *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CookieStore, error)
	predicates     []predicate.CookieStore
}

var _ ent.Mutation = (*CookieStoreMutation)(nil)

// cookiestoreOption allows management of the mutation configuration using functional options.
type cookiestoreOption func(*CookieStoreMutation)

// newCookieStoreMutation creates new mutation for the CookieStore entity.
func newCookieStoreMutation(c config, op Op, opts ...cookiestoreOption) *CookieStoreMutation {
	m := &CookieStoreMutation{
		config:        c,
		op:            op,
		typ:           TypeCookieStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCookieStoreID sets the ID field of the mutation.
func withCookieStoreID(id string) cookiestoreOption {
	return func(m *CookieStoreMutation) {
		var (
			err   error
			once  sync.Once
			value *CookieStore
		)
		m.oldValue = func(ctx context.Context) (*CookieStore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CookieStore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCookieStore sets the old CookieStore of the mutation.
func withCookieStore(node *CookieStore) cookiestoreOption {
	return func(m *CookieStoreMutation) {
		m.oldValue = func(context.Context) (*CookieStore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CookieStoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CookieStoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CookieStore entities.
func (m *CookieStoreMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CookieStoreMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CookieStoreMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CookieStore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuthKey sets the "auth_key" field.
func (m *CookieStoreMutation) SetAuthKey(s string) {
	m.auth_key = &s
}

// AuthKey returns the value of the "auth_key" field in the mutation.
func (m *CookieStoreMutation) AuthKey() (r string, exists bool) {
	v := m.auth_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthKey returns the old "auth_key" field's value of the CookieStore entity.
// If the CookieStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CookieStoreMutation) OldAuthKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthKey: %w", err)
	}
	return oldValue.AuthKey, nil
}

// ResetAuthKey resets all changes to the "auth_key" field.
func (m *CookieStoreMutation) ResetAuthKey() {
	m.auth_key = nil
}

// SetEncryptionKey sets the "encryption_key" field.
func (m *CookieStoreMutation) SetEncryptionKey(s string) {
	m.encryption_key = &s
}

// EncryptionKey returns the value of the "encryption_key" field in the mutation.
func (m *CookieStoreMutation) EncryptionKey() (r string, exists bool) {
	v := m.encryption_key
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptionKey returns the old "encryption_key" field's value of the CookieStore entity.
// If the CookieStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CookieStoreMutation) OldEncryptionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptionKey: %w", err)
	}
	return oldValue.EncryptionKey, nil
}

// ResetEncryptionKey resets all changes to the "encryption_key" field.
func (m *CookieStoreMutation) ResetEncryptionKey() {
	m.encryption_key = nil
}

// Where appends a list predicates to the CookieStoreMutation builder.
func (m *CookieStoreMutation) Where(ps ...predicate.CookieStore) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CookieStoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CookieStoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CookieStore, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CookieStoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CookieStoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CookieStore).
func (m *CookieStoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CookieStoreMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.auth_key != nil {
		fields = append(fields, cookiestore.FieldAuthKey)
	}
	if m.encryption_key != nil {
		fields = append(fields, cookiestore.FieldEncryptionKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CookieStoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cookiestore.FieldAuthKey:
		return m.AuthKey()
	case cookiestore.FieldEncryptionKey:
		return m.EncryptionKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CookieStoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cookiestore.FieldAuthKey:
		return m.OldAuthKey(ctx)
	case cookiestore.FieldEncryptionKey:
		return m.OldEncryptionKey(ctx)
	}
	return nil, fmt.Errorf("unknown CookieStore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CookieStoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cookiestore.FieldAuthKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthKey(v)
		return nil
	case cookiestore.FieldEncryptionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptionKey(v)
		return nil
	}
	return fmt.Errorf("unknown CookieStore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CookieStoreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CookieStoreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CookieStoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CookieStore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CookieStoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CookieStoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CookieStoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CookieStore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CookieStoreMutation) ResetField(name string) error {
	switch name {
	case cookiestore.FieldAuthKey:
		m.ResetAuthKey()
		return nil
	case cookiestore.FieldEncryptionKey:
		m.ResetEncryptionKey()
		return nil
	}
	return fmt.Errorf("unknown CookieStore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CookieStoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CookieStoreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CookieStoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CookieStoreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CookieStoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CookieStoreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CookieStoreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CookieStore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CookieStoreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CookieStore edge %s", name)
}

// CredentialsMutation represents an operation that mutates the Credentials nodes in the graph.
type CredentialsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	client_id           *string
	client_secret       *string
	clearedFields       map[string]struct{}
	oauth_client        *string
	clearedoauth_client bool
	done                bool
	oldValue            func(context.Context) (*Credentials, error)
	predicates          []predicate.Credentials
}

var _ ent.Mutation = (*CredentialsMutation)(nil)

// credentialsOption allows management of the mutation configuration using functional options.
type credentialsOption func(*CredentialsMutation)

// newCredentialsMutation creates new mutation for the Credentials entity.
func newCredentialsMutation(c config, op Op, opts ...credentialsOption) *CredentialsMutation {
	m := &CredentialsMutation{
		config:        c,
		op:            op,
		typ:           TypeCredentials,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialsID sets the ID field of the mutation.
func withCredentialsID(id string) credentialsOption {
	return func(m *CredentialsMutation) {
		var (
			err   error
			once  sync.Once
			value *Credentials
		)
		m.oldValue = func(ctx context.Context) (*Credentials, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credentials.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredentials sets the old Credentials of the mutation.
func withCredentials(node *Credentials) credentialsOption {
	return func(m *CredentialsMutation) {
		m.oldValue = func(context.Context) (*Credentials, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Credentials entities.
func (m *CredentialsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credentials.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *CredentialsMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *CredentialsMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Credentials entity.
// If the Credentials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialsMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *CredentialsMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *CredentialsMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *CredentialsMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the Credentials entity.
// If the Credentials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialsMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *CredentialsMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetOauthClientID sets the "oauth_client" edge to the Application entity by id.
func (m *CredentialsMutation) SetOauthClientID(id string) {
	m.oauth_client = &id
}

// ClearOauthClient clears the "oauth_client" edge to the Application entity.
func (m *CredentialsMutation) ClearOauthClient() {
	m.clearedoauth_client = true
}

// OauthClientCleared reports if the "oauth_client" edge to the Application entity was cleared.
func (m *CredentialsMutation) OauthClientCleared() bool {
	return m.clearedoauth_client
}

// OauthClientID returns the "oauth_client" edge ID in the mutation.
func (m *CredentialsMutation) OauthClientID() (id string, exists bool) {
	if m.oauth_client != nil {
		return *m.oauth_client, true
	}
	return
}

// OauthClientIDs returns the "oauth_client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OauthClientID instead. It exists only for internal usage by the builders.
func (m *CredentialsMutation) OauthClientIDs() (ids []string) {
	if id := m.oauth_client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOauthClient resets all changes to the "oauth_client" edge.
func (m *CredentialsMutation) ResetOauthClient() {
	m.oauth_client = nil
	m.clearedoauth_client = false
}

// Where appends a list predicates to the CredentialsMutation builder.
func (m *CredentialsMutation) Where(ps ...predicate.Credentials) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credentials, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credentials).
func (m *CredentialsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.client_id != nil {
		fields = append(fields, credentials.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, credentials.FieldClientSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credentials.FieldClientID:
		return m.ClientID()
	case credentials.FieldClientSecret:
		return m.ClientSecret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credentials.FieldClientID:
		return m.OldClientID(ctx)
	case credentials.FieldClientSecret:
		return m.OldClientSecret(ctx)
	}
	return nil, fmt.Errorf("unknown Credentials field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credentials.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case credentials.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	}
	return fmt.Errorf("unknown Credentials field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credentials numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Credentials nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialsMutation) ResetField(name string) error {
	switch name {
	case credentials.FieldClientID:
		m.ResetClientID()
		return nil
	case credentials.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	}
	return fmt.Errorf("unknown Credentials field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.oauth_client != nil {
		edges = append(edges, credentials.EdgeOauthClient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credentials.EdgeOauthClient:
		if id := m.oauth_client; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedoauth_client {
		edges = append(edges, credentials.EdgeOauthClient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialsMutation) EdgeCleared(name string) bool {
	switch name {
	case credentials.EdgeOauthClient:
		return m.clearedoauth_client
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialsMutation) ClearEdge(name string) error {
	switch name {
	case credentials.EdgeOauthClient:
		m.ClearOauthClient()
		return nil
	}
	return fmt.Errorf("unknown Credentials unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialsMutation) ResetEdge(name string) error {
	switch name {
	case credentials.EdgeOauthClient:
		m.ResetOauthClient()
		return nil
	}
	return fmt.Errorf("unknown Credentials edge %s", name)
}

// KeySetMutation represents an operation that mutates the KeySet nodes in the graph.
type KeySetMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	clearedFields         map[string]struct{}
	service_config        *string
	clearedservice_config bool
	signing_keys          map[string]struct{}
	removedsigning_keys   map[string]struct{}
	clearedsigning_keys   bool
	done                  bool
	oldValue              func(context.Context) (*KeySet, error)
	predicates            []predicate.KeySet
}

var _ ent.Mutation = (*KeySetMutation)(nil)

// keysetOption allows management of the mutation configuration using functional options.
type keysetOption func(*KeySetMutation)

// newKeySetMutation creates new mutation for the KeySet entity.
func newKeySetMutation(c config, op Op, opts ...keysetOption) *KeySetMutation {
	m := &KeySetMutation{
		config:        c,
		op:            op,
		typ:           TypeKeySet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeySetID sets the ID field of the mutation.
func withKeySetID(id string) keysetOption {
	return func(m *KeySetMutation) {
		var (
			err   error
			once  sync.Once
			value *KeySet
		)
		m.oldValue = func(ctx context.Context) (*KeySet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KeySet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeySet sets the old KeySet of the mutation.
func withKeySet(node *KeySet) keysetOption {
	return func(m *KeySetMutation) {
		m.oldValue = func(context.Context) (*KeySet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeySetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeySetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KeySet entities.
func (m *KeySetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeySetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeySetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KeySet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetServiceConfigID sets the "service_config" edge to the ServiceConfig entity by id.
func (m *KeySetMutation) SetServiceConfigID(id string) {
	m.service_config = &id
}

// ClearServiceConfig clears the "service_config" edge to the ServiceConfig entity.
func (m *KeySetMutation) ClearServiceConfig() {
	m.clearedservice_config = true
}

// ServiceConfigCleared reports if the "service_config" edge to the ServiceConfig entity was cleared.
func (m *KeySetMutation) ServiceConfigCleared() bool {
	return m.clearedservice_config
}

// ServiceConfigID returns the "service_config" edge ID in the mutation.
func (m *KeySetMutation) ServiceConfigID() (id string, exists bool) {
	if m.service_config != nil {
		return *m.service_config, true
	}
	return
}

// ServiceConfigIDs returns the "service_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceConfigID instead. It exists only for internal usage by the builders.
func (m *KeySetMutation) ServiceConfigIDs() (ids []string) {
	if id := m.service_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceConfig resets all changes to the "service_config" edge.
func (m *KeySetMutation) ResetServiceConfig() {
	m.service_config = nil
	m.clearedservice_config = false
}

// AddSigningKeyIDs adds the "signing_keys" edge to the SigningKey entity by ids.
func (m *KeySetMutation) AddSigningKeyIDs(ids ...string) {
	if m.signing_keys == nil {
		m.signing_keys = make(map[string]struct{})
	}
	for i := range ids {
		m.signing_keys[ids[i]] = struct{}{}
	}
}

// ClearSigningKeys clears the "signing_keys" edge to the SigningKey entity.
func (m *KeySetMutation) ClearSigningKeys() {
	m.clearedsigning_keys = true
}

// SigningKeysCleared reports if the "signing_keys" edge to the SigningKey entity was cleared.
func (m *KeySetMutation) SigningKeysCleared() bool {
	return m.clearedsigning_keys
}

// RemoveSigningKeyIDs removes the "signing_keys" edge to the SigningKey entity by IDs.
func (m *KeySetMutation) RemoveSigningKeyIDs(ids ...string) {
	if m.removedsigning_keys == nil {
		m.removedsigning_keys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.signing_keys, ids[i])
		m.removedsigning_keys[ids[i]] = struct{}{}
	}
}

// RemovedSigningKeys returns the removed IDs of the "signing_keys" edge to the SigningKey entity.
func (m *KeySetMutation) RemovedSigningKeysIDs() (ids []string) {
	for id := range m.removedsigning_keys {
		ids = append(ids, id)
	}
	return
}

// SigningKeysIDs returns the "signing_keys" edge IDs in the mutation.
func (m *KeySetMutation) SigningKeysIDs() (ids []string) {
	for id := range m.signing_keys {
		ids = append(ids, id)
	}
	return
}

// ResetSigningKeys resets all changes to the "signing_keys" edge.
func (m *KeySetMutation) ResetSigningKeys() {
	m.signing_keys = nil
	m.clearedsigning_keys = false
	m.removedsigning_keys = nil
}

// Where appends a list predicates to the KeySetMutation builder.
func (m *KeySetMutation) Where(ps ...predicate.KeySet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KeySetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KeySetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.KeySet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KeySetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KeySetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (KeySet).
func (m *KeySetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeySetMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeySetMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeySetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown KeySet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeySetMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KeySet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeySetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeySetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeySetMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown KeySet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeySetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeySetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeySetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KeySet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeySetMutation) ResetField(name string) error {
	return fmt.Errorf("unknown KeySet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeySetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.service_config != nil {
		edges = append(edges, keyset.EdgeServiceConfig)
	}
	if m.signing_keys != nil {
		edges = append(edges, keyset.EdgeSigningKeys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeySetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case keyset.EdgeServiceConfig:
		if id := m.service_config; id != nil {
			return []ent.Value{*id}
		}
	case keyset.EdgeSigningKeys:
		ids := make([]ent.Value, 0, len(m.signing_keys))
		for id := range m.signing_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeySetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsigning_keys != nil {
		edges = append(edges, keyset.EdgeSigningKeys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeySetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case keyset.EdgeSigningKeys:
		ids := make([]ent.Value, 0, len(m.removedsigning_keys))
		for id := range m.removedsigning_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeySetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedservice_config {
		edges = append(edges, keyset.EdgeServiceConfig)
	}
	if m.clearedsigning_keys {
		edges = append(edges, keyset.EdgeSigningKeys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeySetMutation) EdgeCleared(name string) bool {
	switch name {
	case keyset.EdgeServiceConfig:
		return m.clearedservice_config
	case keyset.EdgeSigningKeys:
		return m.clearedsigning_keys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeySetMutation) ClearEdge(name string) error {
	switch name {
	case keyset.EdgeServiceConfig:
		m.ClearServiceConfig()
		return nil
	}
	return fmt.Errorf("unknown KeySet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeySetMutation) ResetEdge(name string) error {
	switch name {
	case keyset.EdgeServiceConfig:
		m.ResetServiceConfig()
		return nil
	case keyset.EdgeSigningKeys:
		m.ResetSigningKeys()
		return nil
	}
	return fmt.Errorf("unknown KeySet edge %s", name)
}

// M2MGrantMutation represents an operation that mutates the M2MGrant nodes in the graph.
type M2MGrantMutation struct {
	config
	op            Op
	typ           string
	id            *string
	scopes        *[]string
	appendscopes  []string
	clearedFields map[string]struct{}
	client        *string
	clearedclient bool
	done          bool
	oldValue      func(context.Context) (*M2MGrant, error)
	predicates    []predicate.M2MGrant
}

var _ ent.Mutation = (*M2MGrantMutation)(nil)

// m2mgrantOption allows management of the mutation configuration using functional options.
type m2mgrantOption func(*M2MGrantMutation)

// newM2MGrantMutation creates new mutation for the M2MGrant entity.
func newM2MGrantMutation(c config, op Op, opts ...m2mgrantOption) *M2MGrantMutation {
	m := &M2MGrantMutation{
		config:        c,
		op:            op,
		typ:           TypeM2MGrant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withM2MGrantID sets the ID field of the mutation.
func withM2MGrantID(id string) m2mgrantOption {
	return func(m *M2MGrantMutation) {
		var (
			err   error
			once  sync.Once
			value *M2MGrant
		)
		m.oldValue = func(ctx context.Context) (*M2MGrant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().M2MGrant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withM2MGrant sets the old M2MGrant of the mutation.
func withM2MGrant(node *M2MGrant) m2mgrantOption {
	return func(m *M2MGrantMutation) {
		m.oldValue = func(context.Context) (*M2MGrant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m M2MGrantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m M2MGrantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of M2MGrant entities.
func (m *M2MGrantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *M2MGrantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *M2MGrantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().M2MGrant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScopes sets the "scopes" field.
func (m *M2MGrantMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *M2MGrantMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the M2MGrant entity.
// If the M2MGrant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *M2MGrantMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *M2MGrantMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *M2MGrantMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *M2MGrantMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetClientID sets the "client" edge to the Application entity by id.
func (m *M2MGrantMutation) SetClientID(id string) {
	m.client = &id
}

// ClearClient clears the "client" edge to the Application entity.
func (m *M2MGrantMutation) ClearClient() {
	m.clearedclient = true
}

// ClientCleared reports if the "client" edge to the Application entity was cleared.
func (m *M2MGrantMutation) ClientCleared() bool {
	return m.clearedclient
}

// ClientID returns the "client" edge ID in the mutation.
func (m *M2MGrantMutation) ClientID() (id string, exists bool) {
	if m.client != nil {
		return *m.client, true
	}
	return
}

// ClientIDs returns the "client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientID instead. It exists only for internal usage by the builders.
func (m *M2MGrantMutation) ClientIDs() (ids []string) {
	if id := m.client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClient resets all changes to the "client" edge.
func (m *M2MGrantMutation) ResetClient() {
	m.client = nil
	m.clearedclient = false
}

// Where appends a list predicates to the M2MGrantMutation builder.
func (m *M2MGrantMutation) Where(ps ...predicate.M2MGrant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the M2MGrantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *M2MGrantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.M2MGrant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *M2MGrantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *M2MGrantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (M2MGrant).
func (m *M2MGrantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *M2MGrantMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.scopes != nil {
		fields = append(fields, m2mgrant.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *M2MGrantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case m2mgrant.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *M2MGrantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case m2mgrant.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown M2MGrant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *M2MGrantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case m2mgrant.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown M2MGrant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *M2MGrantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *M2MGrantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *M2MGrantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown M2MGrant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *M2MGrantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *M2MGrantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *M2MGrantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown M2MGrant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *M2MGrantMutation) ResetField(name string) error {
	switch name {
	case m2mgrant.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown M2MGrant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *M2MGrantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.client != nil {
		edges = append(edges, m2mgrant.EdgeClient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *M2MGrantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case m2mgrant.EdgeClient:
		if id := m.client; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *M2MGrantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *M2MGrantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *M2MGrantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclient {
		edges = append(edges, m2mgrant.EdgeClient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *M2MGrantMutation) EdgeCleared(name string) bool {
	switch name {
	case m2mgrant.EdgeClient:
		return m.clearedclient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *M2MGrantMutation) ClearEdge(name string) error {
	switch name {
	case m2mgrant.EdgeClient:
		m.ClearClient()
		return nil
	}
	return fmt.Errorf("unknown M2MGrant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *M2MGrantMutation) ResetEdge(name string) error {
	switch name {
	case m2mgrant.EdgeClient:
		m.ResetClient()
		return nil
	}
	return fmt.Errorf("unknown M2MGrant edge %s", name)
}

// RefreshTokenMutation represents an operation that mutates the RefreshToken nodes in the graph.
type RefreshTokenMutation struct {
	config
	op              Op
	typ             string
	id              *string
	client_name     *string
	server_name     *string
	scopes          *string
	created_at      *int64
	addcreated_at   *int64
	access_token_id *string
	lifetime        *int64
	addlifetime     *int64
	subject         *string
	key_id          *string
	auth_time       *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*RefreshToken, error)
	predicates      []predicate.RefreshToken
}

var _ ent.Mutation = (*RefreshTokenMutation)(nil)

// refreshtokenOption allows management of the mutation configuration using functional options.
type refreshtokenOption func(*RefreshTokenMutation)

// newRefreshTokenMutation creates new mutation for the RefreshToken entity.
func newRefreshTokenMutation(c config, op Op, opts ...refreshtokenOption) *RefreshTokenMutation {
	m := &RefreshTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeRefreshToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRefreshTokenID sets the ID field of the mutation.
func withRefreshTokenID(id string) refreshtokenOption {
	return func(m *RefreshTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *RefreshToken
		)
		m.oldValue = func(ctx context.Context) (*RefreshToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RefreshToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRefreshToken sets the old RefreshToken of the mutation.
func withRefreshToken(node *RefreshToken) refreshtokenOption {
	return func(m *RefreshTokenMutation) {
		m.oldValue = func(context.Context) (*RefreshToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RefreshTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RefreshTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RefreshToken entities.
func (m *RefreshTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RefreshTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RefreshTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RefreshToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientName sets the "client_name" field.
func (m *RefreshTokenMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *RefreshTokenMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *RefreshTokenMutation) ResetClientName() {
	m.client_name = nil
}

// SetServerName sets the "server_name" field.
func (m *RefreshTokenMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *RefreshTokenMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ResetServerName resets all changes to the "server_name" field.
func (m *RefreshTokenMutation) ResetServerName() {
	m.server_name = nil
}

// SetScopes sets the "scopes" field.
func (m *RefreshTokenMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *RefreshTokenMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ResetScopes resets all changes to the "scopes" field.
func (m *RefreshTokenMutation) ResetScopes() {
	m.scopes = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RefreshTokenMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RefreshTokenMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *RefreshTokenMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RefreshTokenMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RefreshTokenMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetAccessTokenID sets the "access_token_id" field.
func (m *RefreshTokenMutation) SetAccessTokenID(s string) {
	m.access_token_id = &s
}

// AccessTokenID returns the value of the "access_token_id" field in the mutation.
func (m *RefreshTokenMutation) AccessTokenID() (r string, exists bool) {
	v := m.access_token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessTokenID returns the old "access_token_id" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldAccessTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessTokenID: %w", err)
	}
	return oldValue.AccessTokenID, nil
}

// ResetAccessTokenID resets all changes to the "access_token_id" field.
func (m *RefreshTokenMutation) ResetAccessTokenID() {
	m.access_token_id = nil
}

// SetLifetime sets the "lifetime" field.
func (m *RefreshTokenMutation) SetLifetime(i int64) {
	m.lifetime = &i
	m.addlifetime = nil
}

// Lifetime returns the value of the "lifetime" field in the mutation.
func (m *RefreshTokenMutation) Lifetime() (r int64, exists bool) {
	v := m.lifetime
	if v == nil {
		return
	}
	return *v, true
}

// OldLifetime returns the old "lifetime" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldLifetime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifetime: %w", err)
	}
	return oldValue.Lifetime, nil
}

// AddLifetime adds i to the "lifetime" field.
func (m *RefreshTokenMutation) AddLifetime(i int64) {
	if m.addlifetime != nil {
		*m.addlifetime += i
	} else {
		m.addlifetime = &i
	}
}

// AddedLifetime returns the value that was added to the "lifetime" field in this mutation.
func (m *RefreshTokenMutation) AddedLifetime() (r int64, exists bool) {
	v := m.addlifetime
	if v == nil {
		return
	}
	return *v, true
}

// ResetLifetime resets all changes to the "lifetime" field.
func (m *RefreshTokenMutation) ResetLifetime() {
	m.lifetime = nil
	m.addlifetime = nil
}

// SetSubject sets the "subject" field.
func (m *RefreshTokenMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *RefreshTokenMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *RefreshTokenMutation) ResetSubject() {
	m.subject = nil
}

// SetKeyID sets the "key_id" field.
func (m *RefreshTokenMutation) SetKeyID(s string) {
	m.key_id = &s
}

// KeyID returns the value of the "key_id" field in the mutation.
func (m *RefreshTokenMutation) KeyID() (r string, exists bool) {
	v := m.key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyID returns the old "key_id" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyID: %w", err)
	}
	return oldValue.KeyID, nil
}

// ResetKeyID resets all changes to the "key_id" field.
func (m *RefreshTokenMutation) ResetKeyID() {
	m.key_id = nil
}

// SetAuthTime sets the "auth_time" field.
func (m *RefreshTokenMutation) SetAuthTime(t time.Time) {
	m.auth_time = &t
}

// AuthTime returns the value of the "auth_time" field in the mutation.
func (m *RefreshTokenMutation) AuthTime() (r time.Time, exists bool) {
	v := m.auth_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthTime returns the old "auth_time" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldAuthTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthTime: %w", err)
	}
	return oldValue.AuthTime, nil
}

// ResetAuthTime resets all changes to the "auth_time" field.
func (m *RefreshTokenMutation) ResetAuthTime() {
	m.auth_time = nil
}

// Where appends a list predicates to the RefreshTokenMutation builder.
func (m *RefreshTokenMutation) Where(ps ...predicate.RefreshToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RefreshTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RefreshTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RefreshToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RefreshTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RefreshTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RefreshToken).
func (m *RefreshTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RefreshTokenMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.client_name != nil {
		fields = append(fields, refreshtoken.FieldClientName)
	}
	if m.server_name != nil {
		fields = append(fields, refreshtoken.FieldServerName)
	}
	if m.scopes != nil {
		fields = append(fields, refreshtoken.FieldScopes)
	}
	if m.created_at != nil {
		fields = append(fields, refreshtoken.FieldCreatedAt)
	}
	if m.access_token_id != nil {
		fields = append(fields, refreshtoken.FieldAccessTokenID)
	}
	if m.lifetime != nil {
		fields = append(fields, refreshtoken.FieldLifetime)
	}
	if m.subject != nil {
		fields = append(fields, refreshtoken.FieldSubject)
	}
	if m.key_id != nil {
		fields = append(fields, refreshtoken.FieldKeyID)
	}
	if m.auth_time != nil {
		fields = append(fields, refreshtoken.FieldAuthTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RefreshTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case refreshtoken.FieldClientName:
		return m.ClientName()
	case refreshtoken.FieldServerName:
		return m.ServerName()
	case refreshtoken.FieldScopes:
		return m.Scopes()
	case refreshtoken.FieldCreatedAt:
		return m.CreatedAt()
	case refreshtoken.FieldAccessTokenID:
		return m.AccessTokenID()
	case refreshtoken.FieldLifetime:
		return m.Lifetime()
	case refreshtoken.FieldSubject:
		return m.Subject()
	case refreshtoken.FieldKeyID:
		return m.KeyID()
	case refreshtoken.FieldAuthTime:
		return m.AuthTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RefreshTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case refreshtoken.FieldClientName:
		return m.OldClientName(ctx)
	case refreshtoken.FieldServerName:
		return m.OldServerName(ctx)
	case refreshtoken.FieldScopes:
		return m.OldScopes(ctx)
	case refreshtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case refreshtoken.FieldAccessTokenID:
		return m.OldAccessTokenID(ctx)
	case refreshtoken.FieldLifetime:
		return m.OldLifetime(ctx)
	case refreshtoken.FieldSubject:
		return m.OldSubject(ctx)
	case refreshtoken.FieldKeyID:
		return m.OldKeyID(ctx)
	case refreshtoken.FieldAuthTime:
		return m.OldAuthTime(ctx)
	}
	return nil, fmt.Errorf("unknown RefreshToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefreshTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case refreshtoken.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case refreshtoken.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	case refreshtoken.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case refreshtoken.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case refreshtoken.FieldAccessTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessTokenID(v)
		return nil
	case refreshtoken.FieldLifetime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifetime(v)
		return nil
	case refreshtoken.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case refreshtoken.FieldKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyID(v)
		return nil
	case refreshtoken.FieldAuthTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthTime(v)
		return nil
	}
	return fmt.Errorf("unknown RefreshToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RefreshTokenMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, refreshtoken.FieldCreatedAt)
	}
	if m.addlifetime != nil {
		fields = append(fields, refreshtoken.FieldLifetime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RefreshTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case refreshtoken.FieldCreatedAt:
		return m.AddedCreatedAt()
	case refreshtoken.FieldLifetime:
		return m.AddedLifetime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefreshTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case refreshtoken.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case refreshtoken.FieldLifetime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLifetime(v)
		return nil
	}
	return fmt.Errorf("unknown RefreshToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RefreshTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RefreshTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RefreshTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RefreshToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RefreshTokenMutation) ResetField(name string) error {
	switch name {
	case refreshtoken.FieldClientName:
		m.ResetClientName()
		return nil
	case refreshtoken.FieldServerName:
		m.ResetServerName()
		return nil
	case refreshtoken.FieldScopes:
		m.ResetScopes()
		return nil
	case refreshtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case refreshtoken.FieldAccessTokenID:
		m.ResetAccessTokenID()
		return nil
	case refreshtoken.FieldLifetime:
		m.ResetLifetime()
		return nil
	case refreshtoken.FieldSubject:
		m.ResetSubject()
		return nil
	case refreshtoken.FieldKeyID:
		m.ResetKeyID()
		return nil
	case refreshtoken.FieldAuthTime:
		m.ResetAuthTime()
		return nil
	}
	return fmt.Errorf("unknown RefreshToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RefreshTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RefreshTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RefreshTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RefreshTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RefreshTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RefreshTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RefreshTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RefreshToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RefreshTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RefreshToken edge %s", name)
}

// ServiceMutation represents an operation that mutates the Service nodes in the graph.
type ServiceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	issuer                *string
	scopes                *[]string
	appendscopes          []string
	clearedFields         map[string]struct{}
	service_config        *string
	clearedservice_config bool
	applications          map[string]struct{}
	removedapplications   map[string]struct{}
	clearedapplications   bool
	done                  bool
	oldValue              func(context.Context) (*Service, error)
	predicates            []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows management of the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for the Service entity.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the ID field of the mutation.
func withServiceID(id string) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Service entities.
func (m *ServiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Service.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetIssuer sets the "issuer" field.
func (m *ServiceMutation) SetIssuer(s string) {
	m.issuer = &s
}

// Issuer returns the value of the "issuer" field in the mutation.
func (m *ServiceMutation) Issuer() (r string, exists bool) {
	v := m.issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old "issuer" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ResetIssuer resets all changes to the "issuer" field.
func (m *ServiceMutation) ResetIssuer() {
	m.issuer = nil
}

// SetScopes sets the "scopes" field.
func (m *ServiceMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *ServiceMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *ServiceMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *ServiceMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *ServiceMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetServiceConfigID sets the "service_config" edge to the ServiceConfig entity by id.
func (m *ServiceMutation) SetServiceConfigID(id string) {
	m.service_config = &id
}

// ClearServiceConfig clears the "service_config" edge to the ServiceConfig entity.
func (m *ServiceMutation) ClearServiceConfig() {
	m.clearedservice_config = true
}

// ServiceConfigCleared reports if the "service_config" edge to the ServiceConfig entity was cleared.
func (m *ServiceMutation) ServiceConfigCleared() bool {
	return m.clearedservice_config
}

// ServiceConfigID returns the "service_config" edge ID in the mutation.
func (m *ServiceMutation) ServiceConfigID() (id string, exists bool) {
	if m.service_config != nil {
		return *m.service_config, true
	}
	return
}

// ServiceConfigIDs returns the "service_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceConfigID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ServiceConfigIDs() (ids []string) {
	if id := m.service_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceConfig resets all changes to the "service_config" edge.
func (m *ServiceMutation) ResetServiceConfig() {
	m.service_config = nil
	m.clearedservice_config = false
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *ServiceMutation) AddApplicationIDs(ids ...string) {
	if m.applications == nil {
		m.applications = make(map[string]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *ServiceMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *ServiceMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *ServiceMutation) RemoveApplicationIDs(ids ...string) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *ServiceMutation) RemovedApplicationsIDs() (ids []string) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *ServiceMutation) ApplicationsIDs() (ids []string) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *ServiceMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// Where appends a list predicates to the ServiceMutation builder.
func (m *ServiceMutation) Where(ps ...predicate.Service) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Service, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.issuer != nil {
		fields = append(fields, service.FieldIssuer)
	}
	if m.scopes != nil {
		fields = append(fields, service.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldName:
		return m.Name()
	case service.FieldIssuer:
		return m.Issuer()
	case service.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldIssuer:
		return m.OldIssuer(ctx)
	case service.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	case service.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldIssuer:
		m.ResetIssuer()
		return nil
	case service.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.service_config != nil {
		edges = append(edges, service.EdgeServiceConfig)
	}
	if m.applications != nil {
		edges = append(edges, service.EdgeApplications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeServiceConfig:
		if id := m.service_config; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedapplications != nil {
		edges = append(edges, service.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedservice_config {
		edges = append(edges, service.EdgeServiceConfig)
	}
	if m.clearedapplications {
		edges = append(edges, service.EdgeApplications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeServiceConfig:
		return m.clearedservice_config
	case service.EdgeApplications:
		return m.clearedapplications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeServiceConfig:
		m.ClearServiceConfig()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeServiceConfig:
		m.ResetServiceConfig()
		return nil
	case service.EdgeApplications:
		m.ResetApplications()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// ServiceConfigMutation represents an operation that mutates the ServiceConfig nodes in the graph.
type ServiceConfigMutation struct {
	config
	op              Op
	typ             string
	id              *string
	clearedFields   map[string]struct{}
	service         *string
	clearedservice  bool
	key_sets        map[string]struct{}
	removedkey_sets map[string]struct{}
	clearedkey_sets bool
	done            bool
	oldValue        func(context.Context) (*ServiceConfig, error)
	predicates      []predicate.ServiceConfig
}

var _ ent.Mutation = (*ServiceConfigMutation)(nil)

// serviceconfigOption allows management of the mutation configuration using functional options.
type serviceconfigOption func(*ServiceConfigMutation)

// newServiceConfigMutation creates new mutation for the ServiceConfig entity.
func newServiceConfigMutation(c config, op Op, opts ...serviceconfigOption) *ServiceConfigMutation {
	m := &ServiceConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceConfigID sets the ID field of the mutation.
func withServiceConfigID(id string) serviceconfigOption {
	return func(m *ServiceConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceConfig
		)
		m.oldValue = func(ctx context.Context) (*ServiceConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceConfig sets the old ServiceConfig of the mutation.
func withServiceConfig(node *ServiceConfig) serviceconfigOption {
	return func(m *ServiceConfigMutation) {
		m.oldValue = func(context.Context) (*ServiceConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceConfig entities.
func (m *ServiceConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *ServiceConfigMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceConfigMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceConfigMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *ServiceConfigMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceConfigMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceConfigMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// AddKeySetIDs adds the "key_sets" edge to the KeySet entity by ids.
func (m *ServiceConfigMutation) AddKeySetIDs(ids ...string) {
	if m.key_sets == nil {
		m.key_sets = make(map[string]struct{})
	}
	for i := range ids {
		m.key_sets[ids[i]] = struct{}{}
	}
}

// ClearKeySets clears the "key_sets" edge to the KeySet entity.
func (m *ServiceConfigMutation) ClearKeySets() {
	m.clearedkey_sets = true
}

// KeySetsCleared reports if the "key_sets" edge to the KeySet entity was cleared.
func (m *ServiceConfigMutation) KeySetsCleared() bool {
	return m.clearedkey_sets
}

// RemoveKeySetIDs removes the "key_sets" edge to the KeySet entity by IDs.
func (m *ServiceConfigMutation) RemoveKeySetIDs(ids ...string) {
	if m.removedkey_sets == nil {
		m.removedkey_sets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.key_sets, ids[i])
		m.removedkey_sets[ids[i]] = struct{}{}
	}
}

// RemovedKeySets returns the removed IDs of the "key_sets" edge to the KeySet entity.
func (m *ServiceConfigMutation) RemovedKeySetsIDs() (ids []string) {
	for id := range m.removedkey_sets {
		ids = append(ids, id)
	}
	return
}

// KeySetsIDs returns the "key_sets" edge IDs in the mutation.
func (m *ServiceConfigMutation) KeySetsIDs() (ids []string) {
	for id := range m.key_sets {
		ids = append(ids, id)
	}
	return
}

// ResetKeySets resets all changes to the "key_sets" edge.
func (m *ServiceConfigMutation) ResetKeySets() {
	m.key_sets = nil
	m.clearedkey_sets = false
	m.removedkey_sets = nil
}

// Where appends a list predicates to the ServiceConfigMutation builder.
func (m *ServiceConfigMutation) Where(ps ...predicate.ServiceConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceConfig).
func (m *ServiceConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceConfigMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceConfigMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ServiceConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceConfigMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ServiceConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceConfigMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ServiceConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.service != nil {
		edges = append(edges, serviceconfig.EdgeService)
	}
	if m.key_sets != nil {
		edges = append(edges, serviceconfig.EdgeKeySets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceconfig.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case serviceconfig.EdgeKeySets:
		ids := make([]ent.Value, 0, len(m.key_sets))
		for id := range m.key_sets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedkey_sets != nil {
		edges = append(edges, serviceconfig.EdgeKeySets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceconfig.EdgeKeySets:
		ids := make([]ent.Value, 0, len(m.removedkey_sets))
		for id := range m.removedkey_sets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedservice {
		edges = append(edges, serviceconfig.EdgeService)
	}
	if m.clearedkey_sets {
		edges = append(edges, serviceconfig.EdgeKeySets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceconfig.EdgeService:
		return m.clearedservice
	case serviceconfig.EdgeKeySets:
		return m.clearedkey_sets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceConfigMutation) ClearEdge(name string) error {
	switch name {
	case serviceconfig.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown ServiceConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceConfigMutation) ResetEdge(name string) error {
	switch name {
	case serviceconfig.EdgeService:
		m.ResetService()
		return nil
	case serviceconfig.EdgeKeySets:
		m.ResetKeySets()
		return nil
	}
	return fmt.Errorf("unknown ServiceConfig edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	created_at                   *int64
	addcreated_at                *int64
	server_name                  *string
	clearedFields                map[string]struct{}
	authorization_payload        *string
	clearedauthorization_payload bool
	done                         bool
	oldValue                     func(context.Context) (*Session, error)
	predicates                   []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *SessionMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SessionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetServerName sets the "server_name" field.
func (m *SessionMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *SessionMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ResetServerName resets all changes to the "server_name" field.
func (m *SessionMutation) ResetServerName() {
	m.server_name = nil
}

// SetAuthorizationPayloadID sets the "authorization_payload" edge to the AuthorizationPayload entity by id.
func (m *SessionMutation) SetAuthorizationPayloadID(id string) {
	m.authorization_payload = &id
}

// ClearAuthorizationPayload clears the "authorization_payload" edge to the AuthorizationPayload entity.
func (m *SessionMutation) ClearAuthorizationPayload() {
	m.clearedauthorization_payload = true
}

// AuthorizationPayloadCleared reports if the "authorization_payload" edge to the AuthorizationPayload entity was cleared.
func (m *SessionMutation) AuthorizationPayloadCleared() bool {
	return m.clearedauthorization_payload
}

// AuthorizationPayloadID returns the "authorization_payload" edge ID in the mutation.
func (m *SessionMutation) AuthorizationPayloadID() (id string, exists bool) {
	if m.authorization_payload != nil {
		return *m.authorization_payload, true
	}
	return
}

// AuthorizationPayloadIDs returns the "authorization_payload" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorizationPayloadID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) AuthorizationPayloadIDs() (ids []string) {
	if id := m.authorization_payload; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthorizationPayload resets all changes to the "authorization_payload" edge.
func (m *SessionMutation) ResetAuthorizationPayload() {
	m.authorization_payload = nil
	m.clearedauthorization_payload = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.server_name != nil {
		fields = append(fields, session.FieldServerName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldServerName:
		return m.ServerName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldServerName:
		return m.OldServerName(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.AddedCreatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldServerName:
		m.ResetServerName()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.authorization_payload != nil {
		edges = append(edges, session.EdgeAuthorizationPayload)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeAuthorizationPayload:
		if id := m.authorization_payload; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthorization_payload {
		edges = append(edges, session.EdgeAuthorizationPayload)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeAuthorizationPayload:
		return m.clearedauthorization_payload
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeAuthorizationPayload:
		m.ClearAuthorizationPayload()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeAuthorizationPayload:
		m.ResetAuthorizationPayload()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SigningKeyMutation represents an operation that mutates the SigningKey nodes in the graph.
type SigningKeyMutation struct {
	config
	op             Op
	typ            string
	id             *string
	key            *string
	clearedFields  map[string]struct{}
	key_set        *string
	clearedkey_set bool
	done           bool
	oldValue       func(context.Context) (*SigningKey, error)
	predicates     []predicate.SigningKey
}

var _ ent.Mutation = (*SigningKeyMutation)(nil)

// signingkeyOption allows management of the mutation configuration using functional options.
type signingkeyOption func(*SigningKeyMutation)

// newSigningKeyMutation creates new mutation for the SigningKey entity.
func newSigningKeyMutation(c config, op Op, opts ...signingkeyOption) *SigningKeyMutation {
	m := &SigningKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningKeyID sets the ID field of the mutation.
func withSigningKeyID(id string) signingkeyOption {
	return func(m *SigningKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningKey
		)
		m.oldValue = func(ctx context.Context) (*SigningKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningKey sets the old SigningKey of the mutation.
func withSigningKey(node *SigningKey) signingkeyOption {
	return func(m *SigningKeyMutation) {
		m.oldValue = func(context.Context) (*SigningKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningKey entities.
func (m *SigningKeyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningKeyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningKeyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SigningKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SigningKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the SigningKey entity.
// If the SigningKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SigningKeyMutation) ResetKey() {
	m.key = nil
}

// SetKeySetID sets the "key_set" edge to the KeySet entity by id.
func (m *SigningKeyMutation) SetKeySetID(id string) {
	m.key_set = &id
}

// ClearKeySet clears the "key_set" edge to the KeySet entity.
func (m *SigningKeyMutation) ClearKeySet() {
	m.clearedkey_set = true
}

// KeySetCleared reports if the "key_set" edge to the KeySet entity was cleared.
func (m *SigningKeyMutation) KeySetCleared() bool {
	return m.clearedkey_set
}

// KeySetID returns the "key_set" edge ID in the mutation.
func (m *SigningKeyMutation) KeySetID() (id string, exists bool) {
	if m.key_set != nil {
		return *m.key_set, true
	}
	return
}

// KeySetIDs returns the "key_set" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeySetID instead. It exists only for internal usage by the builders.
func (m *SigningKeyMutation) KeySetIDs() (ids []string) {
	if id := m.key_set; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeySet resets all changes to the "key_set" edge.
func (m *SigningKeyMutation) ResetKeySet() {
	m.key_set = nil
	m.clearedkey_set = false
}

// Where appends a list predicates to the SigningKeyMutation builder.
func (m *SigningKeyMutation) Where(ps ...predicate.SigningKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningKey).
func (m *SigningKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningKeyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.key != nil {
		fields = append(fields, signingkey.FieldKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingkey.FieldKey:
		return m.Key()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingkey.FieldKey:
		return m.OldKey(ctx)
	}
	return nil, fmt.Errorf("unknown SigningKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingkey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SigningKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningKeyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningKeyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningKeyMutation) ResetField(name string) error {
	switch name {
	case signingkey.FieldKey:
		m.ResetKey()
		return nil
	}
	return fmt.Errorf("unknown SigningKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.key_set != nil {
		edges = append(edges, signingkey.EdgeKeySet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signingkey.EdgeKeySet:
		if id := m.key_set; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkey_set {
		edges = append(edges, signingkey.EdgeKeySet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case signingkey.EdgeKeySet:
		return m.clearedkey_set
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningKeyMutation) ClearEdge(name string) error {
	switch name {
	case signingkey.EdgeKeySet:
		m.ClearKeySet()
		return nil
	}
	return fmt.Errorf("unknown SigningKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningKeyMutation) ResetEdge(name string) error {
	switch name {
	case signingkey.EdgeKeySet:
		m.ResetKeySet()
		return nil
	}
	return fmt.Errorf("unknown SigningKey edge %s", name)
}

// StandardClaimsMutation represents an operation that mutates the StandardClaims nodes in the graph.
type StandardClaimsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	subject               *string
	name                  *string
	given_name            *string
	family_name           *string
	middle_name           *string
	nickname              *string
	preferred_username    *string
	profile               *string
	picture               *string
	website               *string
	email                 *string
	email_verified        *bool
	gender                *string
	birthdate             *string
	zoneinfo              *string
	locale                *string
	phone_number          *string
	phone_number_verified *bool
	address               *string
	updated_at            *int64
	addupdated_at         *int64
	clearedFields         map[string]struct{}
	user                  *string
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*StandardClaims, error)
	predicates            []predicate.StandardClaims
}

var _ ent.Mutation = (*StandardClaimsMutation)(nil)

// standardclaimsOption allows management of the mutation configuration using functional options.
type standardclaimsOption func(*StandardClaimsMutation)

// newStandardClaimsMutation creates new mutation for the StandardClaims entity.
func newStandardClaimsMutation(c config, op Op, opts ...standardclaimsOption) *StandardClaimsMutation {
	m := &StandardClaimsMutation{
		config:        c,
		op:            op,
		typ:           TypeStandardClaims,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStandardClaimsID sets the ID field of the mutation.
func withStandardClaimsID(id int) standardclaimsOption {
	return func(m *StandardClaimsMutation) {
		var (
			err   error
			once  sync.Once
			value *StandardClaims
		)
		m.oldValue = func(ctx context.Context) (*StandardClaims, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StandardClaims.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStandardClaims sets the old StandardClaims of the mutation.
func withStandardClaims(node *StandardClaims) standardclaimsOption {
	return func(m *StandardClaimsMutation) {
		m.oldValue = func(context.Context) (*StandardClaims, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StandardClaimsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StandardClaimsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StandardClaimsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StandardClaimsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StandardClaims.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubject sets the "subject" field.
func (m *StandardClaimsMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *StandardClaimsMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *StandardClaimsMutation) ResetSubject() {
	m.subject = nil
}

// SetName sets the "name" field.
func (m *StandardClaimsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StandardClaimsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *StandardClaimsMutation) ClearName() {
	m.name = nil
	m.clearedFields[standardclaims.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *StandardClaimsMutation) NameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *StandardClaimsMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, standardclaims.FieldName)
}

// SetGivenName sets the "given_name" field.
func (m *StandardClaimsMutation) SetGivenName(s string) {
	m.given_name = &s
}

// GivenName returns the value of the "given_name" field in the mutation.
func (m *StandardClaimsMutation) GivenName() (r string, exists bool) {
	v := m.given_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenName returns the old "given_name" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldGivenName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenName: %w", err)
	}
	return oldValue.GivenName, nil
}

// ClearGivenName clears the value of the "given_name" field.
func (m *StandardClaimsMutation) ClearGivenName() {
	m.given_name = nil
	m.clearedFields[standardclaims.FieldGivenName] = struct{}{}
}

// GivenNameCleared returns if the "given_name" field was cleared in this mutation.
func (m *StandardClaimsMutation) GivenNameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldGivenName]
	return ok
}

// ResetGivenName resets all changes to the "given_name" field.
func (m *StandardClaimsMutation) ResetGivenName() {
	m.given_name = nil
	delete(m.clearedFields, standardclaims.FieldGivenName)
}

// SetFamilyName sets the "family_name" field.
func (m *StandardClaimsMutation) SetFamilyName(s string) {
	m.family_name = &s
}

// FamilyName returns the value of the "family_name" field in the mutation.
func (m *StandardClaimsMutation) FamilyName() (r string, exists bool) {
	v := m.family_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyName returns the old "family_name" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldFamilyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamilyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamilyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyName: %w", err)
	}
	return oldValue.FamilyName, nil
}

// ClearFamilyName clears the value of the "family_name" field.
func (m *StandardClaimsMutation) ClearFamilyName() {
	m.family_name = nil
	m.clearedFields[standardclaims.FieldFamilyName] = struct{}{}
}

// FamilyNameCleared returns if the "family_name" field was cleared in this mutation.
func (m *StandardClaimsMutation) FamilyNameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldFamilyName]
	return ok
}

// ResetFamilyName resets all changes to the "family_name" field.
func (m *StandardClaimsMutation) ResetFamilyName() {
	m.family_name = nil
	delete(m.clearedFields, standardclaims.FieldFamilyName)
}

// SetMiddleName sets the "middle_name" field.
func (m *StandardClaimsMutation) SetMiddleName(s string) {
	m.middle_name = &s
}

// MiddleName returns the value of the "middle_name" field in the mutation.
func (m *StandardClaimsMutation) MiddleName() (r string, exists bool) {
	v := m.middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMiddleName returns the old "middle_name" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldMiddleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiddleName: %w", err)
	}
	return oldValue.MiddleName, nil
}

// ClearMiddleName clears the value of the "middle_name" field.
func (m *StandardClaimsMutation) ClearMiddleName() {
	m.middle_name = nil
	m.clearedFields[standardclaims.FieldMiddleName] = struct{}{}
}

// MiddleNameCleared returns if the "middle_name" field was cleared in this mutation.
func (m *StandardClaimsMutation) MiddleNameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldMiddleName]
	return ok
}

// ResetMiddleName resets all changes to the "middle_name" field.
func (m *StandardClaimsMutation) ResetMiddleName() {
	m.middle_name = nil
	delete(m.clearedFields, standardclaims.FieldMiddleName)
}

// SetNickname sets the "nickname" field.
func (m *StandardClaimsMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *StandardClaimsMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *StandardClaimsMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[standardclaims.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *StandardClaimsMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *StandardClaimsMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, standardclaims.FieldNickname)
}

// SetPreferredUsername sets the "preferred_username" field.
func (m *StandardClaimsMutation) SetPreferredUsername(s string) {
	m.preferred_username = &s
}

// PreferredUsername returns the value of the "preferred_username" field in the mutation.
func (m *StandardClaimsMutation) PreferredUsername() (r string, exists bool) {
	v := m.preferred_username
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferredUsername returns the old "preferred_username" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldPreferredUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferredUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferredUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferredUsername: %w", err)
	}
	return oldValue.PreferredUsername, nil
}

// ClearPreferredUsername clears the value of the "preferred_username" field.
func (m *StandardClaimsMutation) ClearPreferredUsername() {
	m.preferred_username = nil
	m.clearedFields[standardclaims.FieldPreferredUsername] = struct{}{}
}

// PreferredUsernameCleared returns if the "preferred_username" field was cleared in this mutation.
func (m *StandardClaimsMutation) PreferredUsernameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldPreferredUsername]
	return ok
}

// ResetPreferredUsername resets all changes to the "preferred_username" field.
func (m *StandardClaimsMutation) ResetPreferredUsername() {
	m.preferred_username = nil
	delete(m.clearedFields, standardclaims.FieldPreferredUsername)
}

// SetProfile sets the "profile" field.
func (m *StandardClaimsMutation) SetProfile(s string) {
	m.profile = &s
}

// Profile returns the value of the "profile" field in the mutation.
func (m *StandardClaimsMutation) Profile() (r string, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *StandardClaimsMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[standardclaims.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *StandardClaimsMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *StandardClaimsMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, standardclaims.FieldProfile)
}

// SetPicture sets the "picture" field.
func (m *StandardClaimsMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *StandardClaimsMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldPicture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *StandardClaimsMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[standardclaims.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *StandardClaimsMutation) PictureCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *StandardClaimsMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, standardclaims.FieldPicture)
}

// SetWebsite sets the "website" field.
func (m *StandardClaimsMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *StandardClaimsMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *StandardClaimsMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[standardclaims.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *StandardClaimsMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *StandardClaimsMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, standardclaims.FieldWebsite)
}

// SetEmail sets the "email" field.
func (m *StandardClaimsMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StandardClaimsMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *StandardClaimsMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[standardclaims.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *StandardClaimsMutation) EmailCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *StandardClaimsMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, standardclaims.FieldEmail)
}

// SetEmailVerified sets the "email_verified" field.
func (m *StandardClaimsMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *StandardClaimsMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ClearEmailVerified clears the value of the "email_verified" field.
func (m *StandardClaimsMutation) ClearEmailVerified() {
	m.email_verified = nil
	m.clearedFields[standardclaims.FieldEmailVerified] = struct{}{}
}

// EmailVerifiedCleared returns if the "email_verified" field was cleared in this mutation.
func (m *StandardClaimsMutation) EmailVerifiedCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldEmailVerified]
	return ok
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *StandardClaimsMutation) ResetEmailVerified() {
	m.email_verified = nil
	delete(m.clearedFields, standardclaims.FieldEmailVerified)
}

// SetGender sets the "gender" field.
func (m *StandardClaimsMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *StandardClaimsMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *StandardClaimsMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[standardclaims.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *StandardClaimsMutation) GenderCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *StandardClaimsMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, standardclaims.FieldGender)
}

// SetBirthdate sets the "birthdate" field.
func (m *StandardClaimsMutation) SetBirthdate(s string) {
	m.birthdate = &s
}

// Birthdate returns the value of the "birthdate" field in the mutation.
func (m *StandardClaimsMutation) Birthdate() (r string, exists bool) {
	v := m.birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdate returns the old "birthdate" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldBirthdate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdate: %w", err)
	}
	return oldValue.Birthdate, nil
}

// ClearBirthdate clears the value of the "birthdate" field.
func (m *StandardClaimsMutation) ClearBirthdate() {
	m.birthdate = nil
	m.clearedFields[standardclaims.FieldBirthdate] = struct{}{}
}

// BirthdateCleared returns if the "birthdate" field was cleared in this mutation.
func (m *StandardClaimsMutation) BirthdateCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldBirthdate]
	return ok
}

// ResetBirthdate resets all changes to the "birthdate" field.
func (m *StandardClaimsMutation) ResetBirthdate() {
	m.birthdate = nil
	delete(m.clearedFields, standardclaims.FieldBirthdate)
}

// SetZoneinfo sets the "zoneinfo" field.
func (m *StandardClaimsMutation) SetZoneinfo(s string) {
	m.zoneinfo = &s
}

// Zoneinfo returns the value of the "zoneinfo" field in the mutation.
func (m *StandardClaimsMutation) Zoneinfo() (r string, exists bool) {
	v := m.zoneinfo
	if v == nil {
		return
	}
	return *v, true
}

// OldZoneinfo returns the old "zoneinfo" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldZoneinfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZoneinfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZoneinfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZoneinfo: %w", err)
	}
	return oldValue.Zoneinfo, nil
}

// ClearZoneinfo clears the value of the "zoneinfo" field.
func (m *StandardClaimsMutation) ClearZoneinfo() {
	m.zoneinfo = nil
	m.clearedFields[standardclaims.FieldZoneinfo] = struct{}{}
}

// ZoneinfoCleared returns if the "zoneinfo" field was cleared in this mutation.
func (m *StandardClaimsMutation) ZoneinfoCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldZoneinfo]
	return ok
}

// ResetZoneinfo resets all changes to the "zoneinfo" field.
func (m *StandardClaimsMutation) ResetZoneinfo() {
	m.zoneinfo = nil
	delete(m.clearedFields, standardclaims.FieldZoneinfo)
}

// SetLocale sets the "locale" field.
func (m *StandardClaimsMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *StandardClaimsMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ClearLocale clears the value of the "locale" field.
func (m *StandardClaimsMutation) ClearLocale() {
	m.locale = nil
	m.clearedFields[standardclaims.FieldLocale] = struct{}{}
}

// LocaleCleared returns if the "locale" field was cleared in this mutation.
func (m *StandardClaimsMutation) LocaleCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldLocale]
	return ok
}

// ResetLocale resets all changes to the "locale" field.
func (m *StandardClaimsMutation) ResetLocale() {
	m.locale = nil
	delete(m.clearedFields, standardclaims.FieldLocale)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *StandardClaimsMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *StandardClaimsMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *StandardClaimsMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[standardclaims.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *StandardClaimsMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *StandardClaimsMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, standardclaims.FieldPhoneNumber)
}

// SetPhoneNumberVerified sets the "phone_number_verified" field.
func (m *StandardClaimsMutation) SetPhoneNumberVerified(b bool) {
	m.phone_number_verified = &b
}

// PhoneNumberVerified returns the value of the "phone_number_verified" field in the mutation.
func (m *StandardClaimsMutation) PhoneNumberVerified() (r bool, exists bool) {
	v := m.phone_number_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumberVerified returns the old "phone_number_verified" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldPhoneNumberVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumberVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumberVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumberVerified: %w", err)
	}
	return oldValue.PhoneNumberVerified, nil
}

// ClearPhoneNumberVerified clears the value of the "phone_number_verified" field.
func (m *StandardClaimsMutation) ClearPhoneNumberVerified() {
	m.phone_number_verified = nil
	m.clearedFields[standardclaims.FieldPhoneNumberVerified] = struct{}{}
}

// PhoneNumberVerifiedCleared returns if the "phone_number_verified" field was cleared in this mutation.
func (m *StandardClaimsMutation) PhoneNumberVerifiedCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldPhoneNumberVerified]
	return ok
}

// ResetPhoneNumberVerified resets all changes to the "phone_number_verified" field.
func (m *StandardClaimsMutation) ResetPhoneNumberVerified() {
	m.phone_number_verified = nil
	delete(m.clearedFields, standardclaims.FieldPhoneNumberVerified)
}

// SetAddress sets the "address" field.
func (m *StandardClaimsMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *StandardClaimsMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *StandardClaimsMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[standardclaims.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *StandardClaimsMutation) AddressCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *StandardClaimsMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, standardclaims.FieldAddress)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StandardClaimsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StandardClaimsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *StandardClaimsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StandardClaimsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StandardClaimsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[standardclaims.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StandardClaimsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StandardClaimsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, standardclaims.FieldUpdatedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StandardClaimsMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StandardClaimsMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StandardClaimsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StandardClaimsMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StandardClaimsMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StandardClaimsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the StandardClaimsMutation builder.
func (m *StandardClaimsMutation) Where(ps ...predicate.StandardClaims) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StandardClaimsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StandardClaimsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StandardClaims, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StandardClaimsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StandardClaimsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StandardClaims).
func (m *StandardClaimsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StandardClaimsMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.subject != nil {
		fields = append(fields, standardclaims.FieldSubject)
	}
	if m.name != nil {
		fields = append(fields, standardclaims.FieldName)
	}
	if m.given_name != nil {
		fields = append(fields, standardclaims.FieldGivenName)
	}
	if m.family_name != nil {
		fields = append(fields, standardclaims.FieldFamilyName)
	}
	if m.middle_name != nil {
		fields = append(fields, standardclaims.FieldMiddleName)
	}
	if m.nickname != nil {
		fields = append(fields, standardclaims.FieldNickname)
	}
	if m.preferred_username != nil {
		fields = append(fields, standardclaims.FieldPreferredUsername)
	}
	if m.profile != nil {
		fields = append(fields, standardclaims.FieldProfile)
	}
	if m.picture != nil {
		fields = append(fields, standardclaims.FieldPicture)
	}
	if m.website != nil {
		fields = append(fields, standardclaims.FieldWebsite)
	}
	if m.email != nil {
		fields = append(fields, standardclaims.FieldEmail)
	}
	if m.email_verified != nil {
		fields = append(fields, standardclaims.FieldEmailVerified)
	}
	if m.gender != nil {
		fields = append(fields, standardclaims.FieldGender)
	}
	if m.birthdate != nil {
		fields = append(fields, standardclaims.FieldBirthdate)
	}
	if m.zoneinfo != nil {
		fields = append(fields, standardclaims.FieldZoneinfo)
	}
	if m.locale != nil {
		fields = append(fields, standardclaims.FieldLocale)
	}
	if m.phone_number != nil {
		fields = append(fields, standardclaims.FieldPhoneNumber)
	}
	if m.phone_number_verified != nil {
		fields = append(fields, standardclaims.FieldPhoneNumberVerified)
	}
	if m.address != nil {
		fields = append(fields, standardclaims.FieldAddress)
	}
	if m.updated_at != nil {
		fields = append(fields, standardclaims.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StandardClaimsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case standardclaims.FieldSubject:
		return m.Subject()
	case standardclaims.FieldName:
		return m.Name()
	case standardclaims.FieldGivenName:
		return m.GivenName()
	case standardclaims.FieldFamilyName:
		return m.FamilyName()
	case standardclaims.FieldMiddleName:
		return m.MiddleName()
	case standardclaims.FieldNickname:
		return m.Nickname()
	case standardclaims.FieldPreferredUsername:
		return m.PreferredUsername()
	case standardclaims.FieldProfile:
		return m.Profile()
	case standardclaims.FieldPicture:
		return m.Picture()
	case standardclaims.FieldWebsite:
		return m.Website()
	case standardclaims.FieldEmail:
		return m.Email()
	case standardclaims.FieldEmailVerified:
		return m.EmailVerified()
	case standardclaims.FieldGender:
		return m.Gender()
	case standardclaims.FieldBirthdate:
		return m.Birthdate()
	case standardclaims.FieldZoneinfo:
		return m.Zoneinfo()
	case standardclaims.FieldLocale:
		return m.Locale()
	case standardclaims.FieldPhoneNumber:
		return m.PhoneNumber()
	case standardclaims.FieldPhoneNumberVerified:
		return m.PhoneNumberVerified()
	case standardclaims.FieldAddress:
		return m.Address()
	case standardclaims.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StandardClaimsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case standardclaims.FieldSubject:
		return m.OldSubject(ctx)
	case standardclaims.FieldName:
		return m.OldName(ctx)
	case standardclaims.FieldGivenName:
		return m.OldGivenName(ctx)
	case standardclaims.FieldFamilyName:
		return m.OldFamilyName(ctx)
	case standardclaims.FieldMiddleName:
		return m.OldMiddleName(ctx)
	case standardclaims.FieldNickname:
		return m.OldNickname(ctx)
	case standardclaims.FieldPreferredUsername:
		return m.OldPreferredUsername(ctx)
	case standardclaims.FieldProfile:
		return m.OldProfile(ctx)
	case standardclaims.FieldPicture:
		return m.OldPicture(ctx)
	case standardclaims.FieldWebsite:
		return m.OldWebsite(ctx)
	case standardclaims.FieldEmail:
		return m.OldEmail(ctx)
	case standardclaims.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case standardclaims.FieldGender:
		return m.OldGender(ctx)
	case standardclaims.FieldBirthdate:
		return m.OldBirthdate(ctx)
	case standardclaims.FieldZoneinfo:
		return m.OldZoneinfo(ctx)
	case standardclaims.FieldLocale:
		return m.OldLocale(ctx)
	case standardclaims.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case standardclaims.FieldPhoneNumberVerified:
		return m.OldPhoneNumberVerified(ctx)
	case standardclaims.FieldAddress:
		return m.OldAddress(ctx)
	case standardclaims.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StandardClaims field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardClaimsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case standardclaims.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case standardclaims.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case standardclaims.FieldGivenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenName(v)
		return nil
	case standardclaims.FieldFamilyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyName(v)
		return nil
	case standardclaims.FieldMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiddleName(v)
		return nil
	case standardclaims.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case standardclaims.FieldPreferredUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferredUsername(v)
		return nil
	case standardclaims.FieldProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case standardclaims.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case standardclaims.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case standardclaims.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case standardclaims.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case standardclaims.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case standardclaims.FieldBirthdate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdate(v)
		return nil
	case standardclaims.FieldZoneinfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZoneinfo(v)
		return nil
	case standardclaims.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case standardclaims.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case standardclaims.FieldPhoneNumberVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumberVerified(v)
		return nil
	case standardclaims.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case standardclaims.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StandardClaims field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StandardClaimsMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_at != nil {
		fields = append(fields, standardclaims.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StandardClaimsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case standardclaims.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardClaimsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case standardclaims.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StandardClaims numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StandardClaimsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(standardclaims.FieldName) {
		fields = append(fields, standardclaims.FieldName)
	}
	if m.FieldCleared(standardclaims.FieldGivenName) {
		fields = append(fields, standardclaims.FieldGivenName)
	}
	if m.FieldCleared(standardclaims.FieldFamilyName) {
		fields = append(fields, standardclaims.FieldFamilyName)
	}
	if m.FieldCleared(standardclaims.FieldMiddleName) {
		fields = append(fields, standardclaims.FieldMiddleName)
	}
	if m.FieldCleared(standardclaims.FieldNickname) {
		fields = append(fields, standardclaims.FieldNickname)
	}
	if m.FieldCleared(standardclaims.FieldPreferredUsername) {
		fields = append(fields, standardclaims.FieldPreferredUsername)
	}
	if m.FieldCleared(standardclaims.FieldProfile) {
		fields = append(fields, standardclaims.FieldProfile)
	}
	if m.FieldCleared(standardclaims.FieldPicture) {
		fields = append(fields, standardclaims.FieldPicture)
	}
	if m.FieldCleared(standardclaims.FieldWebsite) {
		fields = append(fields, standardclaims.FieldWebsite)
	}
	if m.FieldCleared(standardclaims.FieldEmail) {
		fields = append(fields, standardclaims.FieldEmail)
	}
	if m.FieldCleared(standardclaims.FieldEmailVerified) {
		fields = append(fields, standardclaims.FieldEmailVerified)
	}
	if m.FieldCleared(standardclaims.FieldGender) {
		fields = append(fields, standardclaims.FieldGender)
	}
	if m.FieldCleared(standardclaims.FieldBirthdate) {
		fields = append(fields, standardclaims.FieldBirthdate)
	}
	if m.FieldCleared(standardclaims.FieldZoneinfo) {
		fields = append(fields, standardclaims.FieldZoneinfo)
	}
	if m.FieldCleared(standardclaims.FieldLocale) {
		fields = append(fields, standardclaims.FieldLocale)
	}
	if m.FieldCleared(standardclaims.FieldPhoneNumber) {
		fields = append(fields, standardclaims.FieldPhoneNumber)
	}
	if m.FieldCleared(standardclaims.FieldPhoneNumberVerified) {
		fields = append(fields, standardclaims.FieldPhoneNumberVerified)
	}
	if m.FieldCleared(standardclaims.FieldAddress) {
		fields = append(fields, standardclaims.FieldAddress)
	}
	if m.FieldCleared(standardclaims.FieldUpdatedAt) {
		fields = append(fields, standardclaims.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StandardClaimsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StandardClaimsMutation) ClearField(name string) error {
	switch name {
	case standardclaims.FieldName:
		m.ClearName()
		return nil
	case standardclaims.FieldGivenName:
		m.ClearGivenName()
		return nil
	case standardclaims.FieldFamilyName:
		m.ClearFamilyName()
		return nil
	case standardclaims.FieldMiddleName:
		m.ClearMiddleName()
		return nil
	case standardclaims.FieldNickname:
		m.ClearNickname()
		return nil
	case standardclaims.FieldPreferredUsername:
		m.ClearPreferredUsername()
		return nil
	case standardclaims.FieldProfile:
		m.ClearProfile()
		return nil
	case standardclaims.FieldPicture:
		m.ClearPicture()
		return nil
	case standardclaims.FieldWebsite:
		m.ClearWebsite()
		return nil
	case standardclaims.FieldEmail:
		m.ClearEmail()
		return nil
	case standardclaims.FieldEmailVerified:
		m.ClearEmailVerified()
		return nil
	case standardclaims.FieldGender:
		m.ClearGender()
		return nil
	case standardclaims.FieldBirthdate:
		m.ClearBirthdate()
		return nil
	case standardclaims.FieldZoneinfo:
		m.ClearZoneinfo()
		return nil
	case standardclaims.FieldLocale:
		m.ClearLocale()
		return nil
	case standardclaims.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case standardclaims.FieldPhoneNumberVerified:
		m.ClearPhoneNumberVerified()
		return nil
	case standardclaims.FieldAddress:
		m.ClearAddress()
		return nil
	case standardclaims.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown StandardClaims nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StandardClaimsMutation) ResetField(name string) error {
	switch name {
	case standardclaims.FieldSubject:
		m.ResetSubject()
		return nil
	case standardclaims.FieldName:
		m.ResetName()
		return nil
	case standardclaims.FieldGivenName:
		m.ResetGivenName()
		return nil
	case standardclaims.FieldFamilyName:
		m.ResetFamilyName()
		return nil
	case standardclaims.FieldMiddleName:
		m.ResetMiddleName()
		return nil
	case standardclaims.FieldNickname:
		m.ResetNickname()
		return nil
	case standardclaims.FieldPreferredUsername:
		m.ResetPreferredUsername()
		return nil
	case standardclaims.FieldProfile:
		m.ResetProfile()
		return nil
	case standardclaims.FieldPicture:
		m.ResetPicture()
		return nil
	case standardclaims.FieldWebsite:
		m.ResetWebsite()
		return nil
	case standardclaims.FieldEmail:
		m.ResetEmail()
		return nil
	case standardclaims.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case standardclaims.FieldGender:
		m.ResetGender()
		return nil
	case standardclaims.FieldBirthdate:
		m.ResetBirthdate()
		return nil
	case standardclaims.FieldZoneinfo:
		m.ResetZoneinfo()
		return nil
	case standardclaims.FieldLocale:
		m.ResetLocale()
		return nil
	case standardclaims.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case standardclaims.FieldPhoneNumberVerified:
		m.ResetPhoneNumberVerified()
		return nil
	case standardclaims.FieldAddress:
		m.ResetAddress()
		return nil
	case standardclaims.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown StandardClaims field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StandardClaimsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, standardclaims.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StandardClaimsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case standardclaims.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StandardClaimsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StandardClaimsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StandardClaimsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, standardclaims.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StandardClaimsMutation) EdgeCleared(name string) bool {
	switch name {
	case standardclaims.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StandardClaimsMutation) ClearEdge(name string) error {
	switch name {
	case standardclaims.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown StandardClaims unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StandardClaimsMutation) ResetEdge(name string) error {
	switch name {
	case standardclaims.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown StandardClaims edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	username               *string
	password               *string
	clearedFields          map[string]struct{}
	user_pool              *string
	cleareduser_pool       bool
	standard_claims        *int
	clearedstandard_claims bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetUserPoolID sets the "user_pool" edge to the UserPool entity by id.
func (m *UserMutation) SetUserPoolID(id string) {
	m.user_pool = &id
}

// ClearUserPool clears the "user_pool" edge to the UserPool entity.
func (m *UserMutation) ClearUserPool() {
	m.cleareduser_pool = true
}

// UserPoolCleared reports if the "user_pool" edge to the UserPool entity was cleared.
func (m *UserMutation) UserPoolCleared() bool {
	return m.cleareduser_pool
}

// UserPoolID returns the "user_pool" edge ID in the mutation.
func (m *UserMutation) UserPoolID() (id string, exists bool) {
	if m.user_pool != nil {
		return *m.user_pool, true
	}
	return
}

// UserPoolIDs returns the "user_pool" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserPoolID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserPoolIDs() (ids []string) {
	if id := m.user_pool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserPool resets all changes to the "user_pool" edge.
func (m *UserMutation) ResetUserPool() {
	m.user_pool = nil
	m.cleareduser_pool = false
}

// SetStandardClaimsID sets the "standard_claims" edge to the StandardClaims entity by id.
func (m *UserMutation) SetStandardClaimsID(id int) {
	m.standard_claims = &id
}

// ClearStandardClaims clears the "standard_claims" edge to the StandardClaims entity.
func (m *UserMutation) ClearStandardClaims() {
	m.clearedstandard_claims = true
}

// StandardClaimsCleared reports if the "standard_claims" edge to the StandardClaims entity was cleared.
func (m *UserMutation) StandardClaimsCleared() bool {
	return m.clearedstandard_claims
}

// StandardClaimsID returns the "standard_claims" edge ID in the mutation.
func (m *UserMutation) StandardClaimsID() (id int, exists bool) {
	if m.standard_claims != nil {
		return *m.standard_claims, true
	}
	return
}

// StandardClaimsIDs returns the "standard_claims" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StandardClaimsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) StandardClaimsIDs() (ids []int) {
	if id := m.standard_claims; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStandardClaims resets all changes to the "standard_claims" edge.
func (m *UserMutation) ResetStandardClaims() {
	m.standard_claims = nil
	m.clearedstandard_claims = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_pool != nil {
		edges = append(edges, user.EdgeUserPool)
	}
	if m.standard_claims != nil {
		edges = append(edges, user.EdgeStandardClaims)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserPool:
		if id := m.user_pool; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeStandardClaims:
		if id := m.standard_claims; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_pool {
		edges = append(edges, user.EdgeUserPool)
	}
	if m.clearedstandard_claims {
		edges = append(edges, user.EdgeStandardClaims)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserPool:
		return m.cleareduser_pool
	case user.EdgeStandardClaims:
		return m.clearedstandard_claims
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeUserPool:
		m.ClearUserPool()
		return nil
	case user.EdgeStandardClaims:
		m.ClearStandardClaims()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserPool:
		m.ResetUserPool()
		return nil
	case user.EdgeStandardClaims:
		m.ResetStandardClaims()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserPoolMutation represents an operation that mutates the UserPool nodes in the graph.
type UserPoolMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	users         map[string]struct{}
	removedusers  map[string]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*UserPool, error)
	predicates    []predicate.UserPool
}

var _ ent.Mutation = (*UserPoolMutation)(nil)

// userpoolOption allows management of the mutation configuration using functional options.
type userpoolOption func(*UserPoolMutation)

// newUserPoolMutation creates new mutation for the UserPool entity.
func newUserPoolMutation(c config, op Op, opts ...userpoolOption) *UserPoolMutation {
	m := &UserPoolMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPoolID sets the ID field of the mutation.
func withUserPoolID(id string) userpoolOption {
	return func(m *UserPoolMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPool
		)
		m.oldValue = func(ctx context.Context) (*UserPool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPool sets the old UserPool of the mutation.
func withUserPool(node *UserPool) userpoolOption {
	return func(m *UserPoolMutation) {
		m.oldValue = func(context.Context) (*UserPool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPool entities.
func (m *UserPoolMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPoolMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPoolMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *UserPoolMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *UserPoolMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *UserPoolMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *UserPoolMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *UserPoolMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *UserPoolMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UserPoolMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the UserPoolMutation builder.
func (m *UserPoolMutation) Where(ps ...predicate.UserPool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPoolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPoolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPoolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPoolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPool).
func (m *UserPoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPoolMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPoolMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown UserPool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserPool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPoolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPoolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPoolMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown UserPool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPoolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPoolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserPool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPoolMutation) ResetField(name string) error {
	return fmt.Errorf("unknown UserPool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, userpool.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpool.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, userpool.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userpool.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, userpool.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPoolMutation) EdgeCleared(name string) bool {
	switch name {
	case userpool.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPoolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserPool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPoolMutation) ResetEdge(name string) error {
	switch name {
	case userpool.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown UserPool edge %s", name)
}
