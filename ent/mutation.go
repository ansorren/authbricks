// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"go.authbricks.com/bricks/ent/application"
	"go.authbricks.com/bricks/ent/authorizationcode"
	"go.authbricks.com/bricks/ent/authorizationpayload"
	"go.authbricks.com/bricks/ent/cookiestore"
	"go.authbricks.com/bricks/ent/credentials"
	"go.authbricks.com/bricks/ent/keyset"
	"go.authbricks.com/bricks/ent/predicate"
	"go.authbricks.com/bricks/ent/refreshtoken"
	"go.authbricks.com/bricks/ent/service"
	"go.authbricks.com/bricks/ent/serviceauthorizationendpointconfig"
	"go.authbricks.com/bricks/ent/serviceintrospectionendpointconfig"
	"go.authbricks.com/bricks/ent/servicejwksendpointconfig"
	"go.authbricks.com/bricks/ent/servicetokenendpointconfig"
	"go.authbricks.com/bricks/ent/serviceuserinfoendpointconfig"
	"go.authbricks.com/bricks/ent/session"
	"go.authbricks.com/bricks/ent/signingkey"
	"go.authbricks.com/bricks/ent/standardclaims"
	"go.authbricks.com/bricks/ent/user"
	"go.authbricks.com/bricks/ent/userpool"
	"go.authbricks.com/bricks/ent/wellknownendpointconfig"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplication                        = "Application"
	TypeAuthorizationCode                  = "AuthorizationCode"
	TypeAuthorizationPayload               = "AuthorizationPayload"
	TypeCookieStore                        = "CookieStore"
	TypeCredentials                        = "Credentials"
	TypeKeySet                             = "KeySet"
	TypeRefreshToken                       = "RefreshToken"
	TypeService                            = "Service"
	TypeServiceAuthorizationEndpointConfig = "ServiceAuthorizationEndpointConfig"
	TypeServiceIntrospectionEndpointConfig = "ServiceIntrospectionEndpointConfig"
	TypeServiceJWKSEndpointConfig          = "ServiceJWKSEndpointConfig"
	TypeServiceTokenEndpointConfig         = "ServiceTokenEndpointConfig"
	TypeServiceUserInfoEndpointConfig      = "ServiceUserInfoEndpointConfig"
	TypeSession                            = "Session"
	TypeSigningKey                         = "SigningKey"
	TypeStandardClaims                     = "StandardClaims"
	TypeUser                               = "User"
	TypeUserPool                           = "UserPool"
	TypeWellKnownEndpointConfig            = "WellKnownEndpointConfig"
)

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *string
	name                                 *string
	public                               *bool
	description                          *string
	redirect_uris                        *[]string
	appendredirect_uris                  []string
	response_types                       *[]string
	appendresponse_types                 []string
	grant_types                          *[]string
	appendgrant_types                    []string
	scopes                               *[]string
	appendscopes                         []string
	pkce_required                        *bool
	s256_code_challenge_method_required  *bool
	allowed_authentication_methods       *[]string
	appendallowed_authentication_methods []string
	clearedFields                        map[string]struct{}
	credentials                          map[string]struct{}
	removedcredentials                   map[string]struct{}
	clearedcredentials                   bool
	service                              *string
	clearedservice                       bool
	done                                 bool
	oldValue                             func(context.Context) (*Application, error)
	predicates                           []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id string) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Application entities.
func (m *ApplicationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ApplicationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApplicationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApplicationMutation) ResetName() {
	m.name = nil
}

// SetPublic sets the "public" field.
func (m *ApplicationMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *ApplicationMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *ApplicationMutation) ResetPublic() {
	m.public = nil
}

// SetDescription sets the "description" field.
func (m *ApplicationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ApplicationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ApplicationMutation) ResetDescription() {
	m.description = nil
}

// SetRedirectUris sets the "redirect_uris" field.
func (m *ApplicationMutation) SetRedirectUris(s []string) {
	m.redirect_uris = &s
	m.appendredirect_uris = nil
}

// RedirectUris returns the value of the "redirect_uris" field in the mutation.
func (m *ApplicationMutation) RedirectUris() (r []string, exists bool) {
	v := m.redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectUris returns the old "redirect_uris" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectUris: %w", err)
	}
	return oldValue.RedirectUris, nil
}

// AppendRedirectUris adds s to the "redirect_uris" field.
func (m *ApplicationMutation) AppendRedirectUris(s []string) {
	m.appendredirect_uris = append(m.appendredirect_uris, s...)
}

// AppendedRedirectUris returns the list of values that were appended to the "redirect_uris" field in this mutation.
func (m *ApplicationMutation) AppendedRedirectUris() ([]string, bool) {
	if len(m.appendredirect_uris) == 0 {
		return nil, false
	}
	return m.appendredirect_uris, true
}

// ResetRedirectUris resets all changes to the "redirect_uris" field.
func (m *ApplicationMutation) ResetRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
}

// SetResponseTypes sets the "response_types" field.
func (m *ApplicationMutation) SetResponseTypes(s []string) {
	m.response_types = &s
	m.appendresponse_types = nil
}

// ResponseTypes returns the value of the "response_types" field in the mutation.
func (m *ApplicationMutation) ResponseTypes() (r []string, exists bool) {
	v := m.response_types
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTypes returns the old "response_types" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldResponseTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTypes: %w", err)
	}
	return oldValue.ResponseTypes, nil
}

// AppendResponseTypes adds s to the "response_types" field.
func (m *ApplicationMutation) AppendResponseTypes(s []string) {
	m.appendresponse_types = append(m.appendresponse_types, s...)
}

// AppendedResponseTypes returns the list of values that were appended to the "response_types" field in this mutation.
func (m *ApplicationMutation) AppendedResponseTypes() ([]string, bool) {
	if len(m.appendresponse_types) == 0 {
		return nil, false
	}
	return m.appendresponse_types, true
}

// ResetResponseTypes resets all changes to the "response_types" field.
func (m *ApplicationMutation) ResetResponseTypes() {
	m.response_types = nil
	m.appendresponse_types = nil
}

// SetGrantTypes sets the "grant_types" field.
func (m *ApplicationMutation) SetGrantTypes(s []string) {
	m.grant_types = &s
	m.appendgrant_types = nil
}

// GrantTypes returns the value of the "grant_types" field in the mutation.
func (m *ApplicationMutation) GrantTypes() (r []string, exists bool) {
	v := m.grant_types
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantTypes returns the old "grant_types" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldGrantTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantTypes: %w", err)
	}
	return oldValue.GrantTypes, nil
}

// AppendGrantTypes adds s to the "grant_types" field.
func (m *ApplicationMutation) AppendGrantTypes(s []string) {
	m.appendgrant_types = append(m.appendgrant_types, s...)
}

// AppendedGrantTypes returns the list of values that were appended to the "grant_types" field in this mutation.
func (m *ApplicationMutation) AppendedGrantTypes() ([]string, bool) {
	if len(m.appendgrant_types) == 0 {
		return nil, false
	}
	return m.appendgrant_types, true
}

// ResetGrantTypes resets all changes to the "grant_types" field.
func (m *ApplicationMutation) ResetGrantTypes() {
	m.grant_types = nil
	m.appendgrant_types = nil
}

// SetScopes sets the "scopes" field.
func (m *ApplicationMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *ApplicationMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *ApplicationMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *ApplicationMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *ApplicationMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetPkceRequired sets the "pkce_required" field.
func (m *ApplicationMutation) SetPkceRequired(b bool) {
	m.pkce_required = &b
}

// PkceRequired returns the value of the "pkce_required" field in the mutation.
func (m *ApplicationMutation) PkceRequired() (r bool, exists bool) {
	v := m.pkce_required
	if v == nil {
		return
	}
	return *v, true
}

// OldPkceRequired returns the old "pkce_required" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldPkceRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkceRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkceRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkceRequired: %w", err)
	}
	return oldValue.PkceRequired, nil
}

// ResetPkceRequired resets all changes to the "pkce_required" field.
func (m *ApplicationMutation) ResetPkceRequired() {
	m.pkce_required = nil
}

// SetS256CodeChallengeMethodRequired sets the "s256_code_challenge_method_required" field.
func (m *ApplicationMutation) SetS256CodeChallengeMethodRequired(b bool) {
	m.s256_code_challenge_method_required = &b
}

// S256CodeChallengeMethodRequired returns the value of the "s256_code_challenge_method_required" field in the mutation.
func (m *ApplicationMutation) S256CodeChallengeMethodRequired() (r bool, exists bool) {
	v := m.s256_code_challenge_method_required
	if v == nil {
		return
	}
	return *v, true
}

// OldS256CodeChallengeMethodRequired returns the old "s256_code_challenge_method_required" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldS256CodeChallengeMethodRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS256CodeChallengeMethodRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS256CodeChallengeMethodRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS256CodeChallengeMethodRequired: %w", err)
	}
	return oldValue.S256CodeChallengeMethodRequired, nil
}

// ResetS256CodeChallengeMethodRequired resets all changes to the "s256_code_challenge_method_required" field.
func (m *ApplicationMutation) ResetS256CodeChallengeMethodRequired() {
	m.s256_code_challenge_method_required = nil
}

// SetAllowedAuthenticationMethods sets the "allowed_authentication_methods" field.
func (m *ApplicationMutation) SetAllowedAuthenticationMethods(s []string) {
	m.allowed_authentication_methods = &s
	m.appendallowed_authentication_methods = nil
}

// AllowedAuthenticationMethods returns the value of the "allowed_authentication_methods" field in the mutation.
func (m *ApplicationMutation) AllowedAuthenticationMethods() (r []string, exists bool) {
	v := m.allowed_authentication_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedAuthenticationMethods returns the old "allowed_authentication_methods" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldAllowedAuthenticationMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedAuthenticationMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedAuthenticationMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedAuthenticationMethods: %w", err)
	}
	return oldValue.AllowedAuthenticationMethods, nil
}

// AppendAllowedAuthenticationMethods adds s to the "allowed_authentication_methods" field.
func (m *ApplicationMutation) AppendAllowedAuthenticationMethods(s []string) {
	m.appendallowed_authentication_methods = append(m.appendallowed_authentication_methods, s...)
}

// AppendedAllowedAuthenticationMethods returns the list of values that were appended to the "allowed_authentication_methods" field in this mutation.
func (m *ApplicationMutation) AppendedAllowedAuthenticationMethods() ([]string, bool) {
	if len(m.appendallowed_authentication_methods) == 0 {
		return nil, false
	}
	return m.appendallowed_authentication_methods, true
}

// ResetAllowedAuthenticationMethods resets all changes to the "allowed_authentication_methods" field.
func (m *ApplicationMutation) ResetAllowedAuthenticationMethods() {
	m.allowed_authentication_methods = nil
	m.appendallowed_authentication_methods = nil
}

// AddCredentialIDs adds the "credentials" edge to the Credentials entity by ids.
func (m *ApplicationMutation) AddCredentialIDs(ids ...string) {
	if m.credentials == nil {
		m.credentials = make(map[string]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credentials entity.
func (m *ApplicationMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credentials entity was cleared.
func (m *ApplicationMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credentials entity by IDs.
func (m *ApplicationMutation) RemoveCredentialIDs(ids ...string) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credentials entity.
func (m *ApplicationMutation) RemovedCredentialsIDs() (ids []string) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *ApplicationMutation) CredentialsIDs() (ids []string) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *ApplicationMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *ApplicationMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *ApplicationMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ApplicationMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *ApplicationMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ApplicationMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, application.FieldName)
	}
	if m.public != nil {
		fields = append(fields, application.FieldPublic)
	}
	if m.description != nil {
		fields = append(fields, application.FieldDescription)
	}
	if m.redirect_uris != nil {
		fields = append(fields, application.FieldRedirectUris)
	}
	if m.response_types != nil {
		fields = append(fields, application.FieldResponseTypes)
	}
	if m.grant_types != nil {
		fields = append(fields, application.FieldGrantTypes)
	}
	if m.scopes != nil {
		fields = append(fields, application.FieldScopes)
	}
	if m.pkce_required != nil {
		fields = append(fields, application.FieldPkceRequired)
	}
	if m.s256_code_challenge_method_required != nil {
		fields = append(fields, application.FieldS256CodeChallengeMethodRequired)
	}
	if m.allowed_authentication_methods != nil {
		fields = append(fields, application.FieldAllowedAuthenticationMethods)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldName:
		return m.Name()
	case application.FieldPublic:
		return m.Public()
	case application.FieldDescription:
		return m.Description()
	case application.FieldRedirectUris:
		return m.RedirectUris()
	case application.FieldResponseTypes:
		return m.ResponseTypes()
	case application.FieldGrantTypes:
		return m.GrantTypes()
	case application.FieldScopes:
		return m.Scopes()
	case application.FieldPkceRequired:
		return m.PkceRequired()
	case application.FieldS256CodeChallengeMethodRequired:
		return m.S256CodeChallengeMethodRequired()
	case application.FieldAllowedAuthenticationMethods:
		return m.AllowedAuthenticationMethods()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldName:
		return m.OldName(ctx)
	case application.FieldPublic:
		return m.OldPublic(ctx)
	case application.FieldDescription:
		return m.OldDescription(ctx)
	case application.FieldRedirectUris:
		return m.OldRedirectUris(ctx)
	case application.FieldResponseTypes:
		return m.OldResponseTypes(ctx)
	case application.FieldGrantTypes:
		return m.OldGrantTypes(ctx)
	case application.FieldScopes:
		return m.OldScopes(ctx)
	case application.FieldPkceRequired:
		return m.OldPkceRequired(ctx)
	case application.FieldS256CodeChallengeMethodRequired:
		return m.OldS256CodeChallengeMethodRequired(ctx)
	case application.FieldAllowedAuthenticationMethods:
		return m.OldAllowedAuthenticationMethods(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case application.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case application.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case application.FieldRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectUris(v)
		return nil
	case application.FieldResponseTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTypes(v)
		return nil
	case application.FieldGrantTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantTypes(v)
		return nil
	case application.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case application.FieldPkceRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkceRequired(v)
		return nil
	case application.FieldS256CodeChallengeMethodRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS256CodeChallengeMethodRequired(v)
		return nil
	case application.FieldAllowedAuthenticationMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedAuthenticationMethods(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldName:
		m.ResetName()
		return nil
	case application.FieldPublic:
		m.ResetPublic()
		return nil
	case application.FieldDescription:
		m.ResetDescription()
		return nil
	case application.FieldRedirectUris:
		m.ResetRedirectUris()
		return nil
	case application.FieldResponseTypes:
		m.ResetResponseTypes()
		return nil
	case application.FieldGrantTypes:
		m.ResetGrantTypes()
		return nil
	case application.FieldScopes:
		m.ResetScopes()
		return nil
	case application.FieldPkceRequired:
		m.ResetPkceRequired()
		return nil
	case application.FieldS256CodeChallengeMethodRequired:
		m.ResetS256CodeChallengeMethodRequired()
		return nil
	case application.FieldAllowedAuthenticationMethods:
		m.ResetAllowedAuthenticationMethods()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.credentials != nil {
		edges = append(edges, application.EdgeCredentials)
	}
	if m.service != nil {
		edges = append(edges, application.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcredentials != nil {
		edges = append(edges, application.EdgeCredentials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcredentials {
		edges = append(edges, application.EdgeCredentials)
	}
	if m.clearedservice {
		edges = append(edges, application.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeCredentials:
		return m.clearedcredentials
	case application.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case application.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// AuthorizationCodeMutation represents an operation that mutates the AuthorizationCode nodes in the graph.
type AuthorizationCodeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	client_name           *string
	code_challenge        *string
	code_challenge_method *string
	created_at            *time.Time
	auth_time             *time.Time
	redirect_uri          *string
	nonce                 *string
	server_name           *string
	state                 *string
	subject               *string
	granted_scopes        *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*AuthorizationCode, error)
	predicates            []predicate.AuthorizationCode
}

var _ ent.Mutation = (*AuthorizationCodeMutation)(nil)

// authorizationcodeOption allows management of the mutation configuration using functional options.
type authorizationcodeOption func(*AuthorizationCodeMutation)

// newAuthorizationCodeMutation creates new mutation for the AuthorizationCode entity.
func newAuthorizationCodeMutation(c config, op Op, opts ...authorizationcodeOption) *AuthorizationCodeMutation {
	m := &AuthorizationCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthorizationCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorizationCodeID sets the ID field of the mutation.
func withAuthorizationCodeID(id string) authorizationcodeOption {
	return func(m *AuthorizationCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthorizationCode
		)
		m.oldValue = func(ctx context.Context) (*AuthorizationCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthorizationCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthorizationCode sets the old AuthorizationCode of the mutation.
func withAuthorizationCode(node *AuthorizationCode) authorizationcodeOption {
	return func(m *AuthorizationCodeMutation) {
		m.oldValue = func(context.Context) (*AuthorizationCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorizationCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorizationCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthorizationCode entities.
func (m *AuthorizationCodeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorizationCodeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorizationCodeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthorizationCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientName sets the "client_name" field.
func (m *AuthorizationCodeMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *AuthorizationCodeMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *AuthorizationCodeMutation) ResetClientName() {
	m.client_name = nil
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *AuthorizationCodeMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *AuthorizationCodeMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *AuthorizationCodeMutation) ResetCodeChallenge() {
	m.code_challenge = nil
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *AuthorizationCodeMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *AuthorizationCodeMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *AuthorizationCodeMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthorizationCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthorizationCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthorizationCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAuthTime sets the "auth_time" field.
func (m *AuthorizationCodeMutation) SetAuthTime(t time.Time) {
	m.auth_time = &t
}

// AuthTime returns the value of the "auth_time" field in the mutation.
func (m *AuthorizationCodeMutation) AuthTime() (r time.Time, exists bool) {
	v := m.auth_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthTime returns the old "auth_time" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldAuthTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthTime: %w", err)
	}
	return oldValue.AuthTime, nil
}

// ResetAuthTime resets all changes to the "auth_time" field.
func (m *AuthorizationCodeMutation) ResetAuthTime() {
	m.auth_time = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AuthorizationCodeMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AuthorizationCodeMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AuthorizationCodeMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetNonce sets the "nonce" field.
func (m *AuthorizationCodeMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *AuthorizationCodeMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *AuthorizationCodeMutation) ResetNonce() {
	m.nonce = nil
}

// SetServerName sets the "server_name" field.
func (m *AuthorizationCodeMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *AuthorizationCodeMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ResetServerName resets all changes to the "server_name" field.
func (m *AuthorizationCodeMutation) ResetServerName() {
	m.server_name = nil
}

// SetState sets the "state" field.
func (m *AuthorizationCodeMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AuthorizationCodeMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AuthorizationCodeMutation) ResetState() {
	m.state = nil
}

// SetSubject sets the "subject" field.
func (m *AuthorizationCodeMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *AuthorizationCodeMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *AuthorizationCodeMutation) ResetSubject() {
	m.subject = nil
}

// SetGrantedScopes sets the "granted_scopes" field.
func (m *AuthorizationCodeMutation) SetGrantedScopes(s string) {
	m.granted_scopes = &s
}

// GrantedScopes returns the value of the "granted_scopes" field in the mutation.
func (m *AuthorizationCodeMutation) GrantedScopes() (r string, exists bool) {
	v := m.granted_scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedScopes returns the old "granted_scopes" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldGrantedScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedScopes: %w", err)
	}
	return oldValue.GrantedScopes, nil
}

// ResetGrantedScopes resets all changes to the "granted_scopes" field.
func (m *AuthorizationCodeMutation) ResetGrantedScopes() {
	m.granted_scopes = nil
}

// Where appends a list predicates to the AuthorizationCodeMutation builder.
func (m *AuthorizationCodeMutation) Where(ps ...predicate.AuthorizationCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthorizationCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthorizationCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthorizationCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthorizationCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthorizationCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthorizationCode).
func (m *AuthorizationCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorizationCodeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.client_name != nil {
		fields = append(fields, authorizationcode.FieldClientName)
	}
	if m.code_challenge != nil {
		fields = append(fields, authorizationcode.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, authorizationcode.FieldCodeChallengeMethod)
	}
	if m.created_at != nil {
		fields = append(fields, authorizationcode.FieldCreatedAt)
	}
	if m.auth_time != nil {
		fields = append(fields, authorizationcode.FieldAuthTime)
	}
	if m.redirect_uri != nil {
		fields = append(fields, authorizationcode.FieldRedirectURI)
	}
	if m.nonce != nil {
		fields = append(fields, authorizationcode.FieldNonce)
	}
	if m.server_name != nil {
		fields = append(fields, authorizationcode.FieldServerName)
	}
	if m.state != nil {
		fields = append(fields, authorizationcode.FieldState)
	}
	if m.subject != nil {
		fields = append(fields, authorizationcode.FieldSubject)
	}
	if m.granted_scopes != nil {
		fields = append(fields, authorizationcode.FieldGrantedScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorizationCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authorizationcode.FieldClientName:
		return m.ClientName()
	case authorizationcode.FieldCodeChallenge:
		return m.CodeChallenge()
	case authorizationcode.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	case authorizationcode.FieldCreatedAt:
		return m.CreatedAt()
	case authorizationcode.FieldAuthTime:
		return m.AuthTime()
	case authorizationcode.FieldRedirectURI:
		return m.RedirectURI()
	case authorizationcode.FieldNonce:
		return m.Nonce()
	case authorizationcode.FieldServerName:
		return m.ServerName()
	case authorizationcode.FieldState:
		return m.State()
	case authorizationcode.FieldSubject:
		return m.Subject()
	case authorizationcode.FieldGrantedScopes:
		return m.GrantedScopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorizationCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authorizationcode.FieldClientName:
		return m.OldClientName(ctx)
	case authorizationcode.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case authorizationcode.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	case authorizationcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authorizationcode.FieldAuthTime:
		return m.OldAuthTime(ctx)
	case authorizationcode.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case authorizationcode.FieldNonce:
		return m.OldNonce(ctx)
	case authorizationcode.FieldServerName:
		return m.OldServerName(ctx)
	case authorizationcode.FieldState:
		return m.OldState(ctx)
	case authorizationcode.FieldSubject:
		return m.OldSubject(ctx)
	case authorizationcode.FieldGrantedScopes:
		return m.OldGrantedScopes(ctx)
	}
	return nil, fmt.Errorf("unknown AuthorizationCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authorizationcode.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case authorizationcode.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case authorizationcode.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	case authorizationcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authorizationcode.FieldAuthTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthTime(v)
		return nil
	case authorizationcode.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case authorizationcode.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case authorizationcode.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	case authorizationcode.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case authorizationcode.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case authorizationcode.FieldGrantedScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedScopes(v)
		return nil
	}
	return fmt.Errorf("unknown AuthorizationCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorizationCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorizationCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthorizationCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorizationCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorizationCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorizationCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthorizationCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorizationCodeMutation) ResetField(name string) error {
	switch name {
	case authorizationcode.FieldClientName:
		m.ResetClientName()
		return nil
	case authorizationcode.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case authorizationcode.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	case authorizationcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authorizationcode.FieldAuthTime:
		m.ResetAuthTime()
		return nil
	case authorizationcode.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case authorizationcode.FieldNonce:
		m.ResetNonce()
		return nil
	case authorizationcode.FieldServerName:
		m.ResetServerName()
		return nil
	case authorizationcode.FieldState:
		m.ResetState()
		return nil
	case authorizationcode.FieldSubject:
		m.ResetSubject()
		return nil
	case authorizationcode.FieldGrantedScopes:
		m.ResetGrantedScopes()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorizationCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorizationCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorizationCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorizationCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorizationCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorizationCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorizationCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthorizationCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorizationCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthorizationCode edge %s", name)
}

// AuthorizationPayloadMutation represents an operation that mutates the AuthorizationPayload nodes in the graph.
type AuthorizationPayloadMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	code_challenge        *string
	code_challenge_method *string
	client_id             *string
	nonce                 *string
	redirect_uri          *string
	response_type         *string
	scope                 *string
	server_name           *string
	state                 *string
	response_mode         *string
	clearedFields         map[string]struct{}
	session               *string
	clearedsession        bool
	done                  bool
	oldValue              func(context.Context) (*AuthorizationPayload, error)
	predicates            []predicate.AuthorizationPayload
}

var _ ent.Mutation = (*AuthorizationPayloadMutation)(nil)

// authorizationpayloadOption allows management of the mutation configuration using functional options.
type authorizationpayloadOption func(*AuthorizationPayloadMutation)

// newAuthorizationPayloadMutation creates new mutation for the AuthorizationPayload entity.
func newAuthorizationPayloadMutation(c config, op Op, opts ...authorizationpayloadOption) *AuthorizationPayloadMutation {
	m := &AuthorizationPayloadMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthorizationPayload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorizationPayloadID sets the ID field of the mutation.
func withAuthorizationPayloadID(id string) authorizationpayloadOption {
	return func(m *AuthorizationPayloadMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthorizationPayload
		)
		m.oldValue = func(ctx context.Context) (*AuthorizationPayload, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthorizationPayload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthorizationPayload sets the old AuthorizationPayload of the mutation.
func withAuthorizationPayload(node *AuthorizationPayload) authorizationpayloadOption {
	return func(m *AuthorizationPayloadMutation) {
		m.oldValue = func(context.Context) (*AuthorizationPayload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorizationPayloadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorizationPayloadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthorizationPayload entities.
func (m *AuthorizationPayloadMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorizationPayloadMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorizationPayloadMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthorizationPayload.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *AuthorizationPayloadMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *AuthorizationPayloadMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *AuthorizationPayloadMutation) ResetCodeChallenge() {
	m.code_challenge = nil
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *AuthorizationPayloadMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *AuthorizationPayloadMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *AuthorizationPayloadMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
}

// SetClientID sets the "client_id" field.
func (m *AuthorizationPayloadMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuthorizationPayloadMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuthorizationPayloadMutation) ResetClientID() {
	m.client_id = nil
}

// SetNonce sets the "nonce" field.
func (m *AuthorizationPayloadMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *AuthorizationPayloadMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *AuthorizationPayloadMutation) ResetNonce() {
	m.nonce = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AuthorizationPayloadMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AuthorizationPayloadMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AuthorizationPayloadMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetResponseType sets the "response_type" field.
func (m *AuthorizationPayloadMutation) SetResponseType(s string) {
	m.response_type = &s
}

// ResponseType returns the value of the "response_type" field in the mutation.
func (m *AuthorizationPayloadMutation) ResponseType() (r string, exists bool) {
	v := m.response_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseType returns the old "response_type" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldResponseType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseType: %w", err)
	}
	return oldValue.ResponseType, nil
}

// ResetResponseType resets all changes to the "response_type" field.
func (m *AuthorizationPayloadMutation) ResetResponseType() {
	m.response_type = nil
}

// SetScope sets the "scope" field.
func (m *AuthorizationPayloadMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *AuthorizationPayloadMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *AuthorizationPayloadMutation) ResetScope() {
	m.scope = nil
}

// SetServerName sets the "server_name" field.
func (m *AuthorizationPayloadMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *AuthorizationPayloadMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ResetServerName resets all changes to the "server_name" field.
func (m *AuthorizationPayloadMutation) ResetServerName() {
	m.server_name = nil
}

// SetState sets the "state" field.
func (m *AuthorizationPayloadMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AuthorizationPayloadMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AuthorizationPayloadMutation) ResetState() {
	m.state = nil
}

// SetResponseMode sets the "response_mode" field.
func (m *AuthorizationPayloadMutation) SetResponseMode(s string) {
	m.response_mode = &s
}

// ResponseMode returns the value of the "response_mode" field in the mutation.
func (m *AuthorizationPayloadMutation) ResponseMode() (r string, exists bool) {
	v := m.response_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseMode returns the old "response_mode" field's value of the AuthorizationPayload entity.
// If the AuthorizationPayload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationPayloadMutation) OldResponseMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseMode: %w", err)
	}
	return oldValue.ResponseMode, nil
}

// ResetResponseMode resets all changes to the "response_mode" field.
func (m *AuthorizationPayloadMutation) ResetResponseMode() {
	m.response_mode = nil
}

// SetSessionID sets the "session" edge to the Session entity by id.
func (m *AuthorizationPayloadMutation) SetSessionID(id string) {
	m.session = &id
}

// ClearSession clears the "session" edge to the Session entity.
func (m *AuthorizationPayloadMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *AuthorizationPayloadMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *AuthorizationPayloadMutation) SessionID() (id string, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *AuthorizationPayloadMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *AuthorizationPayloadMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the AuthorizationPayloadMutation builder.
func (m *AuthorizationPayloadMutation) Where(ps ...predicate.AuthorizationPayload) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthorizationPayloadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthorizationPayloadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthorizationPayload, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthorizationPayloadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthorizationPayloadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthorizationPayload).
func (m *AuthorizationPayloadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorizationPayloadMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.code_challenge != nil {
		fields = append(fields, authorizationpayload.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, authorizationpayload.FieldCodeChallengeMethod)
	}
	if m.client_id != nil {
		fields = append(fields, authorizationpayload.FieldClientID)
	}
	if m.nonce != nil {
		fields = append(fields, authorizationpayload.FieldNonce)
	}
	if m.redirect_uri != nil {
		fields = append(fields, authorizationpayload.FieldRedirectURI)
	}
	if m.response_type != nil {
		fields = append(fields, authorizationpayload.FieldResponseType)
	}
	if m.scope != nil {
		fields = append(fields, authorizationpayload.FieldScope)
	}
	if m.server_name != nil {
		fields = append(fields, authorizationpayload.FieldServerName)
	}
	if m.state != nil {
		fields = append(fields, authorizationpayload.FieldState)
	}
	if m.response_mode != nil {
		fields = append(fields, authorizationpayload.FieldResponseMode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorizationPayloadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authorizationpayload.FieldCodeChallenge:
		return m.CodeChallenge()
	case authorizationpayload.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	case authorizationpayload.FieldClientID:
		return m.ClientID()
	case authorizationpayload.FieldNonce:
		return m.Nonce()
	case authorizationpayload.FieldRedirectURI:
		return m.RedirectURI()
	case authorizationpayload.FieldResponseType:
		return m.ResponseType()
	case authorizationpayload.FieldScope:
		return m.Scope()
	case authorizationpayload.FieldServerName:
		return m.ServerName()
	case authorizationpayload.FieldState:
		return m.State()
	case authorizationpayload.FieldResponseMode:
		return m.ResponseMode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorizationPayloadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authorizationpayload.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case authorizationpayload.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	case authorizationpayload.FieldClientID:
		return m.OldClientID(ctx)
	case authorizationpayload.FieldNonce:
		return m.OldNonce(ctx)
	case authorizationpayload.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case authorizationpayload.FieldResponseType:
		return m.OldResponseType(ctx)
	case authorizationpayload.FieldScope:
		return m.OldScope(ctx)
	case authorizationpayload.FieldServerName:
		return m.OldServerName(ctx)
	case authorizationpayload.FieldState:
		return m.OldState(ctx)
	case authorizationpayload.FieldResponseMode:
		return m.OldResponseMode(ctx)
	}
	return nil, fmt.Errorf("unknown AuthorizationPayload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationPayloadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authorizationpayload.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case authorizationpayload.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	case authorizationpayload.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case authorizationpayload.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case authorizationpayload.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case authorizationpayload.FieldResponseType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseType(v)
		return nil
	case authorizationpayload.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case authorizationpayload.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	case authorizationpayload.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case authorizationpayload.FieldResponseMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseMode(v)
		return nil
	}
	return fmt.Errorf("unknown AuthorizationPayload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorizationPayloadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorizationPayloadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationPayloadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthorizationPayload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorizationPayloadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorizationPayloadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorizationPayloadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthorizationPayload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorizationPayloadMutation) ResetField(name string) error {
	switch name {
	case authorizationpayload.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case authorizationpayload.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	case authorizationpayload.FieldClientID:
		m.ResetClientID()
		return nil
	case authorizationpayload.FieldNonce:
		m.ResetNonce()
		return nil
	case authorizationpayload.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case authorizationpayload.FieldResponseType:
		m.ResetResponseType()
		return nil
	case authorizationpayload.FieldScope:
		m.ResetScope()
		return nil
	case authorizationpayload.FieldServerName:
		m.ResetServerName()
		return nil
	case authorizationpayload.FieldState:
		m.ResetState()
		return nil
	case authorizationpayload.FieldResponseMode:
		m.ResetResponseMode()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationPayload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorizationPayloadMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, authorizationpayload.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorizationPayloadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authorizationpayload.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorizationPayloadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorizationPayloadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorizationPayloadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, authorizationpayload.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorizationPayloadMutation) EdgeCleared(name string) bool {
	switch name {
	case authorizationpayload.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorizationPayloadMutation) ClearEdge(name string) error {
	switch name {
	case authorizationpayload.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationPayload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorizationPayloadMutation) ResetEdge(name string) error {
	switch name {
	case authorizationpayload.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationPayload edge %s", name)
}

// CookieStoreMutation represents an operation that mutates the CookieStore nodes in the graph.
type CookieStoreMutation struct {
	config
	op             Op
	typ            string
	id             *string
	auth_key       *string
	encryption_key *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CookieStore, error)
	predicates     []predicate.CookieStore
}

var _ ent.Mutation = (*CookieStoreMutation)(nil)

// cookiestoreOption allows management of the mutation configuration using functional options.
type cookiestoreOption func(*CookieStoreMutation)

// newCookieStoreMutation creates new mutation for the CookieStore entity.
func newCookieStoreMutation(c config, op Op, opts ...cookiestoreOption) *CookieStoreMutation {
	m := &CookieStoreMutation{
		config:        c,
		op:            op,
		typ:           TypeCookieStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCookieStoreID sets the ID field of the mutation.
func withCookieStoreID(id string) cookiestoreOption {
	return func(m *CookieStoreMutation) {
		var (
			err   error
			once  sync.Once
			value *CookieStore
		)
		m.oldValue = func(ctx context.Context) (*CookieStore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CookieStore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCookieStore sets the old CookieStore of the mutation.
func withCookieStore(node *CookieStore) cookiestoreOption {
	return func(m *CookieStoreMutation) {
		m.oldValue = func(context.Context) (*CookieStore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CookieStoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CookieStoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CookieStore entities.
func (m *CookieStoreMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CookieStoreMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CookieStoreMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CookieStore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuthKey sets the "auth_key" field.
func (m *CookieStoreMutation) SetAuthKey(s string) {
	m.auth_key = &s
}

// AuthKey returns the value of the "auth_key" field in the mutation.
func (m *CookieStoreMutation) AuthKey() (r string, exists bool) {
	v := m.auth_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthKey returns the old "auth_key" field's value of the CookieStore entity.
// If the CookieStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CookieStoreMutation) OldAuthKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthKey: %w", err)
	}
	return oldValue.AuthKey, nil
}

// ResetAuthKey resets all changes to the "auth_key" field.
func (m *CookieStoreMutation) ResetAuthKey() {
	m.auth_key = nil
}

// SetEncryptionKey sets the "encryption_key" field.
func (m *CookieStoreMutation) SetEncryptionKey(s string) {
	m.encryption_key = &s
}

// EncryptionKey returns the value of the "encryption_key" field in the mutation.
func (m *CookieStoreMutation) EncryptionKey() (r string, exists bool) {
	v := m.encryption_key
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptionKey returns the old "encryption_key" field's value of the CookieStore entity.
// If the CookieStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CookieStoreMutation) OldEncryptionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptionKey: %w", err)
	}
	return oldValue.EncryptionKey, nil
}

// ResetEncryptionKey resets all changes to the "encryption_key" field.
func (m *CookieStoreMutation) ResetEncryptionKey() {
	m.encryption_key = nil
}

// Where appends a list predicates to the CookieStoreMutation builder.
func (m *CookieStoreMutation) Where(ps ...predicate.CookieStore) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CookieStoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CookieStoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CookieStore, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CookieStoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CookieStoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CookieStore).
func (m *CookieStoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CookieStoreMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.auth_key != nil {
		fields = append(fields, cookiestore.FieldAuthKey)
	}
	if m.encryption_key != nil {
		fields = append(fields, cookiestore.FieldEncryptionKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CookieStoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cookiestore.FieldAuthKey:
		return m.AuthKey()
	case cookiestore.FieldEncryptionKey:
		return m.EncryptionKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CookieStoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cookiestore.FieldAuthKey:
		return m.OldAuthKey(ctx)
	case cookiestore.FieldEncryptionKey:
		return m.OldEncryptionKey(ctx)
	}
	return nil, fmt.Errorf("unknown CookieStore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CookieStoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cookiestore.FieldAuthKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthKey(v)
		return nil
	case cookiestore.FieldEncryptionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptionKey(v)
		return nil
	}
	return fmt.Errorf("unknown CookieStore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CookieStoreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CookieStoreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CookieStoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CookieStore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CookieStoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CookieStoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CookieStoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CookieStore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CookieStoreMutation) ResetField(name string) error {
	switch name {
	case cookiestore.FieldAuthKey:
		m.ResetAuthKey()
		return nil
	case cookiestore.FieldEncryptionKey:
		m.ResetEncryptionKey()
		return nil
	}
	return fmt.Errorf("unknown CookieStore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CookieStoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CookieStoreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CookieStoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CookieStoreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CookieStoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CookieStoreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CookieStoreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CookieStore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CookieStoreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CookieStore edge %s", name)
}

// CredentialsMutation represents an operation that mutates the Credentials nodes in the graph.
type CredentialsMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	client_id          *string
	client_secret      *string
	clearedFields      map[string]struct{}
	application        *string
	clearedapplication bool
	done               bool
	oldValue           func(context.Context) (*Credentials, error)
	predicates         []predicate.Credentials
}

var _ ent.Mutation = (*CredentialsMutation)(nil)

// credentialsOption allows management of the mutation configuration using functional options.
type credentialsOption func(*CredentialsMutation)

// newCredentialsMutation creates new mutation for the Credentials entity.
func newCredentialsMutation(c config, op Op, opts ...credentialsOption) *CredentialsMutation {
	m := &CredentialsMutation{
		config:        c,
		op:            op,
		typ:           TypeCredentials,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialsID sets the ID field of the mutation.
func withCredentialsID(id string) credentialsOption {
	return func(m *CredentialsMutation) {
		var (
			err   error
			once  sync.Once
			value *Credentials
		)
		m.oldValue = func(ctx context.Context) (*Credentials, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credentials.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredentials sets the old Credentials of the mutation.
func withCredentials(node *Credentials) credentialsOption {
	return func(m *CredentialsMutation) {
		m.oldValue = func(context.Context) (*Credentials, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Credentials entities.
func (m *CredentialsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credentials.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *CredentialsMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *CredentialsMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Credentials entity.
// If the Credentials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialsMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *CredentialsMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *CredentialsMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *CredentialsMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the Credentials entity.
// If the Credentials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialsMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *CredentialsMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetApplicationID sets the "application" edge to the Application entity by id.
func (m *CredentialsMutation) SetApplicationID(id string) {
	m.application = &id
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *CredentialsMutation) ClearApplication() {
	m.clearedapplication = true
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *CredentialsMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationID returns the "application" edge ID in the mutation.
func (m *CredentialsMutation) ApplicationID() (id string, exists bool) {
	if m.application != nil {
		return *m.application, true
	}
	return
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *CredentialsMutation) ApplicationIDs() (ids []string) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *CredentialsMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// Where appends a list predicates to the CredentialsMutation builder.
func (m *CredentialsMutation) Where(ps ...predicate.Credentials) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credentials, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credentials).
func (m *CredentialsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.client_id != nil {
		fields = append(fields, credentials.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, credentials.FieldClientSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credentials.FieldClientID:
		return m.ClientID()
	case credentials.FieldClientSecret:
		return m.ClientSecret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credentials.FieldClientID:
		return m.OldClientID(ctx)
	case credentials.FieldClientSecret:
		return m.OldClientSecret(ctx)
	}
	return nil, fmt.Errorf("unknown Credentials field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credentials.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case credentials.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	}
	return fmt.Errorf("unknown Credentials field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credentials numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Credentials nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialsMutation) ResetField(name string) error {
	switch name {
	case credentials.FieldClientID:
		m.ResetClientID()
		return nil
	case credentials.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	}
	return fmt.Errorf("unknown Credentials field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.application != nil {
		edges = append(edges, credentials.EdgeApplication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credentials.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapplication {
		edges = append(edges, credentials.EdgeApplication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialsMutation) EdgeCleared(name string) bool {
	switch name {
	case credentials.EdgeApplication:
		return m.clearedapplication
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialsMutation) ClearEdge(name string) error {
	switch name {
	case credentials.EdgeApplication:
		m.ClearApplication()
		return nil
	}
	return fmt.Errorf("unknown Credentials unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialsMutation) ResetEdge(name string) error {
	switch name {
	case credentials.EdgeApplication:
		m.ResetApplication()
		return nil
	}
	return fmt.Errorf("unknown Credentials edge %s", name)
}

// KeySetMutation represents an operation that mutates the KeySet nodes in the graph.
type KeySetMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	clearedFields       map[string]struct{}
	service             *string
	clearedservice      bool
	signing_keys        map[string]struct{}
	removedsigning_keys map[string]struct{}
	clearedsigning_keys bool
	done                bool
	oldValue            func(context.Context) (*KeySet, error)
	predicates          []predicate.KeySet
}

var _ ent.Mutation = (*KeySetMutation)(nil)

// keysetOption allows management of the mutation configuration using functional options.
type keysetOption func(*KeySetMutation)

// newKeySetMutation creates new mutation for the KeySet entity.
func newKeySetMutation(c config, op Op, opts ...keysetOption) *KeySetMutation {
	m := &KeySetMutation{
		config:        c,
		op:            op,
		typ:           TypeKeySet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeySetID sets the ID field of the mutation.
func withKeySetID(id string) keysetOption {
	return func(m *KeySetMutation) {
		var (
			err   error
			once  sync.Once
			value *KeySet
		)
		m.oldValue = func(ctx context.Context) (*KeySet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KeySet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeySet sets the old KeySet of the mutation.
func withKeySet(node *KeySet) keysetOption {
	return func(m *KeySetMutation) {
		m.oldValue = func(context.Context) (*KeySet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeySetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeySetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KeySet entities.
func (m *KeySetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeySetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeySetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KeySet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *KeySetMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *KeySetMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *KeySetMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *KeySetMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *KeySetMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *KeySetMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// AddSigningKeyIDs adds the "signing_keys" edge to the SigningKey entity by ids.
func (m *KeySetMutation) AddSigningKeyIDs(ids ...string) {
	if m.signing_keys == nil {
		m.signing_keys = make(map[string]struct{})
	}
	for i := range ids {
		m.signing_keys[ids[i]] = struct{}{}
	}
}

// ClearSigningKeys clears the "signing_keys" edge to the SigningKey entity.
func (m *KeySetMutation) ClearSigningKeys() {
	m.clearedsigning_keys = true
}

// SigningKeysCleared reports if the "signing_keys" edge to the SigningKey entity was cleared.
func (m *KeySetMutation) SigningKeysCleared() bool {
	return m.clearedsigning_keys
}

// RemoveSigningKeyIDs removes the "signing_keys" edge to the SigningKey entity by IDs.
func (m *KeySetMutation) RemoveSigningKeyIDs(ids ...string) {
	if m.removedsigning_keys == nil {
		m.removedsigning_keys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.signing_keys, ids[i])
		m.removedsigning_keys[ids[i]] = struct{}{}
	}
}

// RemovedSigningKeys returns the removed IDs of the "signing_keys" edge to the SigningKey entity.
func (m *KeySetMutation) RemovedSigningKeysIDs() (ids []string) {
	for id := range m.removedsigning_keys {
		ids = append(ids, id)
	}
	return
}

// SigningKeysIDs returns the "signing_keys" edge IDs in the mutation.
func (m *KeySetMutation) SigningKeysIDs() (ids []string) {
	for id := range m.signing_keys {
		ids = append(ids, id)
	}
	return
}

// ResetSigningKeys resets all changes to the "signing_keys" edge.
func (m *KeySetMutation) ResetSigningKeys() {
	m.signing_keys = nil
	m.clearedsigning_keys = false
	m.removedsigning_keys = nil
}

// Where appends a list predicates to the KeySetMutation builder.
func (m *KeySetMutation) Where(ps ...predicate.KeySet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KeySetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KeySetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.KeySet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KeySetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KeySetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (KeySet).
func (m *KeySetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeySetMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeySetMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeySetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown KeySet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeySetMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KeySet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeySetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeySetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeySetMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown KeySet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeySetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeySetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeySetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KeySet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeySetMutation) ResetField(name string) error {
	return fmt.Errorf("unknown KeySet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeySetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.service != nil {
		edges = append(edges, keyset.EdgeService)
	}
	if m.signing_keys != nil {
		edges = append(edges, keyset.EdgeSigningKeys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeySetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case keyset.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case keyset.EdgeSigningKeys:
		ids := make([]ent.Value, 0, len(m.signing_keys))
		for id := range m.signing_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeySetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsigning_keys != nil {
		edges = append(edges, keyset.EdgeSigningKeys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeySetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case keyset.EdgeSigningKeys:
		ids := make([]ent.Value, 0, len(m.removedsigning_keys))
		for id := range m.removedsigning_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeySetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedservice {
		edges = append(edges, keyset.EdgeService)
	}
	if m.clearedsigning_keys {
		edges = append(edges, keyset.EdgeSigningKeys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeySetMutation) EdgeCleared(name string) bool {
	switch name {
	case keyset.EdgeService:
		return m.clearedservice
	case keyset.EdgeSigningKeys:
		return m.clearedsigning_keys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeySetMutation) ClearEdge(name string) error {
	switch name {
	case keyset.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown KeySet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeySetMutation) ResetEdge(name string) error {
	switch name {
	case keyset.EdgeService:
		m.ResetService()
		return nil
	case keyset.EdgeSigningKeys:
		m.ResetSigningKeys()
		return nil
	}
	return fmt.Errorf("unknown KeySet edge %s", name)
}

// RefreshTokenMutation represents an operation that mutates the RefreshToken nodes in the graph.
type RefreshTokenMutation struct {
	config
	op              Op
	typ             string
	id              *string
	client_name     *string
	server_name     *string
	scopes          *string
	created_at      *int64
	addcreated_at   *int64
	access_token_id *string
	lifetime        *int64
	addlifetime     *int64
	subject         *string
	key_id          *string
	auth_time       *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*RefreshToken, error)
	predicates      []predicate.RefreshToken
}

var _ ent.Mutation = (*RefreshTokenMutation)(nil)

// refreshtokenOption allows management of the mutation configuration using functional options.
type refreshtokenOption func(*RefreshTokenMutation)

// newRefreshTokenMutation creates new mutation for the RefreshToken entity.
func newRefreshTokenMutation(c config, op Op, opts ...refreshtokenOption) *RefreshTokenMutation {
	m := &RefreshTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeRefreshToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRefreshTokenID sets the ID field of the mutation.
func withRefreshTokenID(id string) refreshtokenOption {
	return func(m *RefreshTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *RefreshToken
		)
		m.oldValue = func(ctx context.Context) (*RefreshToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RefreshToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRefreshToken sets the old RefreshToken of the mutation.
func withRefreshToken(node *RefreshToken) refreshtokenOption {
	return func(m *RefreshTokenMutation) {
		m.oldValue = func(context.Context) (*RefreshToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RefreshTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RefreshTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RefreshToken entities.
func (m *RefreshTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RefreshTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RefreshTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RefreshToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientName sets the "client_name" field.
func (m *RefreshTokenMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *RefreshTokenMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *RefreshTokenMutation) ResetClientName() {
	m.client_name = nil
}

// SetServerName sets the "server_name" field.
func (m *RefreshTokenMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *RefreshTokenMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ResetServerName resets all changes to the "server_name" field.
func (m *RefreshTokenMutation) ResetServerName() {
	m.server_name = nil
}

// SetScopes sets the "scopes" field.
func (m *RefreshTokenMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *RefreshTokenMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ResetScopes resets all changes to the "scopes" field.
func (m *RefreshTokenMutation) ResetScopes() {
	m.scopes = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RefreshTokenMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RefreshTokenMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *RefreshTokenMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RefreshTokenMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RefreshTokenMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetAccessTokenID sets the "access_token_id" field.
func (m *RefreshTokenMutation) SetAccessTokenID(s string) {
	m.access_token_id = &s
}

// AccessTokenID returns the value of the "access_token_id" field in the mutation.
func (m *RefreshTokenMutation) AccessTokenID() (r string, exists bool) {
	v := m.access_token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessTokenID returns the old "access_token_id" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldAccessTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessTokenID: %w", err)
	}
	return oldValue.AccessTokenID, nil
}

// ResetAccessTokenID resets all changes to the "access_token_id" field.
func (m *RefreshTokenMutation) ResetAccessTokenID() {
	m.access_token_id = nil
}

// SetLifetime sets the "lifetime" field.
func (m *RefreshTokenMutation) SetLifetime(i int64) {
	m.lifetime = &i
	m.addlifetime = nil
}

// Lifetime returns the value of the "lifetime" field in the mutation.
func (m *RefreshTokenMutation) Lifetime() (r int64, exists bool) {
	v := m.lifetime
	if v == nil {
		return
	}
	return *v, true
}

// OldLifetime returns the old "lifetime" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldLifetime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifetime: %w", err)
	}
	return oldValue.Lifetime, nil
}

// AddLifetime adds i to the "lifetime" field.
func (m *RefreshTokenMutation) AddLifetime(i int64) {
	if m.addlifetime != nil {
		*m.addlifetime += i
	} else {
		m.addlifetime = &i
	}
}

// AddedLifetime returns the value that was added to the "lifetime" field in this mutation.
func (m *RefreshTokenMutation) AddedLifetime() (r int64, exists bool) {
	v := m.addlifetime
	if v == nil {
		return
	}
	return *v, true
}

// ResetLifetime resets all changes to the "lifetime" field.
func (m *RefreshTokenMutation) ResetLifetime() {
	m.lifetime = nil
	m.addlifetime = nil
}

// SetSubject sets the "subject" field.
func (m *RefreshTokenMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *RefreshTokenMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *RefreshTokenMutation) ResetSubject() {
	m.subject = nil
}

// SetKeyID sets the "key_id" field.
func (m *RefreshTokenMutation) SetKeyID(s string) {
	m.key_id = &s
}

// KeyID returns the value of the "key_id" field in the mutation.
func (m *RefreshTokenMutation) KeyID() (r string, exists bool) {
	v := m.key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyID returns the old "key_id" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyID: %w", err)
	}
	return oldValue.KeyID, nil
}

// ResetKeyID resets all changes to the "key_id" field.
func (m *RefreshTokenMutation) ResetKeyID() {
	m.key_id = nil
}

// SetAuthTime sets the "auth_time" field.
func (m *RefreshTokenMutation) SetAuthTime(t time.Time) {
	m.auth_time = &t
}

// AuthTime returns the value of the "auth_time" field in the mutation.
func (m *RefreshTokenMutation) AuthTime() (r time.Time, exists bool) {
	v := m.auth_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthTime returns the old "auth_time" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldAuthTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthTime: %w", err)
	}
	return oldValue.AuthTime, nil
}

// ResetAuthTime resets all changes to the "auth_time" field.
func (m *RefreshTokenMutation) ResetAuthTime() {
	m.auth_time = nil
}

// Where appends a list predicates to the RefreshTokenMutation builder.
func (m *RefreshTokenMutation) Where(ps ...predicate.RefreshToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RefreshTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RefreshTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RefreshToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RefreshTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RefreshTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RefreshToken).
func (m *RefreshTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RefreshTokenMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.client_name != nil {
		fields = append(fields, refreshtoken.FieldClientName)
	}
	if m.server_name != nil {
		fields = append(fields, refreshtoken.FieldServerName)
	}
	if m.scopes != nil {
		fields = append(fields, refreshtoken.FieldScopes)
	}
	if m.created_at != nil {
		fields = append(fields, refreshtoken.FieldCreatedAt)
	}
	if m.access_token_id != nil {
		fields = append(fields, refreshtoken.FieldAccessTokenID)
	}
	if m.lifetime != nil {
		fields = append(fields, refreshtoken.FieldLifetime)
	}
	if m.subject != nil {
		fields = append(fields, refreshtoken.FieldSubject)
	}
	if m.key_id != nil {
		fields = append(fields, refreshtoken.FieldKeyID)
	}
	if m.auth_time != nil {
		fields = append(fields, refreshtoken.FieldAuthTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RefreshTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case refreshtoken.FieldClientName:
		return m.ClientName()
	case refreshtoken.FieldServerName:
		return m.ServerName()
	case refreshtoken.FieldScopes:
		return m.Scopes()
	case refreshtoken.FieldCreatedAt:
		return m.CreatedAt()
	case refreshtoken.FieldAccessTokenID:
		return m.AccessTokenID()
	case refreshtoken.FieldLifetime:
		return m.Lifetime()
	case refreshtoken.FieldSubject:
		return m.Subject()
	case refreshtoken.FieldKeyID:
		return m.KeyID()
	case refreshtoken.FieldAuthTime:
		return m.AuthTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RefreshTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case refreshtoken.FieldClientName:
		return m.OldClientName(ctx)
	case refreshtoken.FieldServerName:
		return m.OldServerName(ctx)
	case refreshtoken.FieldScopes:
		return m.OldScopes(ctx)
	case refreshtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case refreshtoken.FieldAccessTokenID:
		return m.OldAccessTokenID(ctx)
	case refreshtoken.FieldLifetime:
		return m.OldLifetime(ctx)
	case refreshtoken.FieldSubject:
		return m.OldSubject(ctx)
	case refreshtoken.FieldKeyID:
		return m.OldKeyID(ctx)
	case refreshtoken.FieldAuthTime:
		return m.OldAuthTime(ctx)
	}
	return nil, fmt.Errorf("unknown RefreshToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefreshTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case refreshtoken.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case refreshtoken.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	case refreshtoken.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case refreshtoken.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case refreshtoken.FieldAccessTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessTokenID(v)
		return nil
	case refreshtoken.FieldLifetime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifetime(v)
		return nil
	case refreshtoken.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case refreshtoken.FieldKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyID(v)
		return nil
	case refreshtoken.FieldAuthTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthTime(v)
		return nil
	}
	return fmt.Errorf("unknown RefreshToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RefreshTokenMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, refreshtoken.FieldCreatedAt)
	}
	if m.addlifetime != nil {
		fields = append(fields, refreshtoken.FieldLifetime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RefreshTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case refreshtoken.FieldCreatedAt:
		return m.AddedCreatedAt()
	case refreshtoken.FieldLifetime:
		return m.AddedLifetime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefreshTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case refreshtoken.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case refreshtoken.FieldLifetime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLifetime(v)
		return nil
	}
	return fmt.Errorf("unknown RefreshToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RefreshTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RefreshTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RefreshTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RefreshToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RefreshTokenMutation) ResetField(name string) error {
	switch name {
	case refreshtoken.FieldClientName:
		m.ResetClientName()
		return nil
	case refreshtoken.FieldServerName:
		m.ResetServerName()
		return nil
	case refreshtoken.FieldScopes:
		m.ResetScopes()
		return nil
	case refreshtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case refreshtoken.FieldAccessTokenID:
		m.ResetAccessTokenID()
		return nil
	case refreshtoken.FieldLifetime:
		m.ResetLifetime()
		return nil
	case refreshtoken.FieldSubject:
		m.ResetSubject()
		return nil
	case refreshtoken.FieldKeyID:
		m.ResetKeyID()
		return nil
	case refreshtoken.FieldAuthTime:
		m.ResetAuthTime()
		return nil
	}
	return fmt.Errorf("unknown RefreshToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RefreshTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RefreshTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RefreshTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RefreshTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RefreshTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RefreshTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RefreshTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RefreshToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RefreshTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RefreshToken edge %s", name)
}

// ServiceMutation represents an operation that mutates the Service nodes in the graph.
type ServiceMutation struct {
	config
	op                                           Op
	typ                                          string
	id                                           *string
	name                                         *string
	issuer                                       *string
	description                                  *string
	scopes                                       *[]string
	appendscopes                                 []string
	service_metadata                             *string
	allowed_client_metadata                      *[]string
	appendallowed_client_metadata                []string
	grant_types                                  *[]string
	appendgrant_types                            []string
	response_types                               *[]string
	appendresponse_types                         []string
	clearedFields                                map[string]struct{}
	key_set                                      *string
	clearedkey_set                               bool
	service_authorization_endpoint_config        *string
	clearedservice_authorization_endpoint_config bool
	service_introspection_endpoint_config        *string
	clearedservice_introspection_endpoint_config bool
	service_token_endpoint_config                *string
	clearedservice_token_endpoint_config         bool
	service_user_info_endpoint_config            *string
	clearedservice_user_info_endpoint_config     bool
	service_jwks_endpoint_config                 *string
	clearedservice_jwks_endpoint_config          bool
	service_well_known_endpoint_config           *string
	clearedservice_well_known_endpoint_config    bool
	applications                                 map[string]struct{}
	removedapplications                          map[string]struct{}
	clearedapplications                          bool
	done                                         bool
	oldValue                                     func(context.Context) (*Service, error)
	predicates                                   []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows management of the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for the Service entity.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the ID field of the mutation.
func withServiceID(id string) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Service entities.
func (m *ServiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Service.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetIssuer sets the "issuer" field.
func (m *ServiceMutation) SetIssuer(s string) {
	m.issuer = &s
}

// Issuer returns the value of the "issuer" field in the mutation.
func (m *ServiceMutation) Issuer() (r string, exists bool) {
	v := m.issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old "issuer" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ResetIssuer resets all changes to the "issuer" field.
func (m *ServiceMutation) ResetIssuer() {
	m.issuer = nil
}

// SetDescription sets the "description" field.
func (m *ServiceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceMutation) ResetDescription() {
	m.description = nil
}

// SetScopes sets the "scopes" field.
func (m *ServiceMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *ServiceMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *ServiceMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *ServiceMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *ServiceMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetServiceMetadata sets the "service_metadata" field.
func (m *ServiceMutation) SetServiceMetadata(s string) {
	m.service_metadata = &s
}

// ServiceMetadata returns the value of the "service_metadata" field in the mutation.
func (m *ServiceMutation) ServiceMetadata() (r string, exists bool) {
	v := m.service_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceMetadata returns the old "service_metadata" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldServiceMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceMetadata: %w", err)
	}
	return oldValue.ServiceMetadata, nil
}

// ResetServiceMetadata resets all changes to the "service_metadata" field.
func (m *ServiceMutation) ResetServiceMetadata() {
	m.service_metadata = nil
}

// SetAllowedClientMetadata sets the "allowed_client_metadata" field.
func (m *ServiceMutation) SetAllowedClientMetadata(s []string) {
	m.allowed_client_metadata = &s
	m.appendallowed_client_metadata = nil
}

// AllowedClientMetadata returns the value of the "allowed_client_metadata" field in the mutation.
func (m *ServiceMutation) AllowedClientMetadata() (r []string, exists bool) {
	v := m.allowed_client_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedClientMetadata returns the old "allowed_client_metadata" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldAllowedClientMetadata(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedClientMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedClientMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedClientMetadata: %w", err)
	}
	return oldValue.AllowedClientMetadata, nil
}

// AppendAllowedClientMetadata adds s to the "allowed_client_metadata" field.
func (m *ServiceMutation) AppendAllowedClientMetadata(s []string) {
	m.appendallowed_client_metadata = append(m.appendallowed_client_metadata, s...)
}

// AppendedAllowedClientMetadata returns the list of values that were appended to the "allowed_client_metadata" field in this mutation.
func (m *ServiceMutation) AppendedAllowedClientMetadata() ([]string, bool) {
	if len(m.appendallowed_client_metadata) == 0 {
		return nil, false
	}
	return m.appendallowed_client_metadata, true
}

// ResetAllowedClientMetadata resets all changes to the "allowed_client_metadata" field.
func (m *ServiceMutation) ResetAllowedClientMetadata() {
	m.allowed_client_metadata = nil
	m.appendallowed_client_metadata = nil
}

// SetGrantTypes sets the "grant_types" field.
func (m *ServiceMutation) SetGrantTypes(s []string) {
	m.grant_types = &s
	m.appendgrant_types = nil
}

// GrantTypes returns the value of the "grant_types" field in the mutation.
func (m *ServiceMutation) GrantTypes() (r []string, exists bool) {
	v := m.grant_types
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantTypes returns the old "grant_types" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldGrantTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantTypes: %w", err)
	}
	return oldValue.GrantTypes, nil
}

// AppendGrantTypes adds s to the "grant_types" field.
func (m *ServiceMutation) AppendGrantTypes(s []string) {
	m.appendgrant_types = append(m.appendgrant_types, s...)
}

// AppendedGrantTypes returns the list of values that were appended to the "grant_types" field in this mutation.
func (m *ServiceMutation) AppendedGrantTypes() ([]string, bool) {
	if len(m.appendgrant_types) == 0 {
		return nil, false
	}
	return m.appendgrant_types, true
}

// ResetGrantTypes resets all changes to the "grant_types" field.
func (m *ServiceMutation) ResetGrantTypes() {
	m.grant_types = nil
	m.appendgrant_types = nil
}

// SetResponseTypes sets the "response_types" field.
func (m *ServiceMutation) SetResponseTypes(s []string) {
	m.response_types = &s
	m.appendresponse_types = nil
}

// ResponseTypes returns the value of the "response_types" field in the mutation.
func (m *ServiceMutation) ResponseTypes() (r []string, exists bool) {
	v := m.response_types
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTypes returns the old "response_types" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldResponseTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTypes: %w", err)
	}
	return oldValue.ResponseTypes, nil
}

// AppendResponseTypes adds s to the "response_types" field.
func (m *ServiceMutation) AppendResponseTypes(s []string) {
	m.appendresponse_types = append(m.appendresponse_types, s...)
}

// AppendedResponseTypes returns the list of values that were appended to the "response_types" field in this mutation.
func (m *ServiceMutation) AppendedResponseTypes() ([]string, bool) {
	if len(m.appendresponse_types) == 0 {
		return nil, false
	}
	return m.appendresponse_types, true
}

// ResetResponseTypes resets all changes to the "response_types" field.
func (m *ServiceMutation) ResetResponseTypes() {
	m.response_types = nil
	m.appendresponse_types = nil
}

// SetKeySetID sets the "key_set" edge to the KeySet entity by id.
func (m *ServiceMutation) SetKeySetID(id string) {
	m.key_set = &id
}

// ClearKeySet clears the "key_set" edge to the KeySet entity.
func (m *ServiceMutation) ClearKeySet() {
	m.clearedkey_set = true
}

// KeySetCleared reports if the "key_set" edge to the KeySet entity was cleared.
func (m *ServiceMutation) KeySetCleared() bool {
	return m.clearedkey_set
}

// KeySetID returns the "key_set" edge ID in the mutation.
func (m *ServiceMutation) KeySetID() (id string, exists bool) {
	if m.key_set != nil {
		return *m.key_set, true
	}
	return
}

// KeySetIDs returns the "key_set" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeySetID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) KeySetIDs() (ids []string) {
	if id := m.key_set; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeySet resets all changes to the "key_set" edge.
func (m *ServiceMutation) ResetKeySet() {
	m.key_set = nil
	m.clearedkey_set = false
}

// SetServiceAuthorizationEndpointConfigID sets the "service_authorization_endpoint_config" edge to the ServiceAuthorizationEndpointConfig entity by id.
func (m *ServiceMutation) SetServiceAuthorizationEndpointConfigID(id string) {
	m.service_authorization_endpoint_config = &id
}

// ClearServiceAuthorizationEndpointConfig clears the "service_authorization_endpoint_config" edge to the ServiceAuthorizationEndpointConfig entity.
func (m *ServiceMutation) ClearServiceAuthorizationEndpointConfig() {
	m.clearedservice_authorization_endpoint_config = true
}

// ServiceAuthorizationEndpointConfigCleared reports if the "service_authorization_endpoint_config" edge to the ServiceAuthorizationEndpointConfig entity was cleared.
func (m *ServiceMutation) ServiceAuthorizationEndpointConfigCleared() bool {
	return m.clearedservice_authorization_endpoint_config
}

// ServiceAuthorizationEndpointConfigID returns the "service_authorization_endpoint_config" edge ID in the mutation.
func (m *ServiceMutation) ServiceAuthorizationEndpointConfigID() (id string, exists bool) {
	if m.service_authorization_endpoint_config != nil {
		return *m.service_authorization_endpoint_config, true
	}
	return
}

// ServiceAuthorizationEndpointConfigIDs returns the "service_authorization_endpoint_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceAuthorizationEndpointConfigID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ServiceAuthorizationEndpointConfigIDs() (ids []string) {
	if id := m.service_authorization_endpoint_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceAuthorizationEndpointConfig resets all changes to the "service_authorization_endpoint_config" edge.
func (m *ServiceMutation) ResetServiceAuthorizationEndpointConfig() {
	m.service_authorization_endpoint_config = nil
	m.clearedservice_authorization_endpoint_config = false
}

// SetServiceIntrospectionEndpointConfigID sets the "service_introspection_endpoint_config" edge to the ServiceIntrospectionEndpointConfig entity by id.
func (m *ServiceMutation) SetServiceIntrospectionEndpointConfigID(id string) {
	m.service_introspection_endpoint_config = &id
}

// ClearServiceIntrospectionEndpointConfig clears the "service_introspection_endpoint_config" edge to the ServiceIntrospectionEndpointConfig entity.
func (m *ServiceMutation) ClearServiceIntrospectionEndpointConfig() {
	m.clearedservice_introspection_endpoint_config = true
}

// ServiceIntrospectionEndpointConfigCleared reports if the "service_introspection_endpoint_config" edge to the ServiceIntrospectionEndpointConfig entity was cleared.
func (m *ServiceMutation) ServiceIntrospectionEndpointConfigCleared() bool {
	return m.clearedservice_introspection_endpoint_config
}

// ServiceIntrospectionEndpointConfigID returns the "service_introspection_endpoint_config" edge ID in the mutation.
func (m *ServiceMutation) ServiceIntrospectionEndpointConfigID() (id string, exists bool) {
	if m.service_introspection_endpoint_config != nil {
		return *m.service_introspection_endpoint_config, true
	}
	return
}

// ServiceIntrospectionEndpointConfigIDs returns the "service_introspection_endpoint_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceIntrospectionEndpointConfigID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ServiceIntrospectionEndpointConfigIDs() (ids []string) {
	if id := m.service_introspection_endpoint_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceIntrospectionEndpointConfig resets all changes to the "service_introspection_endpoint_config" edge.
func (m *ServiceMutation) ResetServiceIntrospectionEndpointConfig() {
	m.service_introspection_endpoint_config = nil
	m.clearedservice_introspection_endpoint_config = false
}

// SetServiceTokenEndpointConfigID sets the "service_token_endpoint_config" edge to the ServiceTokenEndpointConfig entity by id.
func (m *ServiceMutation) SetServiceTokenEndpointConfigID(id string) {
	m.service_token_endpoint_config = &id
}

// ClearServiceTokenEndpointConfig clears the "service_token_endpoint_config" edge to the ServiceTokenEndpointConfig entity.
func (m *ServiceMutation) ClearServiceTokenEndpointConfig() {
	m.clearedservice_token_endpoint_config = true
}

// ServiceTokenEndpointConfigCleared reports if the "service_token_endpoint_config" edge to the ServiceTokenEndpointConfig entity was cleared.
func (m *ServiceMutation) ServiceTokenEndpointConfigCleared() bool {
	return m.clearedservice_token_endpoint_config
}

// ServiceTokenEndpointConfigID returns the "service_token_endpoint_config" edge ID in the mutation.
func (m *ServiceMutation) ServiceTokenEndpointConfigID() (id string, exists bool) {
	if m.service_token_endpoint_config != nil {
		return *m.service_token_endpoint_config, true
	}
	return
}

// ServiceTokenEndpointConfigIDs returns the "service_token_endpoint_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceTokenEndpointConfigID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ServiceTokenEndpointConfigIDs() (ids []string) {
	if id := m.service_token_endpoint_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceTokenEndpointConfig resets all changes to the "service_token_endpoint_config" edge.
func (m *ServiceMutation) ResetServiceTokenEndpointConfig() {
	m.service_token_endpoint_config = nil
	m.clearedservice_token_endpoint_config = false
}

// SetServiceUserInfoEndpointConfigID sets the "service_user_info_endpoint_config" edge to the ServiceUserInfoEndpointConfig entity by id.
func (m *ServiceMutation) SetServiceUserInfoEndpointConfigID(id string) {
	m.service_user_info_endpoint_config = &id
}

// ClearServiceUserInfoEndpointConfig clears the "service_user_info_endpoint_config" edge to the ServiceUserInfoEndpointConfig entity.
func (m *ServiceMutation) ClearServiceUserInfoEndpointConfig() {
	m.clearedservice_user_info_endpoint_config = true
}

// ServiceUserInfoEndpointConfigCleared reports if the "service_user_info_endpoint_config" edge to the ServiceUserInfoEndpointConfig entity was cleared.
func (m *ServiceMutation) ServiceUserInfoEndpointConfigCleared() bool {
	return m.clearedservice_user_info_endpoint_config
}

// ServiceUserInfoEndpointConfigID returns the "service_user_info_endpoint_config" edge ID in the mutation.
func (m *ServiceMutation) ServiceUserInfoEndpointConfigID() (id string, exists bool) {
	if m.service_user_info_endpoint_config != nil {
		return *m.service_user_info_endpoint_config, true
	}
	return
}

// ServiceUserInfoEndpointConfigIDs returns the "service_user_info_endpoint_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceUserInfoEndpointConfigID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ServiceUserInfoEndpointConfigIDs() (ids []string) {
	if id := m.service_user_info_endpoint_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceUserInfoEndpointConfig resets all changes to the "service_user_info_endpoint_config" edge.
func (m *ServiceMutation) ResetServiceUserInfoEndpointConfig() {
	m.service_user_info_endpoint_config = nil
	m.clearedservice_user_info_endpoint_config = false
}

// SetServiceJwksEndpointConfigID sets the "service_jwks_endpoint_config" edge to the ServiceJWKSEndpointConfig entity by id.
func (m *ServiceMutation) SetServiceJwksEndpointConfigID(id string) {
	m.service_jwks_endpoint_config = &id
}

// ClearServiceJwksEndpointConfig clears the "service_jwks_endpoint_config" edge to the ServiceJWKSEndpointConfig entity.
func (m *ServiceMutation) ClearServiceJwksEndpointConfig() {
	m.clearedservice_jwks_endpoint_config = true
}

// ServiceJwksEndpointConfigCleared reports if the "service_jwks_endpoint_config" edge to the ServiceJWKSEndpointConfig entity was cleared.
func (m *ServiceMutation) ServiceJwksEndpointConfigCleared() bool {
	return m.clearedservice_jwks_endpoint_config
}

// ServiceJwksEndpointConfigID returns the "service_jwks_endpoint_config" edge ID in the mutation.
func (m *ServiceMutation) ServiceJwksEndpointConfigID() (id string, exists bool) {
	if m.service_jwks_endpoint_config != nil {
		return *m.service_jwks_endpoint_config, true
	}
	return
}

// ServiceJwksEndpointConfigIDs returns the "service_jwks_endpoint_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceJwksEndpointConfigID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ServiceJwksEndpointConfigIDs() (ids []string) {
	if id := m.service_jwks_endpoint_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceJwksEndpointConfig resets all changes to the "service_jwks_endpoint_config" edge.
func (m *ServiceMutation) ResetServiceJwksEndpointConfig() {
	m.service_jwks_endpoint_config = nil
	m.clearedservice_jwks_endpoint_config = false
}

// SetServiceWellKnownEndpointConfigID sets the "service_well_known_endpoint_config" edge to the WellKnownEndpointConfig entity by id.
func (m *ServiceMutation) SetServiceWellKnownEndpointConfigID(id string) {
	m.service_well_known_endpoint_config = &id
}

// ClearServiceWellKnownEndpointConfig clears the "service_well_known_endpoint_config" edge to the WellKnownEndpointConfig entity.
func (m *ServiceMutation) ClearServiceWellKnownEndpointConfig() {
	m.clearedservice_well_known_endpoint_config = true
}

// ServiceWellKnownEndpointConfigCleared reports if the "service_well_known_endpoint_config" edge to the WellKnownEndpointConfig entity was cleared.
func (m *ServiceMutation) ServiceWellKnownEndpointConfigCleared() bool {
	return m.clearedservice_well_known_endpoint_config
}

// ServiceWellKnownEndpointConfigID returns the "service_well_known_endpoint_config" edge ID in the mutation.
func (m *ServiceMutation) ServiceWellKnownEndpointConfigID() (id string, exists bool) {
	if m.service_well_known_endpoint_config != nil {
		return *m.service_well_known_endpoint_config, true
	}
	return
}

// ServiceWellKnownEndpointConfigIDs returns the "service_well_known_endpoint_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceWellKnownEndpointConfigID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ServiceWellKnownEndpointConfigIDs() (ids []string) {
	if id := m.service_well_known_endpoint_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceWellKnownEndpointConfig resets all changes to the "service_well_known_endpoint_config" edge.
func (m *ServiceMutation) ResetServiceWellKnownEndpointConfig() {
	m.service_well_known_endpoint_config = nil
	m.clearedservice_well_known_endpoint_config = false
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *ServiceMutation) AddApplicationIDs(ids ...string) {
	if m.applications == nil {
		m.applications = make(map[string]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *ServiceMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *ServiceMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *ServiceMutation) RemoveApplicationIDs(ids ...string) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *ServiceMutation) RemovedApplicationsIDs() (ids []string) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *ServiceMutation) ApplicationsIDs() (ids []string) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *ServiceMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// Where appends a list predicates to the ServiceMutation builder.
func (m *ServiceMutation) Where(ps ...predicate.Service) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Service, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.issuer != nil {
		fields = append(fields, service.FieldIssuer)
	}
	if m.description != nil {
		fields = append(fields, service.FieldDescription)
	}
	if m.scopes != nil {
		fields = append(fields, service.FieldScopes)
	}
	if m.service_metadata != nil {
		fields = append(fields, service.FieldServiceMetadata)
	}
	if m.allowed_client_metadata != nil {
		fields = append(fields, service.FieldAllowedClientMetadata)
	}
	if m.grant_types != nil {
		fields = append(fields, service.FieldGrantTypes)
	}
	if m.response_types != nil {
		fields = append(fields, service.FieldResponseTypes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldName:
		return m.Name()
	case service.FieldIssuer:
		return m.Issuer()
	case service.FieldDescription:
		return m.Description()
	case service.FieldScopes:
		return m.Scopes()
	case service.FieldServiceMetadata:
		return m.ServiceMetadata()
	case service.FieldAllowedClientMetadata:
		return m.AllowedClientMetadata()
	case service.FieldGrantTypes:
		return m.GrantTypes()
	case service.FieldResponseTypes:
		return m.ResponseTypes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldIssuer:
		return m.OldIssuer(ctx)
	case service.FieldDescription:
		return m.OldDescription(ctx)
	case service.FieldScopes:
		return m.OldScopes(ctx)
	case service.FieldServiceMetadata:
		return m.OldServiceMetadata(ctx)
	case service.FieldAllowedClientMetadata:
		return m.OldAllowedClientMetadata(ctx)
	case service.FieldGrantTypes:
		return m.OldGrantTypes(ctx)
	case service.FieldResponseTypes:
		return m.OldResponseTypes(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	case service.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case service.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case service.FieldServiceMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceMetadata(v)
		return nil
	case service.FieldAllowedClientMetadata:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedClientMetadata(v)
		return nil
	case service.FieldGrantTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantTypes(v)
		return nil
	case service.FieldResponseTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTypes(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldIssuer:
		m.ResetIssuer()
		return nil
	case service.FieldDescription:
		m.ResetDescription()
		return nil
	case service.FieldScopes:
		m.ResetScopes()
		return nil
	case service.FieldServiceMetadata:
		m.ResetServiceMetadata()
		return nil
	case service.FieldAllowedClientMetadata:
		m.ResetAllowedClientMetadata()
		return nil
	case service.FieldGrantTypes:
		m.ResetGrantTypes()
		return nil
	case service.FieldResponseTypes:
		m.ResetResponseTypes()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.key_set != nil {
		edges = append(edges, service.EdgeKeySet)
	}
	if m.service_authorization_endpoint_config != nil {
		edges = append(edges, service.EdgeServiceAuthorizationEndpointConfig)
	}
	if m.service_introspection_endpoint_config != nil {
		edges = append(edges, service.EdgeServiceIntrospectionEndpointConfig)
	}
	if m.service_token_endpoint_config != nil {
		edges = append(edges, service.EdgeServiceTokenEndpointConfig)
	}
	if m.service_user_info_endpoint_config != nil {
		edges = append(edges, service.EdgeServiceUserInfoEndpointConfig)
	}
	if m.service_jwks_endpoint_config != nil {
		edges = append(edges, service.EdgeServiceJwksEndpointConfig)
	}
	if m.service_well_known_endpoint_config != nil {
		edges = append(edges, service.EdgeServiceWellKnownEndpointConfig)
	}
	if m.applications != nil {
		edges = append(edges, service.EdgeApplications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeKeySet:
		if id := m.key_set; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeServiceAuthorizationEndpointConfig:
		if id := m.service_authorization_endpoint_config; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeServiceIntrospectionEndpointConfig:
		if id := m.service_introspection_endpoint_config; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeServiceTokenEndpointConfig:
		if id := m.service_token_endpoint_config; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeServiceUserInfoEndpointConfig:
		if id := m.service_user_info_endpoint_config; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeServiceJwksEndpointConfig:
		if id := m.service_jwks_endpoint_config; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeServiceWellKnownEndpointConfig:
		if id := m.service_well_known_endpoint_config; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedapplications != nil {
		edges = append(edges, service.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedkey_set {
		edges = append(edges, service.EdgeKeySet)
	}
	if m.clearedservice_authorization_endpoint_config {
		edges = append(edges, service.EdgeServiceAuthorizationEndpointConfig)
	}
	if m.clearedservice_introspection_endpoint_config {
		edges = append(edges, service.EdgeServiceIntrospectionEndpointConfig)
	}
	if m.clearedservice_token_endpoint_config {
		edges = append(edges, service.EdgeServiceTokenEndpointConfig)
	}
	if m.clearedservice_user_info_endpoint_config {
		edges = append(edges, service.EdgeServiceUserInfoEndpointConfig)
	}
	if m.clearedservice_jwks_endpoint_config {
		edges = append(edges, service.EdgeServiceJwksEndpointConfig)
	}
	if m.clearedservice_well_known_endpoint_config {
		edges = append(edges, service.EdgeServiceWellKnownEndpointConfig)
	}
	if m.clearedapplications {
		edges = append(edges, service.EdgeApplications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeKeySet:
		return m.clearedkey_set
	case service.EdgeServiceAuthorizationEndpointConfig:
		return m.clearedservice_authorization_endpoint_config
	case service.EdgeServiceIntrospectionEndpointConfig:
		return m.clearedservice_introspection_endpoint_config
	case service.EdgeServiceTokenEndpointConfig:
		return m.clearedservice_token_endpoint_config
	case service.EdgeServiceUserInfoEndpointConfig:
		return m.clearedservice_user_info_endpoint_config
	case service.EdgeServiceJwksEndpointConfig:
		return m.clearedservice_jwks_endpoint_config
	case service.EdgeServiceWellKnownEndpointConfig:
		return m.clearedservice_well_known_endpoint_config
	case service.EdgeApplications:
		return m.clearedapplications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeKeySet:
		m.ClearKeySet()
		return nil
	case service.EdgeServiceAuthorizationEndpointConfig:
		m.ClearServiceAuthorizationEndpointConfig()
		return nil
	case service.EdgeServiceIntrospectionEndpointConfig:
		m.ClearServiceIntrospectionEndpointConfig()
		return nil
	case service.EdgeServiceTokenEndpointConfig:
		m.ClearServiceTokenEndpointConfig()
		return nil
	case service.EdgeServiceUserInfoEndpointConfig:
		m.ClearServiceUserInfoEndpointConfig()
		return nil
	case service.EdgeServiceJwksEndpointConfig:
		m.ClearServiceJwksEndpointConfig()
		return nil
	case service.EdgeServiceWellKnownEndpointConfig:
		m.ClearServiceWellKnownEndpointConfig()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeKeySet:
		m.ResetKeySet()
		return nil
	case service.EdgeServiceAuthorizationEndpointConfig:
		m.ResetServiceAuthorizationEndpointConfig()
		return nil
	case service.EdgeServiceIntrospectionEndpointConfig:
		m.ResetServiceIntrospectionEndpointConfig()
		return nil
	case service.EdgeServiceTokenEndpointConfig:
		m.ResetServiceTokenEndpointConfig()
		return nil
	case service.EdgeServiceUserInfoEndpointConfig:
		m.ResetServiceUserInfoEndpointConfig()
		return nil
	case service.EdgeServiceJwksEndpointConfig:
		m.ResetServiceJwksEndpointConfig()
		return nil
	case service.EdgeServiceWellKnownEndpointConfig:
		m.ResetServiceWellKnownEndpointConfig()
		return nil
	case service.EdgeApplications:
		m.ResetApplications()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// ServiceAuthorizationEndpointConfigMutation represents an operation that mutates the ServiceAuthorizationEndpointConfig nodes in the graph.
type ServiceAuthorizationEndpointConfigMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *string
	endpoint                                 *string
	pkce_required                            *bool
	pkce_s256_code_challenge_method_required *bool
	clearedFields                            map[string]struct{}
	service                                  *string
	clearedservice                           bool
	done                                     bool
	oldValue                                 func(context.Context) (*ServiceAuthorizationEndpointConfig, error)
	predicates                               []predicate.ServiceAuthorizationEndpointConfig
}

var _ ent.Mutation = (*ServiceAuthorizationEndpointConfigMutation)(nil)

// serviceauthorizationendpointconfigOption allows management of the mutation configuration using functional options.
type serviceauthorizationendpointconfigOption func(*ServiceAuthorizationEndpointConfigMutation)

// newServiceAuthorizationEndpointConfigMutation creates new mutation for the ServiceAuthorizationEndpointConfig entity.
func newServiceAuthorizationEndpointConfigMutation(c config, op Op, opts ...serviceauthorizationendpointconfigOption) *ServiceAuthorizationEndpointConfigMutation {
	m := &ServiceAuthorizationEndpointConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceAuthorizationEndpointConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceAuthorizationEndpointConfigID sets the ID field of the mutation.
func withServiceAuthorizationEndpointConfigID(id string) serviceauthorizationendpointconfigOption {
	return func(m *ServiceAuthorizationEndpointConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceAuthorizationEndpointConfig
		)
		m.oldValue = func(ctx context.Context) (*ServiceAuthorizationEndpointConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceAuthorizationEndpointConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceAuthorizationEndpointConfig sets the old ServiceAuthorizationEndpointConfig of the mutation.
func withServiceAuthorizationEndpointConfig(node *ServiceAuthorizationEndpointConfig) serviceauthorizationendpointconfigOption {
	return func(m *ServiceAuthorizationEndpointConfigMutation) {
		m.oldValue = func(context.Context) (*ServiceAuthorizationEndpointConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceAuthorizationEndpointConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceAuthorizationEndpointConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceAuthorizationEndpointConfig entities.
func (m *ServiceAuthorizationEndpointConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceAuthorizationEndpointConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceAuthorizationEndpointConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEndpoint sets the "endpoint" field.
func (m *ServiceAuthorizationEndpointConfigMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the ServiceAuthorizationEndpointConfig entity.
// If the ServiceAuthorizationEndpointConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceAuthorizationEndpointConfigMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *ServiceAuthorizationEndpointConfigMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetPkceRequired sets the "pkce_required" field.
func (m *ServiceAuthorizationEndpointConfigMutation) SetPkceRequired(b bool) {
	m.pkce_required = &b
}

// PkceRequired returns the value of the "pkce_required" field in the mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) PkceRequired() (r bool, exists bool) {
	v := m.pkce_required
	if v == nil {
		return
	}
	return *v, true
}

// OldPkceRequired returns the old "pkce_required" field's value of the ServiceAuthorizationEndpointConfig entity.
// If the ServiceAuthorizationEndpointConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceAuthorizationEndpointConfigMutation) OldPkceRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkceRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkceRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkceRequired: %w", err)
	}
	return oldValue.PkceRequired, nil
}

// ResetPkceRequired resets all changes to the "pkce_required" field.
func (m *ServiceAuthorizationEndpointConfigMutation) ResetPkceRequired() {
	m.pkce_required = nil
}

// SetPkceS256CodeChallengeMethodRequired sets the "pkce_s256_code_challenge_method_required" field.
func (m *ServiceAuthorizationEndpointConfigMutation) SetPkceS256CodeChallengeMethodRequired(b bool) {
	m.pkce_s256_code_challenge_method_required = &b
}

// PkceS256CodeChallengeMethodRequired returns the value of the "pkce_s256_code_challenge_method_required" field in the mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) PkceS256CodeChallengeMethodRequired() (r bool, exists bool) {
	v := m.pkce_s256_code_challenge_method_required
	if v == nil {
		return
	}
	return *v, true
}

// OldPkceS256CodeChallengeMethodRequired returns the old "pkce_s256_code_challenge_method_required" field's value of the ServiceAuthorizationEndpointConfig entity.
// If the ServiceAuthorizationEndpointConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceAuthorizationEndpointConfigMutation) OldPkceS256CodeChallengeMethodRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkceS256CodeChallengeMethodRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkceS256CodeChallengeMethodRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkceS256CodeChallengeMethodRequired: %w", err)
	}
	return oldValue.PkceS256CodeChallengeMethodRequired, nil
}

// ResetPkceS256CodeChallengeMethodRequired resets all changes to the "pkce_s256_code_challenge_method_required" field.
func (m *ServiceAuthorizationEndpointConfigMutation) ResetPkceS256CodeChallengeMethodRequired() {
	m.pkce_s256_code_challenge_method_required = nil
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *ServiceAuthorizationEndpointConfigMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceAuthorizationEndpointConfigMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceAuthorizationEndpointConfigMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceAuthorizationEndpointConfigMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceAuthorizationEndpointConfigMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ServiceAuthorizationEndpointConfigMutation builder.
func (m *ServiceAuthorizationEndpointConfigMutation) Where(ps ...predicate.ServiceAuthorizationEndpointConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceAuthorizationEndpointConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceAuthorizationEndpointConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceAuthorizationEndpointConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceAuthorizationEndpointConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceAuthorizationEndpointConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceAuthorizationEndpointConfig).
func (m *ServiceAuthorizationEndpointConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceAuthorizationEndpointConfigMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.endpoint != nil {
		fields = append(fields, serviceauthorizationendpointconfig.FieldEndpoint)
	}
	if m.pkce_required != nil {
		fields = append(fields, serviceauthorizationendpointconfig.FieldPkceRequired)
	}
	if m.pkce_s256_code_challenge_method_required != nil {
		fields = append(fields, serviceauthorizationendpointconfig.FieldPkceS256CodeChallengeMethodRequired)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceAuthorizationEndpointConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceauthorizationendpointconfig.FieldEndpoint:
		return m.Endpoint()
	case serviceauthorizationendpointconfig.FieldPkceRequired:
		return m.PkceRequired()
	case serviceauthorizationendpointconfig.FieldPkceS256CodeChallengeMethodRequired:
		return m.PkceS256CodeChallengeMethodRequired()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceAuthorizationEndpointConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceauthorizationendpointconfig.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case serviceauthorizationendpointconfig.FieldPkceRequired:
		return m.OldPkceRequired(ctx)
	case serviceauthorizationendpointconfig.FieldPkceS256CodeChallengeMethodRequired:
		return m.OldPkceS256CodeChallengeMethodRequired(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceAuthorizationEndpointConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceAuthorizationEndpointConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceauthorizationendpointconfig.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case serviceauthorizationendpointconfig.FieldPkceRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkceRequired(v)
		return nil
	case serviceauthorizationendpointconfig.FieldPkceS256CodeChallengeMethodRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkceS256CodeChallengeMethodRequired(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceAuthorizationEndpointConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceAuthorizationEndpointConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceAuthorizationEndpointConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceAuthorizationEndpointConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceAuthorizationEndpointConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceAuthorizationEndpointConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceAuthorizationEndpointConfigMutation) ResetField(name string) error {
	switch name {
	case serviceauthorizationendpointconfig.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case serviceauthorizationendpointconfig.FieldPkceRequired:
		m.ResetPkceRequired()
		return nil
	case serviceauthorizationendpointconfig.FieldPkceS256CodeChallengeMethodRequired:
		m.ResetPkceS256CodeChallengeMethodRequired()
		return nil
	}
	return fmt.Errorf("unknown ServiceAuthorizationEndpointConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.service != nil {
		edges = append(edges, serviceauthorizationendpointconfig.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceauthorizationendpointconfig.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservice {
		edges = append(edges, serviceauthorizationendpointconfig.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceAuthorizationEndpointConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceauthorizationendpointconfig.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceAuthorizationEndpointConfigMutation) ClearEdge(name string) error {
	switch name {
	case serviceauthorizationendpointconfig.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown ServiceAuthorizationEndpointConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceAuthorizationEndpointConfigMutation) ResetEdge(name string) error {
	switch name {
	case serviceauthorizationendpointconfig.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown ServiceAuthorizationEndpointConfig edge %s", name)
}

// ServiceIntrospectionEndpointConfigMutation represents an operation that mutates the ServiceIntrospectionEndpointConfig nodes in the graph.
type ServiceIntrospectionEndpointConfigMutation struct {
	config
	op             Op
	typ            string
	id             *string
	endpoint       *string
	clearedFields  map[string]struct{}
	service        *string
	clearedservice bool
	done           bool
	oldValue       func(context.Context) (*ServiceIntrospectionEndpointConfig, error)
	predicates     []predicate.ServiceIntrospectionEndpointConfig
}

var _ ent.Mutation = (*ServiceIntrospectionEndpointConfigMutation)(nil)

// serviceintrospectionendpointconfigOption allows management of the mutation configuration using functional options.
type serviceintrospectionendpointconfigOption func(*ServiceIntrospectionEndpointConfigMutation)

// newServiceIntrospectionEndpointConfigMutation creates new mutation for the ServiceIntrospectionEndpointConfig entity.
func newServiceIntrospectionEndpointConfigMutation(c config, op Op, opts ...serviceintrospectionendpointconfigOption) *ServiceIntrospectionEndpointConfigMutation {
	m := &ServiceIntrospectionEndpointConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceIntrospectionEndpointConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceIntrospectionEndpointConfigID sets the ID field of the mutation.
func withServiceIntrospectionEndpointConfigID(id string) serviceintrospectionendpointconfigOption {
	return func(m *ServiceIntrospectionEndpointConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceIntrospectionEndpointConfig
		)
		m.oldValue = func(ctx context.Context) (*ServiceIntrospectionEndpointConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceIntrospectionEndpointConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceIntrospectionEndpointConfig sets the old ServiceIntrospectionEndpointConfig of the mutation.
func withServiceIntrospectionEndpointConfig(node *ServiceIntrospectionEndpointConfig) serviceintrospectionendpointconfigOption {
	return func(m *ServiceIntrospectionEndpointConfigMutation) {
		m.oldValue = func(context.Context) (*ServiceIntrospectionEndpointConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceIntrospectionEndpointConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceIntrospectionEndpointConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceIntrospectionEndpointConfig entities.
func (m *ServiceIntrospectionEndpointConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceIntrospectionEndpointConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceIntrospectionEndpointConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEndpoint sets the "endpoint" field.
func (m *ServiceIntrospectionEndpointConfigMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the ServiceIntrospectionEndpointConfig entity.
// If the ServiceIntrospectionEndpointConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceIntrospectionEndpointConfigMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *ServiceIntrospectionEndpointConfigMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *ServiceIntrospectionEndpointConfigMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceIntrospectionEndpointConfigMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceIntrospectionEndpointConfigMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceIntrospectionEndpointConfigMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceIntrospectionEndpointConfigMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ServiceIntrospectionEndpointConfigMutation builder.
func (m *ServiceIntrospectionEndpointConfigMutation) Where(ps ...predicate.ServiceIntrospectionEndpointConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceIntrospectionEndpointConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceIntrospectionEndpointConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceIntrospectionEndpointConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceIntrospectionEndpointConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceIntrospectionEndpointConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceIntrospectionEndpointConfig).
func (m *ServiceIntrospectionEndpointConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceIntrospectionEndpointConfigMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.endpoint != nil {
		fields = append(fields, serviceintrospectionendpointconfig.FieldEndpoint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceIntrospectionEndpointConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceintrospectionendpointconfig.FieldEndpoint:
		return m.Endpoint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceIntrospectionEndpointConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceintrospectionendpointconfig.FieldEndpoint:
		return m.OldEndpoint(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceIntrospectionEndpointConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceIntrospectionEndpointConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceintrospectionendpointconfig.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceIntrospectionEndpointConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceIntrospectionEndpointConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceIntrospectionEndpointConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceIntrospectionEndpointConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceIntrospectionEndpointConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceIntrospectionEndpointConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceIntrospectionEndpointConfigMutation) ResetField(name string) error {
	switch name {
	case serviceintrospectionendpointconfig.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	}
	return fmt.Errorf("unknown ServiceIntrospectionEndpointConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.service != nil {
		edges = append(edges, serviceintrospectionendpointconfig.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceintrospectionendpointconfig.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservice {
		edges = append(edges, serviceintrospectionendpointconfig.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceIntrospectionEndpointConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceintrospectionendpointconfig.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceIntrospectionEndpointConfigMutation) ClearEdge(name string) error {
	switch name {
	case serviceintrospectionendpointconfig.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown ServiceIntrospectionEndpointConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceIntrospectionEndpointConfigMutation) ResetEdge(name string) error {
	switch name {
	case serviceintrospectionendpointconfig.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown ServiceIntrospectionEndpointConfig edge %s", name)
}

// ServiceJWKSEndpointConfigMutation represents an operation that mutates the ServiceJWKSEndpointConfig nodes in the graph.
type ServiceJWKSEndpointConfigMutation struct {
	config
	op             Op
	typ            string
	id             *string
	endpoint       *string
	clearedFields  map[string]struct{}
	service        *string
	clearedservice bool
	done           bool
	oldValue       func(context.Context) (*ServiceJWKSEndpointConfig, error)
	predicates     []predicate.ServiceJWKSEndpointConfig
}

var _ ent.Mutation = (*ServiceJWKSEndpointConfigMutation)(nil)

// servicejwksendpointconfigOption allows management of the mutation configuration using functional options.
type servicejwksendpointconfigOption func(*ServiceJWKSEndpointConfigMutation)

// newServiceJWKSEndpointConfigMutation creates new mutation for the ServiceJWKSEndpointConfig entity.
func newServiceJWKSEndpointConfigMutation(c config, op Op, opts ...servicejwksendpointconfigOption) *ServiceJWKSEndpointConfigMutation {
	m := &ServiceJWKSEndpointConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceJWKSEndpointConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceJWKSEndpointConfigID sets the ID field of the mutation.
func withServiceJWKSEndpointConfigID(id string) servicejwksendpointconfigOption {
	return func(m *ServiceJWKSEndpointConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceJWKSEndpointConfig
		)
		m.oldValue = func(ctx context.Context) (*ServiceJWKSEndpointConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceJWKSEndpointConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceJWKSEndpointConfig sets the old ServiceJWKSEndpointConfig of the mutation.
func withServiceJWKSEndpointConfig(node *ServiceJWKSEndpointConfig) servicejwksendpointconfigOption {
	return func(m *ServiceJWKSEndpointConfigMutation) {
		m.oldValue = func(context.Context) (*ServiceJWKSEndpointConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceJWKSEndpointConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceJWKSEndpointConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceJWKSEndpointConfig entities.
func (m *ServiceJWKSEndpointConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceJWKSEndpointConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceJWKSEndpointConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceJWKSEndpointConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEndpoint sets the "endpoint" field.
func (m *ServiceJWKSEndpointConfigMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *ServiceJWKSEndpointConfigMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the ServiceJWKSEndpointConfig entity.
// If the ServiceJWKSEndpointConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceJWKSEndpointConfigMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *ServiceJWKSEndpointConfigMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *ServiceJWKSEndpointConfigMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceJWKSEndpointConfigMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceJWKSEndpointConfigMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *ServiceJWKSEndpointConfigMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceJWKSEndpointConfigMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceJWKSEndpointConfigMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ServiceJWKSEndpointConfigMutation builder.
func (m *ServiceJWKSEndpointConfigMutation) Where(ps ...predicate.ServiceJWKSEndpointConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceJWKSEndpointConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceJWKSEndpointConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceJWKSEndpointConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceJWKSEndpointConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceJWKSEndpointConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceJWKSEndpointConfig).
func (m *ServiceJWKSEndpointConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceJWKSEndpointConfigMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.endpoint != nil {
		fields = append(fields, servicejwksendpointconfig.FieldEndpoint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceJWKSEndpointConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicejwksendpointconfig.FieldEndpoint:
		return m.Endpoint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceJWKSEndpointConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicejwksendpointconfig.FieldEndpoint:
		return m.OldEndpoint(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceJWKSEndpointConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceJWKSEndpointConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicejwksendpointconfig.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceJWKSEndpointConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceJWKSEndpointConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceJWKSEndpointConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceJWKSEndpointConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceJWKSEndpointConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceJWKSEndpointConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceJWKSEndpointConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceJWKSEndpointConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceJWKSEndpointConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceJWKSEndpointConfigMutation) ResetField(name string) error {
	switch name {
	case servicejwksendpointconfig.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	}
	return fmt.Errorf("unknown ServiceJWKSEndpointConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceJWKSEndpointConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.service != nil {
		edges = append(edges, servicejwksendpointconfig.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceJWKSEndpointConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicejwksendpointconfig.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceJWKSEndpointConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceJWKSEndpointConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceJWKSEndpointConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservice {
		edges = append(edges, servicejwksendpointconfig.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceJWKSEndpointConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case servicejwksendpointconfig.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceJWKSEndpointConfigMutation) ClearEdge(name string) error {
	switch name {
	case servicejwksendpointconfig.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown ServiceJWKSEndpointConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceJWKSEndpointConfigMutation) ResetEdge(name string) error {
	switch name {
	case servicejwksendpointconfig.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown ServiceJWKSEndpointConfig edge %s", name)
}

// ServiceTokenEndpointConfigMutation represents an operation that mutates the ServiceTokenEndpointConfig nodes in the graph.
type ServiceTokenEndpointConfigMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *string
	endpoint                             *string
	allowed_authentication_methods       *[]string
	appendallowed_authentication_methods []string
	clearedFields                        map[string]struct{}
	service                              *string
	clearedservice                       bool
	done                                 bool
	oldValue                             func(context.Context) (*ServiceTokenEndpointConfig, error)
	predicates                           []predicate.ServiceTokenEndpointConfig
}

var _ ent.Mutation = (*ServiceTokenEndpointConfigMutation)(nil)

// servicetokenendpointconfigOption allows management of the mutation configuration using functional options.
type servicetokenendpointconfigOption func(*ServiceTokenEndpointConfigMutation)

// newServiceTokenEndpointConfigMutation creates new mutation for the ServiceTokenEndpointConfig entity.
func newServiceTokenEndpointConfigMutation(c config, op Op, opts ...servicetokenendpointconfigOption) *ServiceTokenEndpointConfigMutation {
	m := &ServiceTokenEndpointConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceTokenEndpointConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceTokenEndpointConfigID sets the ID field of the mutation.
func withServiceTokenEndpointConfigID(id string) servicetokenendpointconfigOption {
	return func(m *ServiceTokenEndpointConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceTokenEndpointConfig
		)
		m.oldValue = func(ctx context.Context) (*ServiceTokenEndpointConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceTokenEndpointConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceTokenEndpointConfig sets the old ServiceTokenEndpointConfig of the mutation.
func withServiceTokenEndpointConfig(node *ServiceTokenEndpointConfig) servicetokenendpointconfigOption {
	return func(m *ServiceTokenEndpointConfigMutation) {
		m.oldValue = func(context.Context) (*ServiceTokenEndpointConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceTokenEndpointConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceTokenEndpointConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceTokenEndpointConfig entities.
func (m *ServiceTokenEndpointConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceTokenEndpointConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceTokenEndpointConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceTokenEndpointConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEndpoint sets the "endpoint" field.
func (m *ServiceTokenEndpointConfigMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *ServiceTokenEndpointConfigMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the ServiceTokenEndpointConfig entity.
// If the ServiceTokenEndpointConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTokenEndpointConfigMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *ServiceTokenEndpointConfigMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetAllowedAuthenticationMethods sets the "allowed_authentication_methods" field.
func (m *ServiceTokenEndpointConfigMutation) SetAllowedAuthenticationMethods(s []string) {
	m.allowed_authentication_methods = &s
	m.appendallowed_authentication_methods = nil
}

// AllowedAuthenticationMethods returns the value of the "allowed_authentication_methods" field in the mutation.
func (m *ServiceTokenEndpointConfigMutation) AllowedAuthenticationMethods() (r []string, exists bool) {
	v := m.allowed_authentication_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedAuthenticationMethods returns the old "allowed_authentication_methods" field's value of the ServiceTokenEndpointConfig entity.
// If the ServiceTokenEndpointConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTokenEndpointConfigMutation) OldAllowedAuthenticationMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedAuthenticationMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedAuthenticationMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedAuthenticationMethods: %w", err)
	}
	return oldValue.AllowedAuthenticationMethods, nil
}

// AppendAllowedAuthenticationMethods adds s to the "allowed_authentication_methods" field.
func (m *ServiceTokenEndpointConfigMutation) AppendAllowedAuthenticationMethods(s []string) {
	m.appendallowed_authentication_methods = append(m.appendallowed_authentication_methods, s...)
}

// AppendedAllowedAuthenticationMethods returns the list of values that were appended to the "allowed_authentication_methods" field in this mutation.
func (m *ServiceTokenEndpointConfigMutation) AppendedAllowedAuthenticationMethods() ([]string, bool) {
	if len(m.appendallowed_authentication_methods) == 0 {
		return nil, false
	}
	return m.appendallowed_authentication_methods, true
}

// ResetAllowedAuthenticationMethods resets all changes to the "allowed_authentication_methods" field.
func (m *ServiceTokenEndpointConfigMutation) ResetAllowedAuthenticationMethods() {
	m.allowed_authentication_methods = nil
	m.appendallowed_authentication_methods = nil
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *ServiceTokenEndpointConfigMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceTokenEndpointConfigMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceTokenEndpointConfigMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *ServiceTokenEndpointConfigMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceTokenEndpointConfigMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceTokenEndpointConfigMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ServiceTokenEndpointConfigMutation builder.
func (m *ServiceTokenEndpointConfigMutation) Where(ps ...predicate.ServiceTokenEndpointConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceTokenEndpointConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceTokenEndpointConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceTokenEndpointConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceTokenEndpointConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceTokenEndpointConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceTokenEndpointConfig).
func (m *ServiceTokenEndpointConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceTokenEndpointConfigMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.endpoint != nil {
		fields = append(fields, servicetokenendpointconfig.FieldEndpoint)
	}
	if m.allowed_authentication_methods != nil {
		fields = append(fields, servicetokenendpointconfig.FieldAllowedAuthenticationMethods)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceTokenEndpointConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicetokenendpointconfig.FieldEndpoint:
		return m.Endpoint()
	case servicetokenendpointconfig.FieldAllowedAuthenticationMethods:
		return m.AllowedAuthenticationMethods()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceTokenEndpointConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicetokenendpointconfig.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case servicetokenendpointconfig.FieldAllowedAuthenticationMethods:
		return m.OldAllowedAuthenticationMethods(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceTokenEndpointConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTokenEndpointConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicetokenendpointconfig.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case servicetokenendpointconfig.FieldAllowedAuthenticationMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedAuthenticationMethods(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceTokenEndpointConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceTokenEndpointConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceTokenEndpointConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTokenEndpointConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceTokenEndpointConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceTokenEndpointConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceTokenEndpointConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceTokenEndpointConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceTokenEndpointConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceTokenEndpointConfigMutation) ResetField(name string) error {
	switch name {
	case servicetokenendpointconfig.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case servicetokenendpointconfig.FieldAllowedAuthenticationMethods:
		m.ResetAllowedAuthenticationMethods()
		return nil
	}
	return fmt.Errorf("unknown ServiceTokenEndpointConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceTokenEndpointConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.service != nil {
		edges = append(edges, servicetokenendpointconfig.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceTokenEndpointConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicetokenendpointconfig.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceTokenEndpointConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceTokenEndpointConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceTokenEndpointConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservice {
		edges = append(edges, servicetokenendpointconfig.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceTokenEndpointConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case servicetokenendpointconfig.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceTokenEndpointConfigMutation) ClearEdge(name string) error {
	switch name {
	case servicetokenendpointconfig.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown ServiceTokenEndpointConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceTokenEndpointConfigMutation) ResetEdge(name string) error {
	switch name {
	case servicetokenendpointconfig.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown ServiceTokenEndpointConfig edge %s", name)
}

// ServiceUserInfoEndpointConfigMutation represents an operation that mutates the ServiceUserInfoEndpointConfig nodes in the graph.
type ServiceUserInfoEndpointConfigMutation struct {
	config
	op             Op
	typ            string
	id             *string
	endpoint       *string
	clearedFields  map[string]struct{}
	service        *string
	clearedservice bool
	done           bool
	oldValue       func(context.Context) (*ServiceUserInfoEndpointConfig, error)
	predicates     []predicate.ServiceUserInfoEndpointConfig
}

var _ ent.Mutation = (*ServiceUserInfoEndpointConfigMutation)(nil)

// serviceuserinfoendpointconfigOption allows management of the mutation configuration using functional options.
type serviceuserinfoendpointconfigOption func(*ServiceUserInfoEndpointConfigMutation)

// newServiceUserInfoEndpointConfigMutation creates new mutation for the ServiceUserInfoEndpointConfig entity.
func newServiceUserInfoEndpointConfigMutation(c config, op Op, opts ...serviceuserinfoendpointconfigOption) *ServiceUserInfoEndpointConfigMutation {
	m := &ServiceUserInfoEndpointConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceUserInfoEndpointConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceUserInfoEndpointConfigID sets the ID field of the mutation.
func withServiceUserInfoEndpointConfigID(id string) serviceuserinfoendpointconfigOption {
	return func(m *ServiceUserInfoEndpointConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceUserInfoEndpointConfig
		)
		m.oldValue = func(ctx context.Context) (*ServiceUserInfoEndpointConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceUserInfoEndpointConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceUserInfoEndpointConfig sets the old ServiceUserInfoEndpointConfig of the mutation.
func withServiceUserInfoEndpointConfig(node *ServiceUserInfoEndpointConfig) serviceuserinfoendpointconfigOption {
	return func(m *ServiceUserInfoEndpointConfigMutation) {
		m.oldValue = func(context.Context) (*ServiceUserInfoEndpointConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceUserInfoEndpointConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceUserInfoEndpointConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceUserInfoEndpointConfig entities.
func (m *ServiceUserInfoEndpointConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceUserInfoEndpointConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceUserInfoEndpointConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceUserInfoEndpointConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEndpoint sets the "endpoint" field.
func (m *ServiceUserInfoEndpointConfigMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *ServiceUserInfoEndpointConfigMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the ServiceUserInfoEndpointConfig entity.
// If the ServiceUserInfoEndpointConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceUserInfoEndpointConfigMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *ServiceUserInfoEndpointConfigMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *ServiceUserInfoEndpointConfigMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceUserInfoEndpointConfigMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceUserInfoEndpointConfigMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *ServiceUserInfoEndpointConfigMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceUserInfoEndpointConfigMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceUserInfoEndpointConfigMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ServiceUserInfoEndpointConfigMutation builder.
func (m *ServiceUserInfoEndpointConfigMutation) Where(ps ...predicate.ServiceUserInfoEndpointConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceUserInfoEndpointConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceUserInfoEndpointConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceUserInfoEndpointConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceUserInfoEndpointConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceUserInfoEndpointConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceUserInfoEndpointConfig).
func (m *ServiceUserInfoEndpointConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceUserInfoEndpointConfigMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.endpoint != nil {
		fields = append(fields, serviceuserinfoendpointconfig.FieldEndpoint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceUserInfoEndpointConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceuserinfoendpointconfig.FieldEndpoint:
		return m.Endpoint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceUserInfoEndpointConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceuserinfoendpointconfig.FieldEndpoint:
		return m.OldEndpoint(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceUserInfoEndpointConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceUserInfoEndpointConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceuserinfoendpointconfig.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceUserInfoEndpointConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceUserInfoEndpointConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceUserInfoEndpointConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceUserInfoEndpointConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceUserInfoEndpointConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceUserInfoEndpointConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceUserInfoEndpointConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceUserInfoEndpointConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceUserInfoEndpointConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceUserInfoEndpointConfigMutation) ResetField(name string) error {
	switch name {
	case serviceuserinfoendpointconfig.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	}
	return fmt.Errorf("unknown ServiceUserInfoEndpointConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceUserInfoEndpointConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.service != nil {
		edges = append(edges, serviceuserinfoendpointconfig.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceUserInfoEndpointConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceuserinfoendpointconfig.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceUserInfoEndpointConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceUserInfoEndpointConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceUserInfoEndpointConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservice {
		edges = append(edges, serviceuserinfoendpointconfig.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceUserInfoEndpointConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceuserinfoendpointconfig.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceUserInfoEndpointConfigMutation) ClearEdge(name string) error {
	switch name {
	case serviceuserinfoendpointconfig.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown ServiceUserInfoEndpointConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceUserInfoEndpointConfigMutation) ResetEdge(name string) error {
	switch name {
	case serviceuserinfoendpointconfig.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown ServiceUserInfoEndpointConfig edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	created_at                   *int64
	addcreated_at                *int64
	server_name                  *string
	clearedFields                map[string]struct{}
	authorization_payload        *string
	clearedauthorization_payload bool
	done                         bool
	oldValue                     func(context.Context) (*Session, error)
	predicates                   []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *SessionMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SessionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetServerName sets the "server_name" field.
func (m *SessionMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *SessionMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ResetServerName resets all changes to the "server_name" field.
func (m *SessionMutation) ResetServerName() {
	m.server_name = nil
}

// SetAuthorizationPayloadID sets the "authorization_payload" edge to the AuthorizationPayload entity by id.
func (m *SessionMutation) SetAuthorizationPayloadID(id string) {
	m.authorization_payload = &id
}

// ClearAuthorizationPayload clears the "authorization_payload" edge to the AuthorizationPayload entity.
func (m *SessionMutation) ClearAuthorizationPayload() {
	m.clearedauthorization_payload = true
}

// AuthorizationPayloadCleared reports if the "authorization_payload" edge to the AuthorizationPayload entity was cleared.
func (m *SessionMutation) AuthorizationPayloadCleared() bool {
	return m.clearedauthorization_payload
}

// AuthorizationPayloadID returns the "authorization_payload" edge ID in the mutation.
func (m *SessionMutation) AuthorizationPayloadID() (id string, exists bool) {
	if m.authorization_payload != nil {
		return *m.authorization_payload, true
	}
	return
}

// AuthorizationPayloadIDs returns the "authorization_payload" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorizationPayloadID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) AuthorizationPayloadIDs() (ids []string) {
	if id := m.authorization_payload; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthorizationPayload resets all changes to the "authorization_payload" edge.
func (m *SessionMutation) ResetAuthorizationPayload() {
	m.authorization_payload = nil
	m.clearedauthorization_payload = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.server_name != nil {
		fields = append(fields, session.FieldServerName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldServerName:
		return m.ServerName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldServerName:
		return m.OldServerName(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.AddedCreatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldServerName:
		m.ResetServerName()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.authorization_payload != nil {
		edges = append(edges, session.EdgeAuthorizationPayload)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeAuthorizationPayload:
		if id := m.authorization_payload; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthorization_payload {
		edges = append(edges, session.EdgeAuthorizationPayload)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeAuthorizationPayload:
		return m.clearedauthorization_payload
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeAuthorizationPayload:
		m.ClearAuthorizationPayload()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeAuthorizationPayload:
		m.ResetAuthorizationPayload()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SigningKeyMutation represents an operation that mutates the SigningKey nodes in the graph.
type SigningKeyMutation struct {
	config
	op             Op
	typ            string
	id             *string
	key            *string
	clearedFields  map[string]struct{}
	key_set        *string
	clearedkey_set bool
	done           bool
	oldValue       func(context.Context) (*SigningKey, error)
	predicates     []predicate.SigningKey
}

var _ ent.Mutation = (*SigningKeyMutation)(nil)

// signingkeyOption allows management of the mutation configuration using functional options.
type signingkeyOption func(*SigningKeyMutation)

// newSigningKeyMutation creates new mutation for the SigningKey entity.
func newSigningKeyMutation(c config, op Op, opts ...signingkeyOption) *SigningKeyMutation {
	m := &SigningKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningKeyID sets the ID field of the mutation.
func withSigningKeyID(id string) signingkeyOption {
	return func(m *SigningKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningKey
		)
		m.oldValue = func(ctx context.Context) (*SigningKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningKey sets the old SigningKey of the mutation.
func withSigningKey(node *SigningKey) signingkeyOption {
	return func(m *SigningKeyMutation) {
		m.oldValue = func(context.Context) (*SigningKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningKey entities.
func (m *SigningKeyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningKeyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningKeyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SigningKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SigningKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the SigningKey entity.
// If the SigningKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SigningKeyMutation) ResetKey() {
	m.key = nil
}

// SetKeySetID sets the "key_set" edge to the KeySet entity by id.
func (m *SigningKeyMutation) SetKeySetID(id string) {
	m.key_set = &id
}

// ClearKeySet clears the "key_set" edge to the KeySet entity.
func (m *SigningKeyMutation) ClearKeySet() {
	m.clearedkey_set = true
}

// KeySetCleared reports if the "key_set" edge to the KeySet entity was cleared.
func (m *SigningKeyMutation) KeySetCleared() bool {
	return m.clearedkey_set
}

// KeySetID returns the "key_set" edge ID in the mutation.
func (m *SigningKeyMutation) KeySetID() (id string, exists bool) {
	if m.key_set != nil {
		return *m.key_set, true
	}
	return
}

// KeySetIDs returns the "key_set" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeySetID instead. It exists only for internal usage by the builders.
func (m *SigningKeyMutation) KeySetIDs() (ids []string) {
	if id := m.key_set; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeySet resets all changes to the "key_set" edge.
func (m *SigningKeyMutation) ResetKeySet() {
	m.key_set = nil
	m.clearedkey_set = false
}

// Where appends a list predicates to the SigningKeyMutation builder.
func (m *SigningKeyMutation) Where(ps ...predicate.SigningKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningKey).
func (m *SigningKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningKeyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.key != nil {
		fields = append(fields, signingkey.FieldKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingkey.FieldKey:
		return m.Key()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingkey.FieldKey:
		return m.OldKey(ctx)
	}
	return nil, fmt.Errorf("unknown SigningKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingkey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SigningKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningKeyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningKeyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningKeyMutation) ResetField(name string) error {
	switch name {
	case signingkey.FieldKey:
		m.ResetKey()
		return nil
	}
	return fmt.Errorf("unknown SigningKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.key_set != nil {
		edges = append(edges, signingkey.EdgeKeySet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signingkey.EdgeKeySet:
		if id := m.key_set; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkey_set {
		edges = append(edges, signingkey.EdgeKeySet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case signingkey.EdgeKeySet:
		return m.clearedkey_set
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningKeyMutation) ClearEdge(name string) error {
	switch name {
	case signingkey.EdgeKeySet:
		m.ClearKeySet()
		return nil
	}
	return fmt.Errorf("unknown SigningKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningKeyMutation) ResetEdge(name string) error {
	switch name {
	case signingkey.EdgeKeySet:
		m.ResetKeySet()
		return nil
	}
	return fmt.Errorf("unknown SigningKey edge %s", name)
}

// StandardClaimsMutation represents an operation that mutates the StandardClaims nodes in the graph.
type StandardClaimsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	subject               *string
	name                  *string
	given_name            *string
	family_name           *string
	middle_name           *string
	nickname              *string
	preferred_username    *string
	profile               *string
	picture               *string
	website               *string
	email                 *string
	email_verified        *bool
	gender                *string
	birthdate             *string
	zoneinfo              *string
	locale                *string
	phone_number          *string
	phone_number_verified *bool
	address               *string
	updated_at            *int64
	addupdated_at         *int64
	clearedFields         map[string]struct{}
	user                  *string
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*StandardClaims, error)
	predicates            []predicate.StandardClaims
}

var _ ent.Mutation = (*StandardClaimsMutation)(nil)

// standardclaimsOption allows management of the mutation configuration using functional options.
type standardclaimsOption func(*StandardClaimsMutation)

// newStandardClaimsMutation creates new mutation for the StandardClaims entity.
func newStandardClaimsMutation(c config, op Op, opts ...standardclaimsOption) *StandardClaimsMutation {
	m := &StandardClaimsMutation{
		config:        c,
		op:            op,
		typ:           TypeStandardClaims,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStandardClaimsID sets the ID field of the mutation.
func withStandardClaimsID(id int) standardclaimsOption {
	return func(m *StandardClaimsMutation) {
		var (
			err   error
			once  sync.Once
			value *StandardClaims
		)
		m.oldValue = func(ctx context.Context) (*StandardClaims, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StandardClaims.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStandardClaims sets the old StandardClaims of the mutation.
func withStandardClaims(node *StandardClaims) standardclaimsOption {
	return func(m *StandardClaimsMutation) {
		m.oldValue = func(context.Context) (*StandardClaims, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StandardClaimsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StandardClaimsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StandardClaimsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StandardClaimsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StandardClaims.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubject sets the "subject" field.
func (m *StandardClaimsMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *StandardClaimsMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *StandardClaimsMutation) ResetSubject() {
	m.subject = nil
}

// SetName sets the "name" field.
func (m *StandardClaimsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StandardClaimsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *StandardClaimsMutation) ClearName() {
	m.name = nil
	m.clearedFields[standardclaims.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *StandardClaimsMutation) NameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *StandardClaimsMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, standardclaims.FieldName)
}

// SetGivenName sets the "given_name" field.
func (m *StandardClaimsMutation) SetGivenName(s string) {
	m.given_name = &s
}

// GivenName returns the value of the "given_name" field in the mutation.
func (m *StandardClaimsMutation) GivenName() (r string, exists bool) {
	v := m.given_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenName returns the old "given_name" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldGivenName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenName: %w", err)
	}
	return oldValue.GivenName, nil
}

// ClearGivenName clears the value of the "given_name" field.
func (m *StandardClaimsMutation) ClearGivenName() {
	m.given_name = nil
	m.clearedFields[standardclaims.FieldGivenName] = struct{}{}
}

// GivenNameCleared returns if the "given_name" field was cleared in this mutation.
func (m *StandardClaimsMutation) GivenNameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldGivenName]
	return ok
}

// ResetGivenName resets all changes to the "given_name" field.
func (m *StandardClaimsMutation) ResetGivenName() {
	m.given_name = nil
	delete(m.clearedFields, standardclaims.FieldGivenName)
}

// SetFamilyName sets the "family_name" field.
func (m *StandardClaimsMutation) SetFamilyName(s string) {
	m.family_name = &s
}

// FamilyName returns the value of the "family_name" field in the mutation.
func (m *StandardClaimsMutation) FamilyName() (r string, exists bool) {
	v := m.family_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyName returns the old "family_name" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldFamilyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamilyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamilyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyName: %w", err)
	}
	return oldValue.FamilyName, nil
}

// ClearFamilyName clears the value of the "family_name" field.
func (m *StandardClaimsMutation) ClearFamilyName() {
	m.family_name = nil
	m.clearedFields[standardclaims.FieldFamilyName] = struct{}{}
}

// FamilyNameCleared returns if the "family_name" field was cleared in this mutation.
func (m *StandardClaimsMutation) FamilyNameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldFamilyName]
	return ok
}

// ResetFamilyName resets all changes to the "family_name" field.
func (m *StandardClaimsMutation) ResetFamilyName() {
	m.family_name = nil
	delete(m.clearedFields, standardclaims.FieldFamilyName)
}

// SetMiddleName sets the "middle_name" field.
func (m *StandardClaimsMutation) SetMiddleName(s string) {
	m.middle_name = &s
}

// MiddleName returns the value of the "middle_name" field in the mutation.
func (m *StandardClaimsMutation) MiddleName() (r string, exists bool) {
	v := m.middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMiddleName returns the old "middle_name" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldMiddleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiddleName: %w", err)
	}
	return oldValue.MiddleName, nil
}

// ClearMiddleName clears the value of the "middle_name" field.
func (m *StandardClaimsMutation) ClearMiddleName() {
	m.middle_name = nil
	m.clearedFields[standardclaims.FieldMiddleName] = struct{}{}
}

// MiddleNameCleared returns if the "middle_name" field was cleared in this mutation.
func (m *StandardClaimsMutation) MiddleNameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldMiddleName]
	return ok
}

// ResetMiddleName resets all changes to the "middle_name" field.
func (m *StandardClaimsMutation) ResetMiddleName() {
	m.middle_name = nil
	delete(m.clearedFields, standardclaims.FieldMiddleName)
}

// SetNickname sets the "nickname" field.
func (m *StandardClaimsMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *StandardClaimsMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *StandardClaimsMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[standardclaims.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *StandardClaimsMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *StandardClaimsMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, standardclaims.FieldNickname)
}

// SetPreferredUsername sets the "preferred_username" field.
func (m *StandardClaimsMutation) SetPreferredUsername(s string) {
	m.preferred_username = &s
}

// PreferredUsername returns the value of the "preferred_username" field in the mutation.
func (m *StandardClaimsMutation) PreferredUsername() (r string, exists bool) {
	v := m.preferred_username
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferredUsername returns the old "preferred_username" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldPreferredUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferredUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferredUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferredUsername: %w", err)
	}
	return oldValue.PreferredUsername, nil
}

// ClearPreferredUsername clears the value of the "preferred_username" field.
func (m *StandardClaimsMutation) ClearPreferredUsername() {
	m.preferred_username = nil
	m.clearedFields[standardclaims.FieldPreferredUsername] = struct{}{}
}

// PreferredUsernameCleared returns if the "preferred_username" field was cleared in this mutation.
func (m *StandardClaimsMutation) PreferredUsernameCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldPreferredUsername]
	return ok
}

// ResetPreferredUsername resets all changes to the "preferred_username" field.
func (m *StandardClaimsMutation) ResetPreferredUsername() {
	m.preferred_username = nil
	delete(m.clearedFields, standardclaims.FieldPreferredUsername)
}

// SetProfile sets the "profile" field.
func (m *StandardClaimsMutation) SetProfile(s string) {
	m.profile = &s
}

// Profile returns the value of the "profile" field in the mutation.
func (m *StandardClaimsMutation) Profile() (r string, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *StandardClaimsMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[standardclaims.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *StandardClaimsMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *StandardClaimsMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, standardclaims.FieldProfile)
}

// SetPicture sets the "picture" field.
func (m *StandardClaimsMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *StandardClaimsMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldPicture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *StandardClaimsMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[standardclaims.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *StandardClaimsMutation) PictureCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *StandardClaimsMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, standardclaims.FieldPicture)
}

// SetWebsite sets the "website" field.
func (m *StandardClaimsMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *StandardClaimsMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *StandardClaimsMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[standardclaims.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *StandardClaimsMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *StandardClaimsMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, standardclaims.FieldWebsite)
}

// SetEmail sets the "email" field.
func (m *StandardClaimsMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StandardClaimsMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *StandardClaimsMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[standardclaims.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *StandardClaimsMutation) EmailCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *StandardClaimsMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, standardclaims.FieldEmail)
}

// SetEmailVerified sets the "email_verified" field.
func (m *StandardClaimsMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *StandardClaimsMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ClearEmailVerified clears the value of the "email_verified" field.
func (m *StandardClaimsMutation) ClearEmailVerified() {
	m.email_verified = nil
	m.clearedFields[standardclaims.FieldEmailVerified] = struct{}{}
}

// EmailVerifiedCleared returns if the "email_verified" field was cleared in this mutation.
func (m *StandardClaimsMutation) EmailVerifiedCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldEmailVerified]
	return ok
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *StandardClaimsMutation) ResetEmailVerified() {
	m.email_verified = nil
	delete(m.clearedFields, standardclaims.FieldEmailVerified)
}

// SetGender sets the "gender" field.
func (m *StandardClaimsMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *StandardClaimsMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *StandardClaimsMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[standardclaims.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *StandardClaimsMutation) GenderCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *StandardClaimsMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, standardclaims.FieldGender)
}

// SetBirthdate sets the "birthdate" field.
func (m *StandardClaimsMutation) SetBirthdate(s string) {
	m.birthdate = &s
}

// Birthdate returns the value of the "birthdate" field in the mutation.
func (m *StandardClaimsMutation) Birthdate() (r string, exists bool) {
	v := m.birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdate returns the old "birthdate" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldBirthdate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdate: %w", err)
	}
	return oldValue.Birthdate, nil
}

// ClearBirthdate clears the value of the "birthdate" field.
func (m *StandardClaimsMutation) ClearBirthdate() {
	m.birthdate = nil
	m.clearedFields[standardclaims.FieldBirthdate] = struct{}{}
}

// BirthdateCleared returns if the "birthdate" field was cleared in this mutation.
func (m *StandardClaimsMutation) BirthdateCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldBirthdate]
	return ok
}

// ResetBirthdate resets all changes to the "birthdate" field.
func (m *StandardClaimsMutation) ResetBirthdate() {
	m.birthdate = nil
	delete(m.clearedFields, standardclaims.FieldBirthdate)
}

// SetZoneinfo sets the "zoneinfo" field.
func (m *StandardClaimsMutation) SetZoneinfo(s string) {
	m.zoneinfo = &s
}

// Zoneinfo returns the value of the "zoneinfo" field in the mutation.
func (m *StandardClaimsMutation) Zoneinfo() (r string, exists bool) {
	v := m.zoneinfo
	if v == nil {
		return
	}
	return *v, true
}

// OldZoneinfo returns the old "zoneinfo" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldZoneinfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZoneinfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZoneinfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZoneinfo: %w", err)
	}
	return oldValue.Zoneinfo, nil
}

// ClearZoneinfo clears the value of the "zoneinfo" field.
func (m *StandardClaimsMutation) ClearZoneinfo() {
	m.zoneinfo = nil
	m.clearedFields[standardclaims.FieldZoneinfo] = struct{}{}
}

// ZoneinfoCleared returns if the "zoneinfo" field was cleared in this mutation.
func (m *StandardClaimsMutation) ZoneinfoCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldZoneinfo]
	return ok
}

// ResetZoneinfo resets all changes to the "zoneinfo" field.
func (m *StandardClaimsMutation) ResetZoneinfo() {
	m.zoneinfo = nil
	delete(m.clearedFields, standardclaims.FieldZoneinfo)
}

// SetLocale sets the "locale" field.
func (m *StandardClaimsMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *StandardClaimsMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ClearLocale clears the value of the "locale" field.
func (m *StandardClaimsMutation) ClearLocale() {
	m.locale = nil
	m.clearedFields[standardclaims.FieldLocale] = struct{}{}
}

// LocaleCleared returns if the "locale" field was cleared in this mutation.
func (m *StandardClaimsMutation) LocaleCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldLocale]
	return ok
}

// ResetLocale resets all changes to the "locale" field.
func (m *StandardClaimsMutation) ResetLocale() {
	m.locale = nil
	delete(m.clearedFields, standardclaims.FieldLocale)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *StandardClaimsMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *StandardClaimsMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *StandardClaimsMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[standardclaims.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *StandardClaimsMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *StandardClaimsMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, standardclaims.FieldPhoneNumber)
}

// SetPhoneNumberVerified sets the "phone_number_verified" field.
func (m *StandardClaimsMutation) SetPhoneNumberVerified(b bool) {
	m.phone_number_verified = &b
}

// PhoneNumberVerified returns the value of the "phone_number_verified" field in the mutation.
func (m *StandardClaimsMutation) PhoneNumberVerified() (r bool, exists bool) {
	v := m.phone_number_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumberVerified returns the old "phone_number_verified" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldPhoneNumberVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumberVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumberVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumberVerified: %w", err)
	}
	return oldValue.PhoneNumberVerified, nil
}

// ClearPhoneNumberVerified clears the value of the "phone_number_verified" field.
func (m *StandardClaimsMutation) ClearPhoneNumberVerified() {
	m.phone_number_verified = nil
	m.clearedFields[standardclaims.FieldPhoneNumberVerified] = struct{}{}
}

// PhoneNumberVerifiedCleared returns if the "phone_number_verified" field was cleared in this mutation.
func (m *StandardClaimsMutation) PhoneNumberVerifiedCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldPhoneNumberVerified]
	return ok
}

// ResetPhoneNumberVerified resets all changes to the "phone_number_verified" field.
func (m *StandardClaimsMutation) ResetPhoneNumberVerified() {
	m.phone_number_verified = nil
	delete(m.clearedFields, standardclaims.FieldPhoneNumberVerified)
}

// SetAddress sets the "address" field.
func (m *StandardClaimsMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *StandardClaimsMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *StandardClaimsMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[standardclaims.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *StandardClaimsMutation) AddressCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *StandardClaimsMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, standardclaims.FieldAddress)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StandardClaimsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StandardClaimsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StandardClaims entity.
// If the StandardClaims object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardClaimsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *StandardClaimsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StandardClaimsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StandardClaimsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[standardclaims.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StandardClaimsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[standardclaims.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StandardClaimsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, standardclaims.FieldUpdatedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StandardClaimsMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StandardClaimsMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StandardClaimsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StandardClaimsMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StandardClaimsMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StandardClaimsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the StandardClaimsMutation builder.
func (m *StandardClaimsMutation) Where(ps ...predicate.StandardClaims) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StandardClaimsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StandardClaimsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StandardClaims, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StandardClaimsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StandardClaimsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StandardClaims).
func (m *StandardClaimsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StandardClaimsMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.subject != nil {
		fields = append(fields, standardclaims.FieldSubject)
	}
	if m.name != nil {
		fields = append(fields, standardclaims.FieldName)
	}
	if m.given_name != nil {
		fields = append(fields, standardclaims.FieldGivenName)
	}
	if m.family_name != nil {
		fields = append(fields, standardclaims.FieldFamilyName)
	}
	if m.middle_name != nil {
		fields = append(fields, standardclaims.FieldMiddleName)
	}
	if m.nickname != nil {
		fields = append(fields, standardclaims.FieldNickname)
	}
	if m.preferred_username != nil {
		fields = append(fields, standardclaims.FieldPreferredUsername)
	}
	if m.profile != nil {
		fields = append(fields, standardclaims.FieldProfile)
	}
	if m.picture != nil {
		fields = append(fields, standardclaims.FieldPicture)
	}
	if m.website != nil {
		fields = append(fields, standardclaims.FieldWebsite)
	}
	if m.email != nil {
		fields = append(fields, standardclaims.FieldEmail)
	}
	if m.email_verified != nil {
		fields = append(fields, standardclaims.FieldEmailVerified)
	}
	if m.gender != nil {
		fields = append(fields, standardclaims.FieldGender)
	}
	if m.birthdate != nil {
		fields = append(fields, standardclaims.FieldBirthdate)
	}
	if m.zoneinfo != nil {
		fields = append(fields, standardclaims.FieldZoneinfo)
	}
	if m.locale != nil {
		fields = append(fields, standardclaims.FieldLocale)
	}
	if m.phone_number != nil {
		fields = append(fields, standardclaims.FieldPhoneNumber)
	}
	if m.phone_number_verified != nil {
		fields = append(fields, standardclaims.FieldPhoneNumberVerified)
	}
	if m.address != nil {
		fields = append(fields, standardclaims.FieldAddress)
	}
	if m.updated_at != nil {
		fields = append(fields, standardclaims.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StandardClaimsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case standardclaims.FieldSubject:
		return m.Subject()
	case standardclaims.FieldName:
		return m.Name()
	case standardclaims.FieldGivenName:
		return m.GivenName()
	case standardclaims.FieldFamilyName:
		return m.FamilyName()
	case standardclaims.FieldMiddleName:
		return m.MiddleName()
	case standardclaims.FieldNickname:
		return m.Nickname()
	case standardclaims.FieldPreferredUsername:
		return m.PreferredUsername()
	case standardclaims.FieldProfile:
		return m.Profile()
	case standardclaims.FieldPicture:
		return m.Picture()
	case standardclaims.FieldWebsite:
		return m.Website()
	case standardclaims.FieldEmail:
		return m.Email()
	case standardclaims.FieldEmailVerified:
		return m.EmailVerified()
	case standardclaims.FieldGender:
		return m.Gender()
	case standardclaims.FieldBirthdate:
		return m.Birthdate()
	case standardclaims.FieldZoneinfo:
		return m.Zoneinfo()
	case standardclaims.FieldLocale:
		return m.Locale()
	case standardclaims.FieldPhoneNumber:
		return m.PhoneNumber()
	case standardclaims.FieldPhoneNumberVerified:
		return m.PhoneNumberVerified()
	case standardclaims.FieldAddress:
		return m.Address()
	case standardclaims.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StandardClaimsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case standardclaims.FieldSubject:
		return m.OldSubject(ctx)
	case standardclaims.FieldName:
		return m.OldName(ctx)
	case standardclaims.FieldGivenName:
		return m.OldGivenName(ctx)
	case standardclaims.FieldFamilyName:
		return m.OldFamilyName(ctx)
	case standardclaims.FieldMiddleName:
		return m.OldMiddleName(ctx)
	case standardclaims.FieldNickname:
		return m.OldNickname(ctx)
	case standardclaims.FieldPreferredUsername:
		return m.OldPreferredUsername(ctx)
	case standardclaims.FieldProfile:
		return m.OldProfile(ctx)
	case standardclaims.FieldPicture:
		return m.OldPicture(ctx)
	case standardclaims.FieldWebsite:
		return m.OldWebsite(ctx)
	case standardclaims.FieldEmail:
		return m.OldEmail(ctx)
	case standardclaims.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case standardclaims.FieldGender:
		return m.OldGender(ctx)
	case standardclaims.FieldBirthdate:
		return m.OldBirthdate(ctx)
	case standardclaims.FieldZoneinfo:
		return m.OldZoneinfo(ctx)
	case standardclaims.FieldLocale:
		return m.OldLocale(ctx)
	case standardclaims.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case standardclaims.FieldPhoneNumberVerified:
		return m.OldPhoneNumberVerified(ctx)
	case standardclaims.FieldAddress:
		return m.OldAddress(ctx)
	case standardclaims.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StandardClaims field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardClaimsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case standardclaims.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case standardclaims.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case standardclaims.FieldGivenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenName(v)
		return nil
	case standardclaims.FieldFamilyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyName(v)
		return nil
	case standardclaims.FieldMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiddleName(v)
		return nil
	case standardclaims.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case standardclaims.FieldPreferredUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferredUsername(v)
		return nil
	case standardclaims.FieldProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case standardclaims.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case standardclaims.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case standardclaims.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case standardclaims.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case standardclaims.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case standardclaims.FieldBirthdate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdate(v)
		return nil
	case standardclaims.FieldZoneinfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZoneinfo(v)
		return nil
	case standardclaims.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case standardclaims.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case standardclaims.FieldPhoneNumberVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumberVerified(v)
		return nil
	case standardclaims.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case standardclaims.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StandardClaims field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StandardClaimsMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_at != nil {
		fields = append(fields, standardclaims.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StandardClaimsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case standardclaims.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardClaimsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case standardclaims.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StandardClaims numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StandardClaimsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(standardclaims.FieldName) {
		fields = append(fields, standardclaims.FieldName)
	}
	if m.FieldCleared(standardclaims.FieldGivenName) {
		fields = append(fields, standardclaims.FieldGivenName)
	}
	if m.FieldCleared(standardclaims.FieldFamilyName) {
		fields = append(fields, standardclaims.FieldFamilyName)
	}
	if m.FieldCleared(standardclaims.FieldMiddleName) {
		fields = append(fields, standardclaims.FieldMiddleName)
	}
	if m.FieldCleared(standardclaims.FieldNickname) {
		fields = append(fields, standardclaims.FieldNickname)
	}
	if m.FieldCleared(standardclaims.FieldPreferredUsername) {
		fields = append(fields, standardclaims.FieldPreferredUsername)
	}
	if m.FieldCleared(standardclaims.FieldProfile) {
		fields = append(fields, standardclaims.FieldProfile)
	}
	if m.FieldCleared(standardclaims.FieldPicture) {
		fields = append(fields, standardclaims.FieldPicture)
	}
	if m.FieldCleared(standardclaims.FieldWebsite) {
		fields = append(fields, standardclaims.FieldWebsite)
	}
	if m.FieldCleared(standardclaims.FieldEmail) {
		fields = append(fields, standardclaims.FieldEmail)
	}
	if m.FieldCleared(standardclaims.FieldEmailVerified) {
		fields = append(fields, standardclaims.FieldEmailVerified)
	}
	if m.FieldCleared(standardclaims.FieldGender) {
		fields = append(fields, standardclaims.FieldGender)
	}
	if m.FieldCleared(standardclaims.FieldBirthdate) {
		fields = append(fields, standardclaims.FieldBirthdate)
	}
	if m.FieldCleared(standardclaims.FieldZoneinfo) {
		fields = append(fields, standardclaims.FieldZoneinfo)
	}
	if m.FieldCleared(standardclaims.FieldLocale) {
		fields = append(fields, standardclaims.FieldLocale)
	}
	if m.FieldCleared(standardclaims.FieldPhoneNumber) {
		fields = append(fields, standardclaims.FieldPhoneNumber)
	}
	if m.FieldCleared(standardclaims.FieldPhoneNumberVerified) {
		fields = append(fields, standardclaims.FieldPhoneNumberVerified)
	}
	if m.FieldCleared(standardclaims.FieldAddress) {
		fields = append(fields, standardclaims.FieldAddress)
	}
	if m.FieldCleared(standardclaims.FieldUpdatedAt) {
		fields = append(fields, standardclaims.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StandardClaimsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StandardClaimsMutation) ClearField(name string) error {
	switch name {
	case standardclaims.FieldName:
		m.ClearName()
		return nil
	case standardclaims.FieldGivenName:
		m.ClearGivenName()
		return nil
	case standardclaims.FieldFamilyName:
		m.ClearFamilyName()
		return nil
	case standardclaims.FieldMiddleName:
		m.ClearMiddleName()
		return nil
	case standardclaims.FieldNickname:
		m.ClearNickname()
		return nil
	case standardclaims.FieldPreferredUsername:
		m.ClearPreferredUsername()
		return nil
	case standardclaims.FieldProfile:
		m.ClearProfile()
		return nil
	case standardclaims.FieldPicture:
		m.ClearPicture()
		return nil
	case standardclaims.FieldWebsite:
		m.ClearWebsite()
		return nil
	case standardclaims.FieldEmail:
		m.ClearEmail()
		return nil
	case standardclaims.FieldEmailVerified:
		m.ClearEmailVerified()
		return nil
	case standardclaims.FieldGender:
		m.ClearGender()
		return nil
	case standardclaims.FieldBirthdate:
		m.ClearBirthdate()
		return nil
	case standardclaims.FieldZoneinfo:
		m.ClearZoneinfo()
		return nil
	case standardclaims.FieldLocale:
		m.ClearLocale()
		return nil
	case standardclaims.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case standardclaims.FieldPhoneNumberVerified:
		m.ClearPhoneNumberVerified()
		return nil
	case standardclaims.FieldAddress:
		m.ClearAddress()
		return nil
	case standardclaims.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown StandardClaims nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StandardClaimsMutation) ResetField(name string) error {
	switch name {
	case standardclaims.FieldSubject:
		m.ResetSubject()
		return nil
	case standardclaims.FieldName:
		m.ResetName()
		return nil
	case standardclaims.FieldGivenName:
		m.ResetGivenName()
		return nil
	case standardclaims.FieldFamilyName:
		m.ResetFamilyName()
		return nil
	case standardclaims.FieldMiddleName:
		m.ResetMiddleName()
		return nil
	case standardclaims.FieldNickname:
		m.ResetNickname()
		return nil
	case standardclaims.FieldPreferredUsername:
		m.ResetPreferredUsername()
		return nil
	case standardclaims.FieldProfile:
		m.ResetProfile()
		return nil
	case standardclaims.FieldPicture:
		m.ResetPicture()
		return nil
	case standardclaims.FieldWebsite:
		m.ResetWebsite()
		return nil
	case standardclaims.FieldEmail:
		m.ResetEmail()
		return nil
	case standardclaims.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case standardclaims.FieldGender:
		m.ResetGender()
		return nil
	case standardclaims.FieldBirthdate:
		m.ResetBirthdate()
		return nil
	case standardclaims.FieldZoneinfo:
		m.ResetZoneinfo()
		return nil
	case standardclaims.FieldLocale:
		m.ResetLocale()
		return nil
	case standardclaims.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case standardclaims.FieldPhoneNumberVerified:
		m.ResetPhoneNumberVerified()
		return nil
	case standardclaims.FieldAddress:
		m.ResetAddress()
		return nil
	case standardclaims.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown StandardClaims field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StandardClaimsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, standardclaims.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StandardClaimsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case standardclaims.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StandardClaimsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StandardClaimsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StandardClaimsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, standardclaims.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StandardClaimsMutation) EdgeCleared(name string) bool {
	switch name {
	case standardclaims.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StandardClaimsMutation) ClearEdge(name string) error {
	switch name {
	case standardclaims.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown StandardClaims unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StandardClaimsMutation) ResetEdge(name string) error {
	switch name {
	case standardclaims.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown StandardClaims edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	username               *string
	password               *string
	clearedFields          map[string]struct{}
	user_pool              *string
	cleareduser_pool       bool
	standard_claims        *int
	clearedstandard_claims bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetUserPoolID sets the "user_pool" edge to the UserPool entity by id.
func (m *UserMutation) SetUserPoolID(id string) {
	m.user_pool = &id
}

// ClearUserPool clears the "user_pool" edge to the UserPool entity.
func (m *UserMutation) ClearUserPool() {
	m.cleareduser_pool = true
}

// UserPoolCleared reports if the "user_pool" edge to the UserPool entity was cleared.
func (m *UserMutation) UserPoolCleared() bool {
	return m.cleareduser_pool
}

// UserPoolID returns the "user_pool" edge ID in the mutation.
func (m *UserMutation) UserPoolID() (id string, exists bool) {
	if m.user_pool != nil {
		return *m.user_pool, true
	}
	return
}

// UserPoolIDs returns the "user_pool" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserPoolID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserPoolIDs() (ids []string) {
	if id := m.user_pool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserPool resets all changes to the "user_pool" edge.
func (m *UserMutation) ResetUserPool() {
	m.user_pool = nil
	m.cleareduser_pool = false
}

// SetStandardClaimsID sets the "standard_claims" edge to the StandardClaims entity by id.
func (m *UserMutation) SetStandardClaimsID(id int) {
	m.standard_claims = &id
}

// ClearStandardClaims clears the "standard_claims" edge to the StandardClaims entity.
func (m *UserMutation) ClearStandardClaims() {
	m.clearedstandard_claims = true
}

// StandardClaimsCleared reports if the "standard_claims" edge to the StandardClaims entity was cleared.
func (m *UserMutation) StandardClaimsCleared() bool {
	return m.clearedstandard_claims
}

// StandardClaimsID returns the "standard_claims" edge ID in the mutation.
func (m *UserMutation) StandardClaimsID() (id int, exists bool) {
	if m.standard_claims != nil {
		return *m.standard_claims, true
	}
	return
}

// StandardClaimsIDs returns the "standard_claims" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StandardClaimsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) StandardClaimsIDs() (ids []int) {
	if id := m.standard_claims; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStandardClaims resets all changes to the "standard_claims" edge.
func (m *UserMutation) ResetStandardClaims() {
	m.standard_claims = nil
	m.clearedstandard_claims = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_pool != nil {
		edges = append(edges, user.EdgeUserPool)
	}
	if m.standard_claims != nil {
		edges = append(edges, user.EdgeStandardClaims)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserPool:
		if id := m.user_pool; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeStandardClaims:
		if id := m.standard_claims; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_pool {
		edges = append(edges, user.EdgeUserPool)
	}
	if m.clearedstandard_claims {
		edges = append(edges, user.EdgeStandardClaims)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserPool:
		return m.cleareduser_pool
	case user.EdgeStandardClaims:
		return m.clearedstandard_claims
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeUserPool:
		m.ClearUserPool()
		return nil
	case user.EdgeStandardClaims:
		m.ClearStandardClaims()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserPool:
		m.ResetUserPool()
		return nil
	case user.EdgeStandardClaims:
		m.ResetStandardClaims()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserPoolMutation represents an operation that mutates the UserPool nodes in the graph.
type UserPoolMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	users         map[string]struct{}
	removedusers  map[string]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*UserPool, error)
	predicates    []predicate.UserPool
}

var _ ent.Mutation = (*UserPoolMutation)(nil)

// userpoolOption allows management of the mutation configuration using functional options.
type userpoolOption func(*UserPoolMutation)

// newUserPoolMutation creates new mutation for the UserPool entity.
func newUserPoolMutation(c config, op Op, opts ...userpoolOption) *UserPoolMutation {
	m := &UserPoolMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPoolID sets the ID field of the mutation.
func withUserPoolID(id string) userpoolOption {
	return func(m *UserPoolMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPool
		)
		m.oldValue = func(ctx context.Context) (*UserPool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPool sets the old UserPool of the mutation.
func withUserPool(node *UserPool) userpoolOption {
	return func(m *UserPoolMutation) {
		m.oldValue = func(context.Context) (*UserPool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPool entities.
func (m *UserPoolMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPoolMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPoolMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *UserPoolMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *UserPoolMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *UserPoolMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *UserPoolMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *UserPoolMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *UserPoolMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UserPoolMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the UserPoolMutation builder.
func (m *UserPoolMutation) Where(ps ...predicate.UserPool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPoolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPoolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPoolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPoolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPool).
func (m *UserPoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPoolMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPoolMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown UserPool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserPool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPoolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPoolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPoolMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown UserPool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPoolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPoolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserPool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPoolMutation) ResetField(name string) error {
	return fmt.Errorf("unknown UserPool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, userpool.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpool.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, userpool.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userpool.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, userpool.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPoolMutation) EdgeCleared(name string) bool {
	switch name {
	case userpool.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPoolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserPool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPoolMutation) ResetEdge(name string) error {
	switch name {
	case userpool.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown UserPool edge %s", name)
}

// WellKnownEndpointConfigMutation represents an operation that mutates the WellKnownEndpointConfig nodes in the graph.
type WellKnownEndpointConfigMutation struct {
	config
	op             Op
	typ            string
	id             *string
	endpoint       *string
	clearedFields  map[string]struct{}
	service        *string
	clearedservice bool
	done           bool
	oldValue       func(context.Context) (*WellKnownEndpointConfig, error)
	predicates     []predicate.WellKnownEndpointConfig
}

var _ ent.Mutation = (*WellKnownEndpointConfigMutation)(nil)

// wellknownendpointconfigOption allows management of the mutation configuration using functional options.
type wellknownendpointconfigOption func(*WellKnownEndpointConfigMutation)

// newWellKnownEndpointConfigMutation creates new mutation for the WellKnownEndpointConfig entity.
func newWellKnownEndpointConfigMutation(c config, op Op, opts ...wellknownendpointconfigOption) *WellKnownEndpointConfigMutation {
	m := &WellKnownEndpointConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeWellKnownEndpointConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWellKnownEndpointConfigID sets the ID field of the mutation.
func withWellKnownEndpointConfigID(id string) wellknownendpointconfigOption {
	return func(m *WellKnownEndpointConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *WellKnownEndpointConfig
		)
		m.oldValue = func(ctx context.Context) (*WellKnownEndpointConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WellKnownEndpointConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWellKnownEndpointConfig sets the old WellKnownEndpointConfig of the mutation.
func withWellKnownEndpointConfig(node *WellKnownEndpointConfig) wellknownendpointconfigOption {
	return func(m *WellKnownEndpointConfigMutation) {
		m.oldValue = func(context.Context) (*WellKnownEndpointConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WellKnownEndpointConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WellKnownEndpointConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WellKnownEndpointConfig entities.
func (m *WellKnownEndpointConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WellKnownEndpointConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WellKnownEndpointConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WellKnownEndpointConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEndpoint sets the "endpoint" field.
func (m *WellKnownEndpointConfigMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *WellKnownEndpointConfigMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the WellKnownEndpointConfig entity.
// If the WellKnownEndpointConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WellKnownEndpointConfigMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *WellKnownEndpointConfigMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *WellKnownEndpointConfigMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *WellKnownEndpointConfigMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *WellKnownEndpointConfigMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *WellKnownEndpointConfigMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *WellKnownEndpointConfigMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *WellKnownEndpointConfigMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the WellKnownEndpointConfigMutation builder.
func (m *WellKnownEndpointConfigMutation) Where(ps ...predicate.WellKnownEndpointConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WellKnownEndpointConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WellKnownEndpointConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WellKnownEndpointConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WellKnownEndpointConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WellKnownEndpointConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WellKnownEndpointConfig).
func (m *WellKnownEndpointConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WellKnownEndpointConfigMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.endpoint != nil {
		fields = append(fields, wellknownendpointconfig.FieldEndpoint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WellKnownEndpointConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wellknownendpointconfig.FieldEndpoint:
		return m.Endpoint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WellKnownEndpointConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wellknownendpointconfig.FieldEndpoint:
		return m.OldEndpoint(ctx)
	}
	return nil, fmt.Errorf("unknown WellKnownEndpointConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WellKnownEndpointConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wellknownendpointconfig.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	}
	return fmt.Errorf("unknown WellKnownEndpointConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WellKnownEndpointConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WellKnownEndpointConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WellKnownEndpointConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WellKnownEndpointConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WellKnownEndpointConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WellKnownEndpointConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WellKnownEndpointConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WellKnownEndpointConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WellKnownEndpointConfigMutation) ResetField(name string) error {
	switch name {
	case wellknownendpointconfig.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	}
	return fmt.Errorf("unknown WellKnownEndpointConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WellKnownEndpointConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.service != nil {
		edges = append(edges, wellknownendpointconfig.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WellKnownEndpointConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wellknownendpointconfig.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WellKnownEndpointConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WellKnownEndpointConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WellKnownEndpointConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservice {
		edges = append(edges, wellknownendpointconfig.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WellKnownEndpointConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case wellknownendpointconfig.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WellKnownEndpointConfigMutation) ClearEdge(name string) error {
	switch name {
	case wellknownendpointconfig.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown WellKnownEndpointConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WellKnownEndpointConfigMutation) ResetEdge(name string) error {
	switch name {
	case wellknownendpointconfig.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown WellKnownEndpointConfig edge %s", name)
}
